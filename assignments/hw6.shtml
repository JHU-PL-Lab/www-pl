<!--#include virtual="/pl/header.html" -->

</div>

<div id="content">


<h2>Programming Languages Assignment 6</h2>
<h4>Due: Friday, April 29th</h4>
<p/>

    The F&#x266d;DK has been designed to support a typechecking extension. 
    Use the F&#x266d;DK to implement the type inference algorithm for <strong>EF&#x266d;</strong> in OCaml. Your implementation is expected to handle all of EF&#x266d; with the exception of <tt>Let Rec</tt>.
</p><p>
  To complete this assignment, you will need to open <tt>fbtype.ml</tt> in the <tt>src/Fb</tt> directory and implement the <tt>typecheck</tt> function.  This function must return the type of that expression as specified by the EF&#x266d; algorithm; you should use the <tt>fbtype</tt> data type which appears in <tt>fbast.ml</tt>.  You should set <tt>typecheck_default_enabled</tt> to <tt>true</tt> in <tt>fbtype.ml</tt> to enable the typechecker.

  <p><b>Turn in your <tt>fbtype.ml</tt> file and nothing else.</b>  Do not change fbast.ml or similar files, since your code will be tested with an otherwise correct implementation of the F&#x266d;DK by dropping your <tt>fbtype.ml</tt> file in.
</p><p>
    The F&#x266d; binary from the website also supports typechecking. You can turn it on by passing <tt>--typecheck</tt> to it. As an example, a correctly working interpreter should behave as follows:
</p>
<pre>
Fb version 1.23         (typechecker enabled)

# (Function x -> Function y -> x + y) 4;;
: Int -> Int
==> Function y ->
4 + y
# Function x -> x;;    
: 'a -> 'a
==> Function x ->
x
# True + 1;;
Exception: Fbtype.TypeInferenceFailure("immediately inconsistent types")
</pre>
<p>
    Note that, by default, the type of the expression is printed. Look at the command line options with <tt>--help</tt> for more information.
</p>
<p>
    Note also that the exception which is raised by a type error is defined in the <tt>fbtype.ml</tt> module; you must define your own exception(s) to throw when the expression cannot be assigned a type.
</p><p>
    You need to implement the full algorithm <em>except</em> you do not need  to implement the cycle detection algorithm - your checker can loop forever on programs with cyclic constraints (but only on such programs). You don't need to implement the let-polymorphism of PEF&#x266d;.
</p><p>
    Here are some suggestions:
</p>
<ul>
    <li>
        <p>
            The reference implementation binaries that we provide for this class already have an implementation of EF&#x266d;, so you can experiment.  Run the <tt>Fb</tt> binary with the flag <tt>--typecheck</tt>.  (Using this flag is equivalent to setting <tt>typecheck_default_enabled</tt> to <tt>true</tt>.)
        </p>
    </li>
    <li>
        <p>
            Break down your implementation into the same phases as in the book:
        </p>
        <ol>
            <li>
                <p>
                    Generate the type <code>&tau; \ E</code> using the ideas in the type system (and also following the typechecker for <code>TF&#x266d;</code> in the book),
                </p>
            </li>
            <li>
                <p>
                    Perform the closure on <code>E</code>,
                </p>
            </li>
            <li>
                <p>
                    Check the closure for immediate inconsistencies, and
                </p>
            </li>
            <li>
                <p>
                    Substitute equations of <code>E</code> into <code>&tau;</code> to solve.
                </p>
            </li>
        </ol>
    </li>
    <li>
        <p>
            The <code>E</code> is a set of pairs (the type equations &tau; = &tau;'); the built-in Caml types such as <code>Set</code> or <code>Map</code> may prove useful in your implementation of this data structure.
        </p>
    </li>
    <li>
        <p>
            In the closure outlined in the book, we assumed = was symmetric; in your implementation, one easy (but inefficient) method to achieve this to add an additional closure step: every time you add &tau; = &tau;' to the closure, also add &tau;' = &tau;.
        </p>
    </li>
    <li>
        <p>
            The "substitute to solve" phase is the same idea as your substitution function you wrote on terms; just do it on types.
        </p>
    </li>
    <li>
        <p>
            During testing, it may be useful to run your interpreter with the <tt>--show-backtrace</tt>. This will give you a stack trace for any exceptions that occur. Unfortunately this feature works only on the compiled binary and not in the interpreter.
        </p>
    </li>
    <li>
        <p>
            Don't worry about efficiency.  <b>Do</b> worry about correctness.
        </p>
    </li>
</ul>

</div>

<!--#include virtual="/pl/footer.html" -->
