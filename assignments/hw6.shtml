<!--#include virtual="/~scott/pl/header.html" -->

</div>

<div id="content">


<h2>Programming Languages Assignment 6</h2>
<h4>Due: Friday May 6th</h4>
<p/>

<ol>
	<li>
  		<b>(75 points)</b>
		<p>
			Implement the type inference algorithm for <strong>EF&#x266d;</strong> in Caml.  You are to use the book presentation (also given in class) as the "specification" of your implementation.  Write a function <code>typecheck</code> which takes an expression and either returns the inferred type of <strong>F&#x266d;</strong> program <code>e</code> or raises an exception if type inference fails.
		</p><p>
			You need to implement the full algorithm <em>except</em> you do not need  to implement the cycle detection algorithm - your checker can loop forever on programs with cyclic constraints (but only on such programs).  Extra credit will be given for implementing cycle detection.  Also you don't need to include let-polymorphism.
		</p><p>
			Here are some suggestions:
		</p>
		<ul>
  			<li>
  				<p>
  					Use the F&#x266d;DK and just modify your file fbinterp.ml to include <code>typecheck</code> and affiliated functions.
  				</p>
  			</li>
  			<li>
  				<p>
  					Types need an abstract syntax.   Here is a good one:
  				</p>
  				<pre>type fbtype = TInt | TBool | TArrow of fbtype * fbtype | TVar of string</pre>
  				<p>
					The "T" prefixes above are for "type".  <code>'a</code> has
					the abstract syntax <code>TVar "a"</code>.
				</p>
			</li>
  			<li>
  				<p>
  					Break down your implementation into the same phases as in the book:
  				</p>
      			<ol>
					<li>
						<p>
							Generate the type <code>&tau; \ E</code> using the ideas in the type system (and also following the typechecker for <code>TF&#x266d;</code> in the book),
						</p>
					</li>
					<li>
						<p>
							Perform the closure on <code>E</code>,
						</p>
					</li>
					<li>
						<p>
							Check the closure for immediate inconsistencies, and
						</p>
					</li>
					<li>
						<p>
							Substitute equations of <code>E</code> into <code>&tau;</code> to solve.
						</p>
					</li>
      			</ol>
      		</li>
  			<li>
  				<p>
  					The <code>E</code> is a set of pairs (the type equations &tau; = &tau;'); the built-in Caml types such as <code>Set</code> or <code>Map</code> may prove useful in your implementation of this data structure.
  				</p>
  			</li>
  			<li>
  				<p>
  					In the closure outlined the book we assumed = was symmetric; in your implementation, one easy (but inefficient) method to achieve this is every time you add &tau; = &tau;' also add &tau;' = &tau;.
  				</p>
  			</li>
  			<li>
  				<p>
  					The "substitute to solve" phase is the same idea as your substitution function you wrote on terms, just do it on types.
  				</p>
  			</li>
  			<li>
  				<p>
  					Don't worry about efficiency.  <b>Do</b> worry about correctness.
  				</p>
  			</li>
  		</ul>
  	</li>
  	<li>
  		<b>(25 points)</b>
  		<p>
			This question concerns concurrency.  Please refer to Chapter 7 in the book.
    	</p>
        <p>
            One application of the actor model is in the telephony switching system.  Consider a case in which we have customers calling a phone bank of tech support staff.  The different kinds of actors in this model include the customer, the tech support staff, and the phone bank itself.  Customers initially only have access to the phone bank (because they only know the customer support phone number); the phone bank then relays them to an available staff member.  A conversation ensues between the customer and the staff member until the customer's problem is resolved; afterward, the customer hangs up (terminates) and the staff member notifies the phone bank that he/she is available to take another call.  This process continues until all customers have been helped.
        </p>
        <p>
            Our model starts by sending customers a message <tt>`broken(0)</tt>.  Customers then send a message <tt>`call(self)</tt> to the phone bank; the phone bank responds with <tt>`connect(staff)</tt>, which connects the customer with a staff member.  The customer then sends a message <tt>`help(self)</tt>; the staff member replies with <tt>`answer(self)</tt>.  The customer replies <tt>`thanks(0)</tt>.  The staff member then sends <tt>`ready(self)</tt> to the phone bank.  (Each message containing a non-zero value contains a reference to an actor.)
        </p>
        <p>
            You will write AF&#x266d;rVR code (F&#x266d; with actors, rings, variants and records) which implements this actor model of the phone bank.  You may also assume that this version of rings allows rings of zero length (which can be created by the syntax <tt>EmptyRing</tt>, as in <tt>Let x = EmptyRing In</tt>...) and that <tt>RingSize</tt> is available.  You may also use <tt>Let Rec</tt>, <tt>Let</tt>...<tt>In</tt>, and the sequence operator <tt>;</tt>.  Your answer will be in the form of a function
        </p>
        <pre>
            Function numCustomers -> Function numStaff -> ...
        </pre>
        <p>
            This function will, when applied to arguments, <tt>Create</tt> one phone bank and an appropriate number of customers and staff.  It then sends the correct <tt>`broken(0)</tt> to each customer to get things started.  You can imagine the initial state of the system being a startup message passed to a single actor whose only behavior is to evaluate your function.
        </p>
        <p>
            Here are some hints to get you started:
        </p>
        <ul>
            <li>
                <p>
                    Before you write any actor code at all, stop to consider what states an actor may have and how an actor transitions from one state to another.  It may be helpful to write a state transition diagram if you are familiar with UML.
                </p>
            </li>
            <li>
                <p>
                    There will often be more customers than support staff.  As a result, your phone bank may not have an available staff member when a <tt>`call(0)</tt> is received.  You will need to have some way of tracking which customers are currently "on hold".
                </p>
            </li>
            <li>
                <p>
                    It may be helpful to use <tt>Let</tt>...<tt>In</tt> in order to define certain utility functions.  For instance, you might write a function which, when invoked with a reference to the phone bank, creates and returns a customer actor.
                </p>
            </li>
            <li>
                <p>
                    Remember to use the built-in AF&#x266d; function <code>Create</code> to launch your actors.  Also, remember to kick off the calls by passing <tt>`broken(0)</tt> to each customer.
                </p>
            </li>
            <li>
                <p>
                    Observe that the phone bank has to have a reference to all of the staff (so it can give customers references to them) and the staff member has to have a reference to the phone bank (so it can report that it is now available).  Because this is a circular reference, you won't be able to make both entities have access to the other when they are defined.  But you can make one of them expect an initialization message; for instance, you can write the staff member actor to expect an <tt>`init(phonebank)</tt> message as the first message it receives.
                </p>
            </li>
            <li>
                <p>
                    If something unexpected happens (like the customer sending a <tt>`profanity(0)</tt> message), you are permitted to diverge.  No error handling is expected.
                </p>
            </li>
            <li>
                <p>
                    Because you are writing this code in AF&#x266d;rV (a language for which you do not have an interpreter), we will overlook the occasional syntax mistake (e.g., a missing semicolon).  But the semantics of your program are important; make sure your program does what you think it does.
                </p>
            </li>
            <li>
                <p>
                    A relatively straightforward implementation of this problem comes to about 60 lines of code (give or take, depending on how you format it and where your like breaks are).  You answer should not need to be hundreds of lines long, but any 20 line solution is probably missing something.
                </p>
            </li>
        </ul>
    </li>
</ol>

</div>

<!--#include virtual="/~scott/pl/footer.html" -->
