<!--#include virtual="/pl/header.html" -->	 
</div>

<!-- Main -->
<div id="main" class="wrapper style4">

<!-- Content -->
<div id="content" class="container">
<section>
<header class="major">

<h2>PL Take Home Midterm</h2>
<h4>Due: Wednesday Apr 12th (and due late no later than Fri Apr 14th)</h4>
</header>

  <ol>
     <li>[10 points]  This question concerns mutual recursion.
      <ol class="a">
	<li>Write mutually recursive functions <code>
	    iseven
	  </code>
	  and <code>
	    isodd
	  </code>
	  in <strong>Fb</strong> without using <code>Let Rec</code>.  You can use Y combinator, self-passing, or a variation on one of these, whatever gets the job done.  Your functions need only work on non-negative numbers.
	<li>Use your idea in a. to make general sugar for mutual recursion.  OCaml supports  the <code>and</code> syntax
	  <pre>
	    let rec f x = ...
	    and     g y = ... 
	    in            ... </pre>
	  to allow mutually recursive functions
  to be defined.  Write an <strong>Fb</strong> macro to support this,
  just for the case of two mutually recursive functions of one
  argument:
      <pre>Let Rec f x = e And g y = e' In e'' =def= (you fill in)</pre>
</ol>

     <li> [17 Points] Consider the language <strong>FbC</strong>, <strong>Fb</strong> extended with a simple global stateful
       integer counter.  The counter can go <code>Up</code>, and <code>Down</code> (including into negative numbers), and you can check if the counter has
       been <code>Zeroed</code>.  The initial counter value when the program starts is always zero.  <code>Up/Down</code> move the counter, and additionally return a value: <code>True</code> if the counter just was set to zero and
       <code>False</code> if not.  For example (we use the macro encodings of <code>Let</code> and ";" here):<br>

       <code>Up   ==>   False</code> (* the counter is now 1 so we return False *)<br>
       <code> Up; Up; Down; Down   ==>   True</code> (* the last Down returns True because it zeroed the counter *)<br>
       <code>Let fourup = (Function x -> Up; Up; Up; Up) In fourup 0; Zeroed   ==>   False</code>

<ol class="a">
  <li> <code>Zeroed</code> is not strictly needed as primitive syntax, define <code>Zeroed</code> as a
    macro in terms of other <strong>FbC</strong> constructs.

  <li> Write an encoding of <strong>FbC</strong> in <strong>FbS</strong>: for any <strong>FbC</strong> program, convert it to an <strong>FbS</strong> program
    that will return the same answer.  Note you will need to think about the top level of
    the encoding to get the counter set up properly.

    
  <li>Write operational semantics rules for <strong>FbC</strong>.  You don't need to give all the rules
    for the base <strong>Fb</strong> syntax, just give the new <code>Up/Down/Zeroed</code> rules and the rule for say
    "<code>+</code>" in the <strong>Fb</strong> part.

    </ol>
    <li> [8 Points] Show why the following two expressions cannot typecheck in <strong>TFb</strong> (i.e. no
   derivation tree could ever be built; there are lots of possibilities out there,
   infinitely many, so you need to show none of them will work).  Make sure to build a tree structure schema to show how it won't work, don't just explain in English.
<ol type="i">
  <li>If True Then 0 Else False</li>
  <li>(Function x:(Int -> Int) -> x x)</li>
</ol>


  <li>[15 points]  This question concerns subtyping in
    <strong>STFbR</strong>.
<ol type="a">
  <li>Give a function type with only <em>one</em> subtype, other
      than itself.
  <li>The function subtyping rule is "contravariant" -- it states that if <code>t2 &lt;: t1</code> and <code>t1' &lt;: t2'</code>, then <code>t1 -> t1' &lt;: t2 -> t2'</code>.  Observe how it is  <code>t2 &lt;: t1</code>, flipping the relation on the function domain.  Suppose we had instead used the incorrect rule where things were not flipped (the language Eiffel in fact did this, and paid the consequences): if <code>t1 &lt;: t2</code> and <code>t1' &lt;: t2'</code>, then <code>t1 -> t1' &lt;: t2 -> t2'</code>.  Show this incorrect rule is unsound by finding a program which will typecheck in <strong>STFbR</strong> with this new rule, but will obviously have a run-time error.
</ol>

 

      </ol>

  
Submission is via Gradescope as usual.  Remember that that you are not allowed to collaborate with others on the midterm, unlike regular assignments.  You still may seek help from CAs and professor like on a regular assigment, but only 1-on-1.


</section>
</div>
</div>


<!--#include virtual="/pl/footer.html" -->


