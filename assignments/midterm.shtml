<!--#include virtual="/pl/header.html" -->	 
</div>

<!-- Main -->
<div id="main" class="wrapper style4">

<!-- Content -->
<div id="content" class="container">
<section>
<header class="major">

<h2>PL Take Home Midterm</h2>
</header>

  <ol>
     <li>[10 points]  This question concerns mutual recursion.
      <ol class="a">
	<li>Write mutually recursive functions <code>
	    iseven
	  </code>
	  and <code>
	    isodd
	  </code>
	  in <strong>Fb</strong> without using <code>Let Rec</code>.  You can use Y combinator, self-passing, or a variation on one of these, whatever gets the job done.  Your functions need only work on non-negative numbers.
	<li>Use your idea in a. to make general sugar for mutual recursion.  OCaml supports  the <code>and</code> syntax
	  <pre>
	    let rec f x = ...
	    and     g y = ... 
	    in            ... </pre>
	  to allow mutually recursive functions
  to be defined.  Write an <strong>Fb</strong> macro to support this,
  just for the case of two mutually recursive functions of one
  argument:
      <pre>Let Rec f x = e And g y = e' In e'' =def= (you fill in)</pre>
</ol>

      
     <li>[10 points] The operational semantics for <strong>FbX</strong> included various rules to "bubble" up any exception raised since the exception needs to percolate up to the nearest syntactically enclosing <tt>Try</tt> block; see the book for details.  For this question, briefly outline how the bubbling rules
       could be implemented in an <strong>FbX</strong> extension to your <strong>Fb</strong> interpreter written in OCaml.  Pseudocode is fine, and you can say e.g. "- is similar to +" etc for cases that are clearly analogous.  You need not explicitly define how Try or Raise are interpreted for this question, but it might help to think about potential ways to implement them so that your bubbling is sensible.
       
    <li> [12 Points] For each of the following expressions either show how they can typecheck in <strong>TFbSRX</strong>, or show that typing is impossible (i.e. no derivation tree could ever be built; there are lots of possibilities out there,
   infinitely many, so you need to show none of them will work).  Make sure to build a tree structure in either case to show clearly why typing is a success or failure.  Recall that the <strong>TFbSRX</strong> rules are given in the book.
<ol class="a">
  <li><code>If True Then 0 Else False</code></li>
  <li><code>(Fun x : { a : Int } -> x.a - 1) {a = 5; b=7}</code></li>
  <li><code>(Fun f : (Int Ref -> Int) -> f (Ref 4)) (Fun x : Int Ref -> !x)</code></li>
</ol>


  <li>[12 points] For this question consider a very simple language <strong>BL</strong> with just booleans (<tt>True, False</tt>, plus <tt>And, Or, Not</tt> operators) and <tt>Let</tt>.  No functions!  So a sample program would be <tt>Let x = True And False In x And Not x</tt>.
  <ol class="a">
    <li>Give the grammar definitions of expressions <tt>e</tt> and values <tt>v</tt>.</li>
    <li>Given an arbitrary <strong>BL</strong> expression e, define what the <em>bound</em> and <em>free</em> variables in the expression are.</li>
    <li>Define substitution for <strong>BL</strong> expressions: <tt>e[v/x]</tt>.  You can assume that as with <strong>Fb</strong> etc, the values <tt>v</tt> are closed.
    <li>We only needed to define substitution for <em>closed</em> <tt>v</tt> in <strong>Fb</strong> (and <strong>BL</strong>).  Why is that?
</li>

  </ol>

<li>[12 points] Atomic subtyping is the subtyping concept applied
  to atomic types such as <tt>int</tt>, <tt>float</tt>, etc to give another view of
  overloading.  It makes some sense 
  that "integers are subtypes of floats"  since integers are a subset of the floating-point numbers. For our case, consider
  adding  <code>Bool &lt;: Int</code> to our  <strong>STFbR</strong>
  subtype language to give  an extension <strong>STFbR'</strong>: <code>0</code> will be used as boolean <code>False</code>, 
  and <tt>1</tt> as boolean <code>True</code> (and, no other integers can be considered booleans and <tt>True</tt>/<tt>False</tt> are removed from the grammar syntax).  This should allow integers to be used as booleans similar to how e.g. C works, but also keeping the built-in ones.
<ol class="a">
  <li> Give the subtype of <code>(Int -> Int) -> ((Int -> Int)-> Bool)
      -> Bool</code> which contains the the most <code>Bool</code>'s in the type.</li>
  <li>Repeat the previous but with the <em>fewest</em> <tt>Bool</tt>'s.

  <li> The current <strong>Fb</strong> interpreter would not work on such programs since it expects <tt>True/False</tt> boolean values.  Give the modified <tt>And</tt> and <tt>=</tt> operational semantics rules and modified interpreter clauses for these two cases which would properly interpret 0/1 as false/true.

    <li>The function subtyping rule is "contravariant" -- it states that if <code>t2 &lt;: t1</code> and <code>t1' &lt;: t2'</code>, then <code>t1 -> t1' &lt;: t2 -> t2'</code>.  Observe how it is  <code>t2 &lt;: t1</code>, flipping the relation on the function domain.  Suppose we had instead used the incorrect rule where things were not flipped (the language Eiffel in fact did this, and paid the consequences): if <code>t1 &lt;: t2</code> and <code>t1' &lt;: t2'</code>, then <code>t1 -> t1' &lt;: t2 -> t2'</code>.  Show this incorrect rule is unsound by finding a program which will typecheck in <strong>STFbR'</strong> with this new rule, but will obviously have a run-time error.

   </ol>


    </body> </html>




      </ol>

  
Submission is via Gradescope as usual.  Remember that that you are not allowed to collaborate with others on the midterm, unlike regular assignments.  You still may seek help from CAs and professor like on a regular assigment, but only 1-on-1.


</section>
</div>
</div>


<!--#include virtual="/pl/footer.html" -->


