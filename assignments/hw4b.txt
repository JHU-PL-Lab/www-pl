600.426 - Programming Languages
JHU Spring 2014
Homework 4 Part 2 (60 points)

--------------------------------------------------------------------------------------------------
HEADER: PLEASE FILL THIS IN
--------------------------------------------------------------------------------------------------

Name                  :
List of team Members  :
List of discussants   :

--------------------------------------------------------------------------------------------------
Operational Equivalence (20 points)
--------------------------------------------------------------------------------------------------

1. For each of the following expressions, indicate whether operational
   equivalence holds in the language specified. If it does not, show
   some context that evaluates differently dependent upon which of the
   two expressions you use. (Remember: it only takes one of the
   infinitely many contexts to make the two expressions operationally
   inequivalent)

  e1 and e2 are arbitrary expressions; x and y are variables.

  Assume that semicolon is encoded as in section 4.1.1 of the book.

  FbS: for this section, e1 and e2 are FbS expressions and contexts may
  contain FbS expressions (Ref, !, and :=, for example, are allowed).

  a. e1 ~= e1; e1
  b. e1 + e2 =~ e2 + e1
  c. e1 ; 0 0 =~ 0 0
  d. x := y =~ x := y ; x := y
  e. x := y =~ y
  f. Let x = y In !x + !y =~ !y + !y

  FbX: for this section, e1 and e2 are FbX expressions and contexts may
  contain FbX expressions (Raise, Try-With, and #exn, for example, are
  allowed).

  g. e1 ~= e1 ; e1
  h. e1 + e2 =~ e2 + e1
  i. e1 ; 0 0 =~ 0 0
  j. Function x -> #Exn 0 =~ Function x -> Raise #Exn 0

--------------------------------------------------------------------------------------------------
Operational Semantics (Proof Trees) (8 points)
--------------------------------------------------------------------------------------------------

2. Construct a proof of evaluation for the following FbX expression:

  Try (Try (Raise #Exn2 0) With #Exn1 n -> n - 1) With #Exn2 n -> n + 1

--------------------------------------------------------------------------------------------------
Translation and Encoding (Part 1: 20 points)
--------------------------------------------------------------------------------------------------

3. Consider a simplified version of FbS where there is only one cell
   (FbS-). The grammar of FbS- and some examples to get an intuition
   follow:

   The grammar of FbS- includes two new expression forms:

      e ::= ... | Get | Put e

   The following are some example FbS- expressions followed by their
   expected output and the contents of the cell after their evaluation:

   (Assume semicolon and While-Do are encoded as in section 4.1.1 of the
   book.)

     True
       => (True, 0)

     Get
       => (0, 0)

     Put False; True
       => (True, False)

     Put False
       => (0, False)

     Put 7; While Not Get = 1 Do Put (Get - 1); False
       => (False, 1)

     Let Rec summate x =
       If x = 0
       Then Get
       Else (Put (Get + x) ; summate (x - 1))
     In (Put 0 ; summate 5)
       => (15, 15)

     Let withState = Function state -> Function f ->
       Let savedState = Get In
         Put state ;
         Let ret = f 0 In
           Put savedState ;
           ret
     In Put 9; withState 5 (Function x -> Get + 1)
       => (6, 9)

     Put 4 ;
     (If Get = 4
     Then
       (Put (Get + 1))
     Else
       (Put (Get + 2)))
     ; False
       => (False, 5)

   FbS- differes from FbS in a few ways: there is no need for "Ref"
   operator (assume that the cell is always in scope and starts out
   containing the value "0") or for cell names, and assignment and
   dereference become unary and nullary operations, respectively. In
   this assignment, you will be asked to encode parts of FbS- in Fb with
   pairs (FbP).

   Recall that FbP has three new expression forms and one new value form.

     e ::= ... | (e, e) | Left e | Right e
     v ::= ... | (v, v)

   Section 5.2.3 of the book defines a translation from FbOB to FbSR;
   here we will define a translation from FbS- to FbP.

   We will represent values in this language as pairs in FbP, the Right
   side representing the state of the cell and the Left side
   representing the actual value. For example, "(0, 1)" represents the
   value "0" when the cell contains the value "1". Expressions are
   represented as functions returning pairs, whose input is the state in
   which they are run.

   We use [| e |] to indicate the translation of terms from FbS- to FbP.

   To ensure the correct behavior of Get before any Puts have occurred,
   we need a slightly different translation for top-level expressions
   than for internal ones:

     TopLevel( e ) = [| e |] 0

   We define some of these operations; fill in the others such that the
   examples evaluate correctly.

   [| e1 + e2 |] =
     Function s0 ->
       Let v1 = [| e1 |] s0 In
       Let v2 = [| e2 |] (Right v1) In
       (v1 + v2, Right v2)

   [| Function x -> e |] =
     Function s0 -> (Function x -> Function s1 -> [| e |] s1, s0)

   [| v |] (where v is not a function) =
     Function s0 -> (v, s0)

   [| e1 e2 |] =
     Function s0 ->
       Let v1 = [| e1 |] s0 In
       Let v2 = [| e2 |] (Right v1) In
       ((Left v1) (Left v2)) (Right v2)

   [| Let Rec f x = e1 In e2 |] = 
     Function s0 ->
       Let Rec f x = [| e1 |] In [| e2 |] s0


   [| Put e1 |] =
     Function s0 ->
       Let v1 = [| e1 |] s0 In
       (0, v1)

   a. [| Get |] = Function s0 -> ?

   b. [| Not e1 |] = ?

   c. [| If e1 Then e2 Else e3 |] = ?

   Examples (note how [| |] differs from TopLevel( )):

     [| True |]
       => Function s0 -> (True, s0)

     TopLevel( True )
       => (True, 0)

     [| Get |]
       => Function s0 -> (0, s0)

     TopLevel( Get )
       => (0, 0)

     [| Put False; True |] =
       => v
       where v =~ Function s0 -> (True, False)

     TopLevelTranslate( Put False; True )
       => (True, False)

   Put always evaluates to zero but changes the state. Let us consider a
   similar operation, Put', that evaluates to the value written to the
   state.

   Examples:

     Put' 5
       => (5, 5)

     (Put' 6) + 1
       => (7, 6)

   How would you translate Put' from FbS- to FbP

   d. [| Put' e1 |] = ?

   How would you encode Put' in FbS-? (That is, imagine that Put' is a
   macro in FbS- written in terms of other FbS- expressions, simliar to
   how Let is a macro over Fb.)

   e. Put' e1 def= ?

   For each of the following, provide an e1 such that the FbS-
   expression given evaluates to True:

   f. (These two should be straightforward)

      1. e1 ; True
      2. e1

   g. e1 ; Get

   h. e1 ; Get 0

   i. e1 ; 
      (If Get 0
       Then False
       Else (If Not (Get 1) 
             Then False
             Else (If Get 2
                   Then False
                   Else True)))

      (That is to say, "Get 0" is False, "Get 1" is True, and "Get 2" is
      False.)

   j. If (e1 + Get) = 0
      Then Get = 3
      Else False

--------------------------------------------------------------------------------------------------
Translation and Encoding (Part 2: 12 points)
--------------------------------------------------------------------------------------------------

   Write a translation function [| |] from FbS to FbS-. Your translation
   may be more permissive than the FbS semantics but must be faithful:

   That is to say, if e => v in FbS, then [| e |] => v' in FbS- where v'
   is, in some sense, equivalent v (this is not operational equivalence,
   since we are operating over two different languages), but if e =/> in
   FbS, then [| e |] is unconstrained.

   It need not be the case that if [| e |] => v' in FbS- then e => v in
   FbS.

   (Hints:
     You will need some way of representing cell names; how about
     integers?

     You will need some way to get the value out of a cell and some way
     to put a value into a cell; how would you represent a map in Fb?

     You will need some way of remembering which cell names have been
     created by a Ref expression; how about a counter?

     You will need somewhere to store such a counter; how about in a
     cell that programmers are not expected to interact with?)

   l. [| Ref e |] = ?

   m. [| e := e' |] = ?

   n. [| ! e |] = ?

   o. Give an example FbS expression, e, that gets stuck but whose
      corresponding [| e |] does not, or explain why this cannot be the
      case in your translation.
