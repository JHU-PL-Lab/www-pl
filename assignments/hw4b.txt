600.426 - Programming Languages
JHU Spring 2014
Homework 4 Part 2 (60 points)

--------------------------------------------------------------------------------------------------
HEADER: PLEASE FILL THIS IN
--------------------------------------------------------------------------------------------------

Name                  :
List of team Members  :
List of discussants   :

--------------------------------------------------------------------------------------------------
Operational Equivalence (20 points)
--------------------------------------------------------------------------------------------------

1. For each of the following expressions, indicate whether operational
   equivalence holds in the language specified. If it does not, show
   some context that evaluates differently dependent upon which of the
   two expressions you use. (Remember: it only takes one of the
   infinitely many contexts to make the two expressions operationally
   inequivalent)

  e1 and e2 are arbitrary expressions; x and y are variables.

  Assume that semicolon is encoded as in section 4.1.1 of the book.

  FbS

  a. e1 ~= e1; e1
  b. e1 + e2 =~ e2 + e1
  c. e1 ; 0 0 =~ 0 0
  d. x := y =~ x := y ; x := y
  e. x := y =~ y
  f. Let x = y In !x + !y =~ !y + !y

  FbX

  g. e1 ~= e1 ; e1
  h. e1 + e2 =~ e2 + e1
  i. e1 ; 0 0 =~ 0 0
  j. Function x -> #Exn 0 =~ Function x -> Raise #Exn 0

--------------------------------------------------------------------------------------------------
Operational Semantics (Proof Trees) (8 points)
--------------------------------------------------------------------------------------------------

2. Construct a proof of evaluation for the following FbX expression:

  Try (Try (Raise #Exn2 0) With #Exn1 n -> n - 1) With #Exn2 n -> n + 1

--------------------------------------------------------------------------------------------------
Translation and Encoding (Part 1: 20 points)
--------------------------------------------------------------------------------------------------

3. Consider a simplified version of FbS where there is only one cell
   (FbS-). There is no need for "Ref" operator (assume that the cell is
   always in scope and starts out containing the value "0") or for cell
   names, and assignment and dereference become unary and nullary
   operations, respectively. Let's encode this in Fb with pairs (FbP).

   Section 5.2.3 of the book defines a translation from FbOB to FbSR;
   here we will define a translation from FbS- to FbP.

   The grammar of FbS- includes two new expression forms:

      e ::= ... | Get | Put e

   The following are some example FbS- expressions followed by their
   expected output and the contents of the cell after their evaluation:

   (Assume semicolon and While-Do are encoded as in section 4.1.1 of the
   book.)

     True
       => True

     Get
       => (0, 0)

     Put False; True
       => (True, False)

     Put False
       => (0, False)

     Put 7; While Not Get = 1 Do Put (Get - 1); False
       => (False, 1)

     Let Rec summate x =
       If x = 0
       Then Get
       Else (Put (Get + x) ; summate (x - 1))
     In (Put 0 ; summate 5)
       => (15, 15)

     Let withState = Function state -> Function f ->
       Let savedState = Get In
         Put state ;
         Let ret = f 0 In
           Put savedState ;
           ret
     In Put 9; withState 5 (Function x -> Get + 1)
       => (6, 9)

     Put 4 ;
     (If Get = 4
     Then
       (Put (Get + 1))
     Else
       (Put (Get + 2)))
     ; False
       => (False, 5)

   We will represent values in this language as pairs in FbP, the Right
   side representing the state of the cell and the Left side
   representing the actual value. For example, "Pr 0 1" represents the
   value "0" when the cell contains the value "1". Expressions are
   represented as functions returning pairs, whose input is the state in
   which they are run.

   We use [| e |] to indicate the translation of terms from FbS- to FbP.

   We define some of these operations; fill in the others such that the
   examples evaluate correctly.

   (We use "Let Pr x1 x2 = e1 In e2" as shorthand for "Let x0 = e1 In
   Let x1 = Left x0 In Let x2 = Right x1 In e2")

   [| e1 + e2 |] =
     Function s0 ->
       Let Pr v1 s1 = [| e1 |] s0 In
       Let Pr v2 s2 = [| e2 |] s1 In
       Pr (v1 + v2) s2

   [| Function x -> e |] =
     Function s0 -> Pr (Function x -> Function s1 -> [| e |] s1) s0

   [| v |] (where v is not a function) =
     Function s0 -> Pr v s0

   [| e1 e2 |] =
     Function s0 ->
       Let Pr v1 s1 = [| e1 |] s0 In
       Let Pr v2 s2 = [| e2 |] s1 In
       (v1 v2) s2

   [| Let Rec f x = e1 In e2 |] = 
     Function s0 ->
       Let Rec f x = [| e1 |] In [| e2 |] s0

   [| Get |] = Function s0 -> Pr s0 s0

   [| Put e1 |] =
     Function s0 ->
       Let Pr v1 s1 = [| e1 |] s0 In
       Pr 0 v1

   a. [| Not e1 |] = ?

   b. [| If e1 Then e2 Else e3 |] = ?

   Notice that, since all expressions translate to functions, we are not
   quite done; in order to actually run the FbS- program, we need to
   translate the expression occurring at top-level slightly
   differently. Namely, there is some FbP function that we need to pass
   the result to. Replace the question mark with that function:

   c. TopLevelTranslate(e) = ? [| e |]

   Examples:

     [| True |]
       => Function s0 -> Pr True s0

     TopLevelTranslate( True )
       => Pr True 0

     [| Get |]
       => Function s0 -> Pr 0 s0

     TopLevelTranslate( Get )
       => Pr 0 0

     [| Put False; True |] =
       => v
       where v =~ Function s0 -> Pr True False

     TopLevelTranslate( Put False; True )
       => Pr True False

   Put always evaluates to zero but changes the state. Write an
   translation rule for a variant, Put', that evaluates to the value
   written to the state. If you wanted to encode Put', how would you do
   so in FbS-?

   Examples:

     Put' 5
       => (5, 5)

     (Put' 6) + 1
       => (7, 6)

   d. [| Put' e1 |] = ?

   e. Put' e1 def= ?

   For each of the following, provide an e1 such that the FbS-
   expression given evaluates to True:

   f.
      1. e1 ; True
      2. e1

   g. e1 ; Get

   h. e1 ; Get 0

   i. e1 ; 
      (If Get 0
       Then False
       Else (If Not (Get 1) 
             Then False
             Else (If Get 2
                   Then False
                   Else True)))

      (That is to say, "Get 0" is False, "Get 1" is True, and "Get 2" is
      False.)

   j. If (e1 + Get) = 0
      Then Get = 3
      Else False

--------------------------------------------------------------------------------------------------
Translation and Encoding (Part 2: 12 points)
--------------------------------------------------------------------------------------------------

   Write a translation function [| |] from FbS to FbS-. Your translation
   may be more permissive than the FbS semantics but must be faithful:

   That is to say, if e => v in FbS, then [| e |] => v' in FbS- where v'
   is, in some sense, equivalent v (this is not operational equivalence,
   since we are operating over two different languages), but if e =/> in
   FbS, then [| e |] is unconstrained.

   It need not be the case that if [| e |] => v' in FbS- then e => v in
   FbS.

   (Hints:
     You will need some way of representing cell names; how about
     integers?

     You will need some way to get the value out of a cell and some way
     to put a value into a cell; how would you represent a map in Fb?

     You will need some way of remembering which cell names have been
     created by a Ref expression; how about a counter?

     You will need somewhere to store such a counter; how about in a
     cell that programmers are not expected to interact with?

     It might be helpful to think of the state in FbS as a really big
     record, integers as a variant with constructors 0, 1, -1, 2, and so
     on, and of the duality between records and variants described in
     section 3.3.2.)

   l. [| Ref e |] = ?

   m. [| e := e' |] = ?

   n. [| ! e |] = ?

   o. Give an example FbS expression, e, that gets stuck but whose
      corresponding [| e |] does not, or explain why this cannot be the
      case in your translation.
