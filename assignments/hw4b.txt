opsem for records - FbR

opsem for (functional) record extension? (to encode javascript objects??)

variant-based objects

information hiding in objects

dynamic dispatch - random replacing of super with this.  effect of ob1.doit ob2 args

encode prototypes - ob.prototype.blah

opsem for something with state (e.g. while loop)


----------------------------------------------------------------------------------------
Section 1: Stateful Semantics
----------------------------------------------------------------------------------------

1a. In the presence of state, traditional looping constructs make sense once again. Let us
    try introducing a new python style "While" loop to FbS with the following grammar:
      While e: e Else: e

    The behavior of an expression While e1: e2 Else: e3 is as follows:
      - As long as e1 evaluates to True, e2 gets evaluated repeatedly (as you would expect
        in most languages)
      - When e1 evaluates to False, e3 gets evaluated (once) instead.
      - The result of the while expression is the result of e3. The result of e2 is never
        really used. (This is different from Python since while in python does not return 
        a value.  But we like our values)

    E.g. Let t = Ref 0 in
         Let i = Ref 0 in
         While (Not (!i = 10)):
           t := !t + !i + 1 ;
           i := !i + 1
         Else:
           !t

        returns 55;


    Write down the operational semantics for the above While expression as an extension to FbS.
    
1b.

    [20+ Points]


----------------------------------------------------------------------------------------
Section 2: Extensible Records
----------------------------------------------------------------------------------------

2a. We covered the operational semantics of pairs in lecture, but not records.  For this
question, present the operational semantics rules needed for FbR.  First write out the
new expressions to add to Fb, then the new values, and finally the operational semantics
rules.  The book contains a sketch of an interpreter for FbR, but we want operational
semantics rules, not an interpreter.

2b. Consider a new language FbxR - Fb with extensible Records. Extensible records are
like normal FbR, but they can also be FUNCTIONALLY extended - you can define a new
record with one extra field.  Other than the new extension operator, records work just
like in FbR.

Example:
 
    Let r = { x = 3 + 4 ; y = (Function a -> a + 1) ; } In
    Let rnew = r.z <+ True In
      rnew.z (* returns True; note r.z would be a runtime error, r still has no z *)

     (Let in the above is a macros with the usual meaning)

If you extend a field that already exists, it is an override:

    Let r = { x = 3 + 4 ; y = (Function a -> a + 1) ; } In
    Let rnew = r.x <+ True In
      rnew.x (* returns True *)

    The value and expression syntax of FbR will need to be extended to accomodate 
    the new syntax for mutable records. You must provide these extensions along with the
    set of new operational semantics rules required for FbxR.  Since you gave the operational semantics of FbR in question 2a, here you only need to add the syntax and semantics for the extension operator.

    [25 Points]


----------------------------------------------------------------------------------------
Section 3: Inheritance With Extensible Records
----------------------------------------------------------------------------------------

3a.  In the encoding of inheritance in the book section 5.1.5, it was required to
explicitly copy over all inherited fields and methods one by one.  For this question,
re-do the colorPointClass definition in that section using FbSxR (FbSR plus the <+
operator in question 2b above) so that this explicit copying is not needed.

3b. It is also possible to write higher-order class operations using extension.
Write a FbSxR function addPulse which takes a class such as pointClass or colorPointClass
from the book s. 5.1.5 (or any other class encoded in that manner) and adds a boolean
field pulse (initially False), methods pulseOn and pulseOff which change the pulse
setting, and override magnitude so it is 0 if the pulse is off.

Example:
     Let addPulse = Fun ... In
     Let pulsedPoint = addPulse pointClass In
        Let ppOb = pulsedPoint {} In
          ppOb.magnitude ppOb {} (* should return 0 in spite of x,y being (4,3) *)

And, the code should produce the same answer for colorPointClass as well.

[15 points ]


----------------------------------------------------------------------------------------
Section 4: 
----------------------------------------------------------------------------------------



[10 points]
