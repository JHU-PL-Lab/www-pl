<!--#include virtual="/pl/header.html" -->	 
</div>

<!-- Main -->
<div id="main" class="wrapper style4">

<!-- Content -->
<div id="content" class="container">
<section>
<header class="major">
  <h3>Assigment 4: Operational semantics</h3>
</header>

<p>
  <h3>Part A, due before spring break</h3>

Make direct operational semantics rules for the following
  <strong>Fb</strong> extensions.  Note that you can use as few or as
  many rules as you need.  What you <em>must</em> do is write a rule
  that actually does the "work" of the construct; don't just translate
  it into <strong>Fb</strong> syntax or other <strong>Fb</strong> extension already defined that will do the work.
  <br>
<ol>
  <li>Write out the operational semantics rules for for <strong>FbL</strong>, <strong>Fb</strong> with OCaml-style lists. <strong>Fb</strong>'s BNF grammar is extended with the following productions:
    <pre>e ::= .... | [] | e :: e | (Match e With [] -> e | x :: x -> e)</pre>


Programmers will need to build their lists from the above operations -- you don't need to support syntax <tt>[1;2]</tt> since they can just do <tt>1 :: 2 :: []</tt>
Here is a sample program which should evaluate to <tt>11</tt>.

<pre>Match (1 :: (2 :: [])) With [] -> 0 | h :: t -> h + 10</pre>

    For your answer:<ol>
  <li>Make sure to define any new values <tt>v</tt> in <strong>FbL</strong> (beyond those present in <strong>Fb</strong>)</li>
  <li>Give the new operational semantics rules that would have to be 
    added to standard <strong>Fb</strong> rules; you should not need to change the existing rules.
    <li>When your rules are done, test that they work by writing out a complete proof of the above small program execution using your new rules.
    </ol>
<li>The <strong>FbS</strong> operational semantics requires changes to the existing <strong>Fb</strong> rules to thread state through the rules.  We worked through the <tt>Let</tt> rule in lecture, and the book contains the function application rule.
  For this question consider a language <strong>FbLS</strong> which has both lists and state.  Write out state versions of the new operational semantics rules you created for the previous question, making sure to "thread the state" through them. 
</li>
<li>We defined the operational semantics for a language with records, <strong>FbR</strong>, in lecture.  These records are quite weak compared to e.g. Python dictionaries: the labels are fixed and cannot be computed, and records cannot be extended, unlike Python dictionaries.  For this question we will develop a language <strong>FbRe</strong>, which has records that can also be <strong>e</strong>xtended with additional mappings.
In general we will define a "record addition" operation using <tt>+</tt>, so that operation will now also "add" two records together.  <ol>
    <li>Note that no new grammar constructs beyond the <strong>FbR</strong> ones are needed, we already have addition of expressions in the syntax and we are just overloading it.
    <li>Make your extension a strict extension of <strong>FbR</strong>: all of those rules can remain unchanged</li>
    <li>Write a new rule for the <tt>+</tt> operation on records.  Note that if a label occurs in both records, we will let the value in the right side have precedence: <tt> ({a = 4+1; b=6} + {b=False}).b</tt> should evaluate to <tt>False</tt>.
      <li>Test the small program above works correctly: write out the full proof tree for the computation.
      </ol>
  </ol>


<a name="4b"></a>  <h3>Part B</h3>
  
  <ol>
    <li>Implement an interpreter for the variant language <strong>FbReL</strong> which implements the operational semantics extensions you developed in part A:  <strong>FbRe</strong> plus <strong>FbL</strong> plus modify the <tt>And</tt> and <tt>Or</tt> meaning so that they short-circuit.  Lastly, change <tt>=</tt> testing so it works on all types, e.g. <tt>True={}</tt> will return <tt>False</tt>, <tt>{a = 1} = {a = 0 + 1}</tt> is <tt>True</tt>, etc (hint: using OCaml's = this last modification is trivial).
      <p>In order to get you going we have added a scanner/parser/pretty printer for  <strong>FbReL</strong> to the FbDK: there is a new directory <a href="http://pl.cs.jhu.edu/pl/book/_dist/fbdk/src/FbReL/"><tt>FbReL/</tt></a> in the latest version for download.  Like the Fb interpreter, that directory contains a dummy <tt>fbrelinterp.ml</tt> file which you need to complete.  <tt>make fbrel.byte</tt> will also build this <tt>ocamlrun fbrel.byte</tt> interpreter, and the <tt>debugscript/fbrel.ml</tt> file should also work for interacting with the interpreter in the OCaml top loop.   In other words, its more or less identical to how Fb developement worked, and we also supply you with "solution" binaries to check against.
      <p>You will need to port over your <strong>Fb</strong> interpreter code for the basic <strong>Fb</strong> features.  If you lost points for buggy code there, we will be <em>very</em> helpful in getting your basic <strong>Fb</strong> interpreter stuff working now if you ask (i.e. ask any CA and you will be told how to fix your code).  In any case the tests will primarily be on the new features and not on the function calling.  <strong>FbReL</strong> does not include <tt>Let Rec</tt> in the syntax so no need to deal with that if you did not get it in HW3.  The AST type is as usual in the file <a href="http://pl.cs.jhu.edu/pl/book/_dist/fbdk/src/FbReL/fbrelast.ml">fbrelast.ml</a>.  The AST representation is most self-explanatory; for <tt>Match</tt> the argument order is just the order in the syntax.  Use the parser in the debug script to test if you are not sure on the AST format.  Hint: the book contains a sketch of how an interpreter for records works.

     <li> Inheritance can be encoded more elegantly with record addition.
       <ol class="a">
	 <li>
	   Taking your <strong>FbReL</strong> interpreter from the previous question, write out a version of the <code>Point</code>/<code>ColorPoint</code> class example in the book, but where you don't need to "manually copy" fields/methods from the superclass like our <strong>FbSR</strong> version had to do; instead define inheritance by using record addition to <em>extend</em> the record encoding the point object.  Note that we have no mutable fields so follow Section 5.1.1 and make the fields immutable in your encoding; also include the <tt>iszero</tt> method of the 5.1.1 encoding so there is more than one method. Lastly, just make <tt>magnitude</tt>  add the point coordinates (i.e. x + y), no need to implement square and square root; similarly for <tt>brightness</tt> just add the r/g/b values, and simply add brightness and super's magnitude to give the color point magniotude.  Use the code template in <a href="assignment4.ml">assignment4.ml</a> - this template also should help clarify any issues on how your object should work as the tests given there cannot be changed by you - it is how we will test your encoding.</li>
   
	 <li> We covered in lecture and the book how variants and records could be encoded in each other.  For this question you are to translate a small program in <strong>FbV</strong> into <strong>FbReL</strong>, see the  <a href="assignment4.ml">assignment4.ml</a> file for details.</li>
	 <li>One cool thing about extensible records is if you enode variants using extensible records you can append together case variants.  For this question again see  <a href="assignment4.ml">assignment4.ml</a> for a program you will translate to <strong>FbReL</strong>.
  </ol>


  
<h3>Submission and Grading</h3>

<ul>
  <li>Submit a pdf with the answers to part A at "Assignment 4A written" in Gradescope</li>
  <li>Submit files <tt>fbrelinterp.ml</tt> and <tt>assignment4.ml</tt> with the answers to part B at "Assignment 4B code" in Gradescope (don't zip them up just submit two separate files)</li>
    </ul>
	
</section>
</div>
</div>


<!--#include virtual="/pl/footer.html" -->
