<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<HEAD>
<title>PL Final</title>
</HEAD>
<BODY LINK="#0000FF" VLINK="#800080" bgcolor="#F0FFF0">
<h3> 600.426, Programming Languages
<br> Spring 2002
<br> Final Examination
<br> 
</h3>
You can use one handwritten 8.5x11 cheat sheet.
<strong>Good Luck!</strong>
<hr>
<ol><h4>Multiple Choice, 3 pts each</h4>

<li>
  Which of the following standard programming language mechanisms does not involve side effects inherently?
<dl>
<dd> (a) Exceptions
<dd> (b) Objects
<dd> (c) Output (such as <code>print_string</code>)
<dd> (d) Side effects are inherent in all of the above three.
</dl> 




Recall in our <strong>D</strong> interpreter, we have a <code>subst</code> function to deal with substitution, with a structure shown below, meaning for each occurence of <code>ident</code> in expression <code>wholeterm</code>, <code>interm</code> is going to substituted in. 

This question is designed to ask what should be filled in for the <code>Let</code> case. Let(i, t1, t2) is the same as ``Let i = t1 In t2''. 

<pre>
subst wholeterm interm ident =
      match wholeterm with
         Plus(t1, t2) -> ...
       | Minus(t1, t2) -> ...
        ...
       | Let(i, t1, t2) ->   [ FILL IN HERE ]
</pre>

<dl>
<dd> (a) <pre>Let(i,subst(t1,interm,ident),subst(t2,interm,ident))</pre>
<dd> (b)<pre> if i = ident then Let(i,t1,t2) else
            Let(i,subst(t1,interm,ident),subst(t2,interm,ident))</pre>
<dd> (c) <pre>if i = ident then Let(i,subst(t1, interm, ident),t2) else
            Let(i,subst(t1,interm,ident),subst(t2,interm,ident))</pre>
<dd> (d) <pre>if i = ident then Let(i,t1,subst(t2, interm, ident)) else
            Let(i,subst(t1,interm,ident),subst(t2,interm,ident))</pre>
</dl>


<li>
The following is a Caml progam. What is the result of typing in this code?

<pre>
type  exprtype =  Int of int

let myfunc expr = match expr with
     Int(1) -> 1
   | Int(2) -> 2
   | Int(x) -> false
in myfunc (Int 2)
</pre>

<dl>
<dd> (a) 1
<dd> (b) 2
<dd> (c) false
<dd> (d) None of the above
</dl>


<li>
This is a question on subtyping. Suppose we have two functions:
    <code>func1</code> and <code>func2</code>, with the following
    types: <code>func1: tau1 -> tau1'</code>, <code>func2: tau2 -> tau2'</code>
What requirement must hold if <code>func1</code> is of subtype of <code>func2</code>? ("<code>&lt;:</code>" means ``is a subtype of'' below)

<dl>
<dd> (a) (<code>tau1 &lt;: tau2</code>) and (<code>tau1' &lt;: tau2'</code>)
<dd> (b) (<code>tau2 &lt;: tau1</code>) and (<code>tau1' &lt;: tau2'</code>)
<dd> (c) (<code>tau1 &lt;: tau2</code>) and (<code>tau2' &lt;: tau1'</code>)
<dd> (d) (<code>tau2 &lt;: tau1</code>) and (<code>tau2' &lt;: tau1'</code>)
</dl>

<li>
Which of the following propositions on type systems is false?
<dl>
<dd> (a) Type systems are a rule-based formal system, which has a strong and deep parallel with formal logic. 
<dd> (b) For expressions, type systems specify what types and what
    values they have.
<dd> (c) Type checkers are implementations of type system specifications. 
<dd> (d) For some simple type systems it is still very hard to implement a type checker.
</dl>

<li>
Which of the following rules is commonly used to define the operational semantics for <code>Not</code> (logical negation)?
<dl>
<dd> (a)
    <pre>
    e --> v
    ------------------------------
    Not(e) --> the negation of v</pre>
<dd> (b)  <pre>
    Not(e) --> v
    -------------------------
    e --> the negation of v</pre>
<dd> (c)
<pre>
    Gamma |- Not(e):Bool
   -------------------------
    Gamma |-  e:Bool
</pre><dd> (d)
<pre>
    Gamma |-  e : Bool
  -------------------------
    Gamma |- Not(e) : Bool
</pre></dl>

<li>
If we consider Caml functor as a mapping taking <code>tau1</code> to <code>tau2</code>, then

<dl>
<dd> (a) <code>tau1</code> is a signature; <code>tau2</code> is also a signature.
<dd> (b) <code>tau1</code> can either be a signature or a regular type; <code>tau2</code> is a signature.
<dd> (c) <code>tau1</code> is a signature; <code>tau2</code> can either be a signature or a regular type.
<dd> (d) <code>tau1</code> is a regular type, <code>tau2</code> is also a regular type.

</dl>

<li>
If we would like to define a curried addition function
    <code>add</code>; which of the following reflects the idea of
    curried addition in Caml?

<dl>
<dd> (a) <code>let add (x, y) = x + y</code>
<dd> (b) <code>let add = function x -> function y -> x + y</code>
<dd> (c) <code>let add curry = match curry with (x, y) -> x + y </code>
<dd> (d) Eating lamb vindaloo with raita in the desert

</dl>


<li>
In TDSR language, what are the value and the type of expression
    <code>i := Int 1</code>, respectively?
<dl>
<dd> (a) <code>Int 1, Int</code>
<dd> (b) <code>Ref Int 1, Int</code>
<dd> (c) <code>Int 1, Int Ref</code>
<dd> (d) <code>Ref Int 1, Int Ref</code>
</dl>


<li>
This question is concerned with the <code>eval</code> function of the <strong>D</strong> interpreter. What should be filled in the blank line?

<pre>
let eval exp = match exp with
...
| Function(ident, subexp) ->  [FILL IN HERE]
</pre>

<dl>
<dd> (a) <code>eval Function(ident, subexp)</code> 
<dd> (b) <code>Function(ident, subexp)</code>
<dd> (c) <code>Function(ident, eval subexp)</code>
<dd> (d) <code>eval Function(ident, eval subexp)</code>
</dl>


<li>
What is the result of the following expression after closure conversion?

<pre>Function x -> Function y -> x + y</pre>

<dl>

<dd> (a) <pre>{ fn = Function xx -> 
   { fn = Function yy -> (yy.envt.x) + (yy.arg); envt = {} }; 
     envt = {x = xx.arg} 
}
</pre>
<dd> (b)
<pre>{ fn = Function xx -> 
   { fn = Function yy -> (xx.arg) + (xx.envt.y); envt = { y = yy.arg } }; 
     envt = {} 
}
</pre>
<dd>(c)
<pre>{ fn = Function xx -> 
   { fn = Function yy -> (yy.envt.x) + (yy.arg); envt = { x = xx.arg } }; 
     envt = {} 
}
</pre>

<dd>(d)
<pre>{ fn = Function xx -> 
   { fn = Function yy -> (xx.arg) + (xx.envt.y); envt = {} }; 
     envt = {y = yy.arg} 
}
</pre>
</dl>

<li>

What is the result of this Caml program?

<pre>
let fresh = let count = ref 0 in function () -> ( count := !count + 1; !count ) in
let x = fresh() in
let y = fresh() in
 Printf.printf("%d %d\n") x y

</pre>

<dl>
<dd> (a) 1 1
<dd> (b) 1 2
<dd> (c) {contents = 1} {contents = 1}
<dd> (d) {contents = 1} {contents = 2}
</dl>

<li>
How many of the following remarks are/is true? 

    <ul>
      <li><strong>Remark 1:</strong> A language is deterministic iff for any of its expression e, if <code>e --> v</code> and <code>e --> v'</code>, then <code>v = v'</code>. 
<li> <strong>Remark 2</strong>: A language is normalizing iff for any of its expression e, there is some value v where <code>e --> v</code>. 
<li> <strong>Remark 3</strong>: The type system for a language is sound iff: if in the process of evaluating an expression e of the language, a stuck state is never reached, then <code>Gamma |- e: tau</code> can be derived from the type system. 
<li> <strong>Remark 4:</strong> A lanugage is Turing complete iff every partial recursive function on numbers can be written in this language. 
</ul>
<dl>
<dd> (a) 1
<dd> (b) 2
<dd> (c) 3
<dd> (d) 4
</dl>


<li>
This is a question designed to test your understanding on downcasting. The following is a chunk of Java code:

<pre>
class Point {
    protected int x;
    protected int y;
}

class ColorPoint extends Point {
    protected int color;
    public int getColor() {return color;}
}

public class test {
    public static void main (String[] args){
        Point p1 = new Point();                         //line1
        ColorPoint p2 = (ColorPoint)p1;                 //line2
        int temp = p2.getColor();                       //line3
    }
}
</pre>

Which of the following claims is correct?
<dl>
<dd> (a) This program does not compile, since type checking on downcasting would fail.
<dd> (b) This program compiles, and run-time error would not appear until <code>line2</code> gets executed, since downcasting would fail.
<dd> (c) This program compiles, and run-time error would not appear until <code>line3</code> gets executed, since variable <code>p2</code> does not have a <code>getColor</code> method.
<dd> (d) This program compiles, and no run-time error would happen. <code>line3</code> would return the default value of the <code>color</code> field, 0.
</dl>

<br>

  <h4>Short Answer, 6 pts each</h4>
<strong>(You can answer any <em>one</em> of these with "freebie" for an automatic
six points)</strong><p>

  <li>Show that the <strong>D</strong> operational equivalence <code>x
      x x =~ x x </code> does not hold; use the definition of
      operational equivalence to clearly show this.
  <li>
      <dl>
	<dd>
	(a) Is it possible to write a function in either
      <strong>DSR</strong> <em>or</em> Caml which takes two curried 
arguments, one a record with x
and y fields and the next a record with a z field, and produces a
single record with the x, y, and z fields?  Give the program or argue
why not.
<dd>(b) In a similar vein, is is possible to write a
    <strong>DSR</strong> or Caml program which
    takes any record, and returns a record which has all the fields of
    the record that came in except that the <code>x</code> field, if
    present, has been removed. Give the program or argue
why not.
      </dl>
  <li>Suppose Joe was a little sleep-deprived when writing his
      <strong>D</strong> interpreter and he forgot to check whether variables were bound
      or free during substitution, so substitutions replaced all bound
      <em>and</em> free variable occurrences.  Give a
      <strong>D</strong> program which
      would help the TA's test for the Sleepy Joe Error: Joe's
      interpreter will give the wrong answer.
  <li>Describe where the seemingly strange error message below is
      coming from (this is a direct Caml run):

      <pre># let rec f x = f;;
<em>Toplevel input:
# let rec f x = f;;
                ^
This expression has type 'a -> 'b but is here used with type 'b
</em></pre>
  <li>    

<li> What would it mean to have "curried functors and functor application" in Caml?
Does Caml then support curried functors?

<li>A type system is <em>sound</em> if "nothing bad" happens type-wise at
    run-time.  This concept is not so clear, however, as there will
    still may be run-time errors with a sound type system. But, these
    errors are classified into those which are failings of the type
    system, and those which are not. Of the
    following errors, which should not arise for a language with a
    provably sound type system: (use the notion of these language concepts and
    types as defined in class)
    <ol>
      <li>uncaught exception
      <li>division by zero
      <li>negating a function
      <li>a match expression in which none of the cases matches
      <li>selection of a record field which is not present
      <li>access of an array element out of the array size bound.
    </ol>
<li>An <em>immutable object</em> is one for which its fields cannot
    change after the object is created.
    <dl>
      <dd>(a) Give a real programming example of an object which makes most
	  sense as an immutable object: once its created, its fields
	  should stay constant.
      <dd>(b) Describe how immutable objects would be encoded into
	  records, in contrast to how we encoded mutable object
	  fields.  You can be informal, you don't need to define an
	  offical imutable object syntax and encoding into <strong>DSR</strong>.
      <dd>(c) Imagine a language <strong>DO</strong>, which is like
	  <strong>DOB</strong> but has some explicitly declared <em>immutable</em> objects
	  for which  field update syntax, 
	  <code>ob.f := e</code>, cannot be used. Why might it be good to
	  propose explicitly immutable object syntax, 
	  instead of just using normal objects and just not changing
	  the field values?
    </dl>
<br>
<h4>Longer Answer</h4>
<li>(15 points) Write out either the operational semantics rules <em>or</em> an
    interpreter (<em>your choice</em>) for <strong>DE</strong>, <strong>D</strong>
    with enumerations.  Enumerations are like variants, but they are
    atomic.  So, for example in Caml an enumeration of a dog, cat, or
    bird is defined as the type
<pre>type dcb = Dog | Cat | Bird</pre>
    and then we write <code>Dog</code> to get a dog variant.  We are
    going to use different syntax than Caml because <strong>DE</strong> is untyped.
    <code>`dog</code> is our syntax for the variant
    <code>dog</code> (this syntax is in fact allowed in Caml for
    <em>polymorphic variants</em>, a topic we didn't cover).  Also we
    allow match on an enumeration.  The 
    syntax you need to support is:
    <ul>
      <li><code>`l</code>, the enumeration <code>l</code> for
	  <code>l</code> a label (like a record label)
      <li><code>EMatch e With `l1 -> e1 | ... |  `ln -> en</code>
    </ul>
    which you can take the abstract syntax view on if you wish:
    <pre>type expr = ...
    | Enum of label (* `label *)
    | EMatch of expr * ((label * expr) list)
      (* EMatch expr With `label -> expr .. | `label -> expr *)</pre>
    <code>EMatch</code> works like match in Caml; here is an example
    program to be clear:
    <pre>
    Let anenum = ( If .. Then `dog Else `cat )
    In EMatch anunum With `dog -> 0 | `cat -> 1</pre>
    You only need to give the relevant (new) cases.
<li>(10 points) Write the new type rules for <strong>TDE</strong>, <strong>TE</strong> with the above enumeration
    syntax (note there is no need for any additional type declaration
    so the expression syntax for <strong>TDE</strong> is the same as for <strong>DE</strong>). <strong>TDE</strong> in addition
    to the types of <strong>TD</strong> has types <code>`lab1 | `lab2 | `lab3</code>.
    That is,<pre>type dtype = ... | Enu of (label list) | ...</pre> 
(Note that it is hard to write a typechecker for <strong>TDE</strong> because it lacks
    the type declaration information of the variants in Caml.)
</ol> 


</BODY> </html>


<hr>
<address></address>
<!-- hhmts start -->
Last modified: Thu May  9 13:48:35 EDT 2002
<!-- hhmts end -->
</body> </html>




    