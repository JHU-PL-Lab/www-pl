<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<HEAD>
<title>PL Final 2007</title>
</HEAD>
<BODY LINK="#0000FF" VLINK="#800080" bgcolor="#F0FFF0">
<h3> 600.426, Programming Languages
<br> Spring 2007
<br> Final Examination
<br> 
</h3>
You can use one handwritten 8.5x11 notes sheet.  You can write on both
sides.  No printer output is allowed, it must all  be hand-written.<p>
For this exam you have 10 "freebie" points which you can apply to any
question(s).  Those points are added to your score on the question up
to but not over the total number of points the question is for.  You
can sprinkle them about as you choose.<p> 

<strong>Good Luck!</strong>
<hr>
<ol>
<h4>Shorter Questions</h4>
   <li>(3 points) Give one example of something that you can do with C++ Templates
that you can't do with Java's Generics.
  <li>(3 points) Why are return types not  declared on <strong>TD</strong>
      functions, only argument types?  Both Java and C++ require
      return types on functions to also be declared.
  <li>(4 points)  Is <strong>TD</strong> normalizing? Recall that normalizing means that all programs
are guaranteed to halt. Say why it is or is not.

  <li> (4 points) Does the addition of <code>LetRec</code> add
      expressive power to the
<strong>D</strong> language?  Briefly explain why or why not.
  <li> (3 points) OCaml can do most of the things that <strong>D</strong> can do,
but not everything:  give an example of a <strong>D</strong>
expression that produces a type error when lower-cased and
fed into OCaml. 
  <li> (3 points) Actor True False Questions:
<br>

a) actors can create other actors
<br>

b) actors can create and modify global variables
<br>

c) an actor can discard messages if its queue exceeds a threshold

<p>
<h4>Longer Questions</h4>
  <li>(8 points) This question addresses the gap in <strong>D</strong> when
      run-time type errors occur: expressions such as <code>4 +
      True</code> or <code>4 3</code> do not evaluate to anything,
      which is the same as a nonterminating computation.  In this
      question we consider adding an extension to <strong>DX</strong>,
      to have some exception mechanism that can 
      raise exceptions for these dynamic type errors (we  are using
      <strong>DX</strong> just because it has exceptions, and that is
      what  we need to raise  when one of these errors  is hit).  Let
      us call this language <strong>DDX</strong> for <strong>D</strong>ynamic
      <strong>DX</strong>. Our desire is
      to have <strong>DX</strong> raise an exception, <code>Raise
      #TypeErr 0</code>, whenever one of these mismatch cases arise.
      <code>#TypeErr</code> will be  the name of the special exception for
      (all) such type errors, and  <code>0</code> is the required
      argument.   This is a very simple form of exception, we would
      likely want  a fancier form in a real language.<br>
a) Write the additional <strong>DX</strong> operational semantics rules
      which would raise exceptions  in the cases where
      <strong>D</strong> would have gotten stuck due to a run-time
      type mismatch on a <code>+</code> operation (all the other type
      mismatches  for function application, etc are similar; for
      simplicity you only
      need to do "<code>+</code>" for this question).  Make the rules clear and unambigous.<br>
b) Now  write a <code>safeadd</code> function in <strong>DDX</strong>
      which is  "fault tolerant": it will return <code>0</code> in the
      case that either argument was not a number, and do the addition otherwise.
  

  <li> (10 points) Consider the following rigorous (but flawed) definition of
operational equivalence:
<br>

<strong>Flawed Definition: (Operational Equivalence)</strong>. <code>e =~ e'</code> if and only if
for all contexts <code>C</code>,<code> C[e] ==> v</code> if and only if <code>C[e'] ==> v</code> for some <code>v</code>.
<br>

a) Correct this flawed definition so that it is equivalent to the
rigorous definition in the book.
<br>

b) For the following say whether each is operationally equivalent in
DS according to the <em>correct</em> definition. You should write true or false for each part. If the
relationship is false, provide a context <code>C</code> justifying
      your answer. 
Note that <code>e/e'</code> are arbitrary expressions, i.e. the
equivalence holds for any such expressions. x on the other hand is an
arbitrary variable.
<br>

 &nbsp;&nbsp;&nbsp;&nbsp;1. <code>1 + 1 =~ 2</code>
<br>

 &nbsp;&nbsp;&nbsp;&nbsp;2. <code>e + x =~ x + e</code>
<br>

 &nbsp;&nbsp;&nbsp;&nbsp;3. <code>e - e + e' =~ e + e' - e</code>

<br>

c). Now use the flawed definition provided above: state whether each of
      1.-3. is
operationally equivalent in <strong>DS</strong> according to the <em>flawed</em> definition. If
the relationship is false, again show a context.

  <li>  (10 points) Consider a new language <strong>TreeD</strong>, which has built in
semantics for simple binary trees. 
<pre>
LF             an empty tree (You could consider this a leaf node)
T(e1,e2, e3)   a Tree where e1 is the data that is stored in the root
                  node, e2 is the left child tree, and e3 is the
                  right child tree
LC(e)          left child of a tree
RC(e)          right child of a tree
D(e)           data in the root node of a tree
</pre>

      Here is the <strong>TreeD</strong> datatype:
<pre>type ident = Ident of string

type expr = 
 Var of ident | Function of ident * expr | Appl of expr * expr |
 .. (rest of D ) ... |
 LF | T of expr * expr * expr | LC of expr | RC of expr | D of expr
</pre>
      
For example, we might build a tree as follows:

<pre>
      T(1,
       T(2,LF,LF),
       T(3,T(4,LF,LF),LF)
      )
</pre>
This corresponds to the tree:
<pre>
                 1
              /    \
             2      3
            / \    / \
           LF LF  4  LF
                 / \
                LF LF
</pre>
Extend the <strong>D</strong> interpreter's <code>eval</code> function
      to a <strong>TreeD</strong> 
      interpreter. None of the existing cases of the
      <strong>D</strong> interpreter need to  change, you only need to
      give the five new clauses for the above five new syntactic forms.

 

  <li> (7 points) Consider when the following OCaml code is typed into
      the top loop in turn (a then b then c etc).
For each part, state what OCaml will respond with when you type in that line.
<br>

a) <code>let f x = x;;</code>
<br>

b) <code>f (1=2);;</code>
<br>

c) <code>let f x = (f x) + 1;;</code>
<br>

d) <code>f (1=1);;</code>
<br>

e) <code>f 1;;</code>
<br>

f) <code>let f x = (f x) + 1;;</code>
<br>

g) <code>f 1;;</code>

 
  <li>(10 points) We showed how the spirit of objects and classes could be implemented in
  <strong>DSR</strong> via functions, records, and references.
  Multiple inheritance can also be implemented in a similar spirit.
  In fact, given two objects-as-records, we can from them create a
  "merged" object which has all of the fields and methods of the
  original objects.  <br>
a) Using the encoding as outlined in class, define two objects in <strong>DSR</strong>:
      <ul>
	<li><code>obeven</code> is an object with no fields (for simplicity) and only one
  method <code>iseven</code> which has the following body (you get to
  figure out where the parameters are declared yourself, this is just
  the body):
	    <pre>If n = 0 Then True Else If n = 1 Then False Else
	           Not (this &lt;- isodd (n-1))
  </pre>
	 The above example uses the  <code>&lt;-</code>  macro which
  you should write out  in your answers -- don't use this macro.   Note
  that <code>obeven</code> does <em>not</em> have an <code>isodd</code>
  method, so <code>obeven &lt;- iseven 5</code> will get stuck when it
  tries to find an <code>isodd</code> method on the recursive call.
	<li><code>obodd</code> is the dual to <code>obeven</code> -- it has
  <code>isodd</code> which invokes <code>iseven</code> on one smaller,
  but has no such method itself.
      </ul>
b) Now write  the  <strong>DSR</strong> code for <code>obmerge</code> as a
  merge of these two objects, and 
  which will in fact  run correctly because <code>iseven</code> now
  has an <code>isodd</code> method in the merged object, and
  vice-versa.  You must not redefine the code 
  for these methods to build <code>obmerge</code>, you must pull them out
  of the already existing <code>obeven</code> and <code>obodd</code>.
  <br>
c) Show how you would test if <code>5</code> is even on <code>obmerge</code>
  by giving  the <strong>DSR</strong> syntax encoding that message
  send (again don't use any macros).
</ol> 

<p>

</BODY> </html>
 <!--  WWWli>(8 points) The standard "Y combinator" for writing recursive functions in a
      call-by-WWWem>nameWWW/em> language is:
      WWWpre>Y = Function f -> (Function x -> f (x x))(Function x -> f (x x))WWW/pre>
      Where the "WWWcode>fWWW/code>" fed in is the same as in our
      call-by-value Y combinator, it is a functional 
      WWWcode>Function this -> Function n -> ...WWW/code>.WWWbr>
      This is not the same as the Y-combinator, WWWcode>YcombWWW/code>,
      given in the book for the (call-by-value) WWWstrong>DWWW/strong> language.WWWbr>
a) ... What was WWWcode>YcombWWW/code> exactly, anyway?  Write it out.WWWbr>

      b)  Will the above call-by-name WWWcode>YWWW/code> also work in a call-by-value  language
      such as WWWstrong>DWWW/strong>, or not?   Justify your answer.

  WWWli> (8 points) Give WWWem>anyWWW/em> example of how OCaml modules can make abstract data
  types by hiding types and operation.  If you want something to chew
  on thaat is more concrete, make a stack data structure implemented
  internally as
  a list, but hide  the fact that  it is a list from users of the
  stack.  You don't need to fill in all function bodies but do give
  all type declarations, the function headers, and all of the
  structure(s) and signature(s) needed. 
WWWli> (1 point) True or False: "Duck typing" is  so named because its like
      "duck taping": hack together a patch of anything with it.
    -->
  

<br>
