<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<HEAD>
<title>PL Final 2008</title>
</HEAD>
<BODY LINK="#0000FF" VLINK="#800080" bgcolor="#F0FFF0">
<h3> 600.426, Programming Languages
<br> Spring 2008
<br> Final Examination
<br> 
</h3>
You can use one handwritten 8.5x11 notes sheet.  You can write on both
sides.  No printer output is allowed, it must all  be hand-written.<p>

<strong>Good Luck!</strong>
<hr>
<ol>
  <li>(4 points) Define atomicity in programming languages and briefly explain in what
      way actor executions are atomic.
<p>


  <li>(6 points) For each of <strong>Fb</strong> and
      <strong>FbSR</strong>, answer whether the following operational
      equivalences hold.  If the answer is no, give a context C
      showing  that fact.<br>
&nbsp;&nbsp;&nbsp;&nbsp;a)  <code>1 + 1 ~= 3</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;b)  <code>(Function x -> e)(e') ~= e[e'/x]</code> (assume e' contains no free <code>x</code>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;c)  <code>Function x -> ((x 4); (Function y -> x y)) ~= Function x -> ((x 4); x)</code>

<p>
  <li>(6 points) Atomic subtyping is the subtyping concept applied
  to atomic types such as int, float, etc to give another view of
  overloading.  It makes some sense 
  that "integers are subtypes of floats"  since all integers can be
  viewed as floating-point  numbers. For our case, consider
  adding  <code>Bool &lt;: Int</code> to our  <strong>STFb</strong>
  subtype language to give  an extension <strong>STFb'</strong>.  We
  will view boolean <code>False</code> as 
  <code>0</code> and <code>True</code> as <code>1</code>.<br>
a) Give the supertype of <code>(Int -> Int) -> ((Int -> Int)-> Bool)
  -> Bool</code> which contains the most <code>Bool</code>'s.<br>

b) This language also requires some modification of the runtime: give
  a program typeable in <strong>STFb'</strong> which would get stuck
  when run by our <strong>Fb</strong> interpreter.

 
<p>

  <li>(6 points) Caml supports  the syntax <code>let rec f x = ... and g y = ... in
  ..(use f and g here).. </code> to allow mutually recursive functions
  to be defined.  Write an <strong>Fb</strong> macro to support this,
  just for the case of two mutually recursive functions of one
  argument:
      <pre>Let Rec f x = e and g y = e' In e'' =def= (fill in)</pre>

 
 <li>(20 points) The book presented <strong>FbV</strong>, a functional language
      with simple variant data.  We did not cover it in detail but
      here are some examples to recall <strong>FbV</strong>:
<pre>Function y -> Match y With
     `Positive(x) -> 1 | `Negative(y) -> -1 | `Zero(p) -> 0
</pre>and
<pre>
Match `Grilled(3+1) With
  `Stewed(x) -> 4 + x |
  `Grilled(y) -> 2 + y
 ==> 6, because
`Grilled(3+1) ==> `Grilled(4) and (2 + y)[4/y] ==> 6
</pre>
Recall that each variant has exactly one argument here, unlike Caml
      where  the number of arguments can be 0 or more.
     For this question we are going to focus on a slightly different
     variant language.  First let us consider <strong>FbV'</strong>.  We have
     only <em>one</em> case in each <code>Match</code> in
      <strong>FbV'</strong>.  Unfortunately this language is too weak.<br>
a) Describe why the above grilled/stewed match <em>cannot</em> be
      written in <strong>FbV'</strong>.<br>
     
     To be clear, <strong>FbV'</strong> extends <strong>Fb</strong>
     with the following syntax:

     <pre>
     e ::= ... (Fb syntax) ...| Match e With `lab(x) -> e
               | `lab(e) </pre>
     where <code>`lab</code> is a  variant label constant.<br>
b) OK before  we dig in, please define the set of <em>values</em>
     <code>v</code> for <strong>FbV'</strong>.
<br>

c) Dig in time: write the operational semantics rules for  <strong>FbV'</strong> as
     an extension to <strong>Fb</strong>. (You don't need to repeat
     the <strong>Fb</strong> rules).
     <br>
d)
    We need to fix the weakness of <strong>FbV'</strong> and we do
     this by adding just "otherwise" case, inspired by the "_" pattern
     match allowed in Caml.  Let us define yet another language,
     <strong>FbV''</strong>, which adds to <strong>Fb</strong> the
     following syntax:
          <pre>
     e ::= ... (Fb syntax) ...
               | Match  e With `lab(x) -> e | _(x) -> e
               | `lab(e) </pre>

Write the
     operational semantics for <strong>FbV''</strong> as an extension
     to <strong>Fb</strong>.<br>
e) Finally we have a language which can express general matches.
     Write a macro encoding for the sugared syntax 
<pre>Match s With `n1(x1) -> e1 | ... | `nm(xm) -> em | _(x) -> e</pre>
in <strong>FbV''</strong>.
<p>

<li>(16 points) This question concerns the alternative encoding of objects as
    variants that we used as part of the actor language.  In this
    question we focus on using this approach in a non-concurrent
    language, <strong>FbSV''</strong> (we did not define this language
    explicitly but it is the <strong>FbV''</strong> variant language
    of the previous question plus state).  To recall the approach, the
    key idea is to instead of viewing objects as records to encode
    objects  via a <code>Match</code> which dispatches on the method
    name and args as a variant.  The above Positive/Negative/Zero
    example can for example be viewed as a crude encoding of an object with three
    methods, Positive, Negative, and  Zero.<br>

    a) Do a less crude encoding by encoding an object which has
    methods that may refer to the object itself, by having a binding
    for <code>this</code>.  To make the task concrete, modify the
    above crude "Positive/Negative/Zero object" so the
    <code>'Negative</code> method is implemented by invoking the
    <code>'Positive</code> method via a <code>this</code>.  Feel free to use the variant macro
    defined in part e) of the previous question.

    <br>
b) The object above has only methods and no fields.  Now show how
    fields can also be encoded. Illustrate your encoding by writing
    <strong>FbSV''</strong> code to create our classic
    <code>Point</code> object, with mutable fields <code>x</code> 
    and <code>y</code> and methods <code>`GetX</code> and
    <code>`PutX</code> (plus other methods you can leave off now).
    (Hint: don't define the <code>x/y</code> as variants and parts of
    the match; just define them in an enclosing <code>Let</code>).<br>

c) Ruby lets you add methods to arbitrary existing objects, but this
    is in fact <em>not</em>
      possible with our record encoding of objects in the book (the
    <strong>FbSR</strong> encoding).  Discuss why it is not
      possible. (think of trying to write a function taking any object
    <code>ob</code> as argument, and returning with a new object with
    one extra method  <code>newmethod</code> <em>plus</em> keeping all
the original methods of <code>ob</code>, whatever they were)<br>
d) It is in fact possible to encode such extensible objects  in
<strong>FbSV''</strong>.  Explain in high-level terms how your answer to part a) above
could be redone to allow for an extension to be later added.  For this
question  all you need to do is point out what advantage the variant
has over the record for extensions, not to give the details of how to
do it! 



</ol> 

<p>

</BODY> </html>

