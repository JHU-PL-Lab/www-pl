<!--#include virtual="/pl/header.html" -->
</div>

<!-- Main -->
<div id="main" class="wrapper style4">

  <!-- Content -->
  <div id="content" class="container">
    <section>
      <header class="major">
        <h2>Assigment 8: More Types</h2>
      </header>
      <h4>Part A</h4>
      <p>Write a type checker for <strong>TFbX</strong>. 	
	The  <strong>TFbSRX</strong> language (also with records and state) is described in section 6.4 of the book. FbDK contains source directory <a href="http://pl.cs.jhu.edu/pl/book/_dist/fbdk/src/TFbSRX/"><tt>TFbSRX</tt></a> which has the relevant parser and OCaml data type, all you have to do is fill in the file <tt>tfbsrxtype.ml</tt> with a correct implemention of the <tt>typecheck</tt> function there.  Note that you <em>don't</em> have to do the state or records part, just raise an OCaml exception if the source program contains any of that syntax. Here are some details.
	</p>
      <ul>
	<li>The file <a href="http://pl.cs.jhu.edu/pl/book/_dist/fbdk/debugscript/tfbsrx.ml"<code>debugscript/tfbsrx.ml</code></a> contains quite a few examples for you to test the typechecker with.
 </li>
 <li>
 The AST for the language, in file <a href="http://pl.cs.jhu.edu/pl/book/_dist/fbdk/src/TFbSRX/tfbsrxast.ml"><tt>TFbSRX/tfbsrxast.ml</tt></a>, is slightly different from the one at the top of Section 6.4 in the textbook. It is slightly simplified.
 </li>
<li>To run our reference binary (assuming you are in the <tt>fbdk</tt> directory), use <tt>ocamlrun binaries/tfbsrx.byte</tt>; to run your binary, <tt>make</tt> then <tt>ocamlrun tfbsrx.byte</tt>.  note the reference binary implements records and state, but you should not.  </li>
<li>For the Fb interpreter we additionally provided a way you could directly in OCaml invoke the eval function etc; we provide a similar modality for TFBSRX to allow you to invoke the typecheck fucntion in the OCaml top loop. To do this, from the OCaml top-loop <tt>#use debugscript/tfbsrx.ml</tt> and then you can use function <tt>ptc</tt> to first parse and then typecheck the supplied program.  If you want to use our solution binaries with this file, as with Fb change the line
<pre>#directory "_build/src/TFbSRX";;</pre>
to												<pre>#directory "binaries/libraries";;</pre>
and our binaries will be used instead of yours.
</li>
<li>Note that you need not write the interpreter portion, you can leave the file <tt>tfbsrxinterp.ml</tt> as-is and so when you ask to eval it will just return what it was given; thats fine, the point is to blow up if there was a type error, and return the right type if not. </li>
</li>
<li>
 Notice that <code>Raise ..</code> evaluates to "arbitrary tau" in the rule in the book. As we mentioned in lecture, this is usually handled by introducing an "anything type <tt>*</tt>" - a type that is equal to every other type in the system. A new type <code>TBottom</code> has been added to the type <tt>fbtype</tt> for this purpose.
 </li>
 <li>
 Type checking exceptions can be somewhat tricky; especially their interactions with <i>other</i> expressions and type rules. You need to consider each rule carefully.<br>
 <br>
 For example:<br>
 <code>
  |- (Function x:Int -> x = 1) (Raise #Exn@Bool False) : Bool <br>
  &nbsp;&nbsp;Because by function rule</br>
  &nbsp;&nbsp;|- (Function x:Int -> x = 1) : Int -> Bool <br>
  &nbsp;&nbsp;and by exception rule <br>
  &nbsp;&nbsp;|- (Raise #Exn@Bool False) : Bottom (arbitrary tau) <br>
  And because Int and Bottom can be equated, by application rule we have <br>
  |- (Function x:Int -> x = 1) (Raise #Exn@Bool False) : Bool <br>
 </code><p>
</li>
</ul>

<h4>Part B</h4>
Some written questions on typing.
<ol>
  <li> Consider type inference for <strong>TFbR</strong>.  If we only infer equations on types like we did for <strong>EFb</strong>, it is in fact quite difficult to infer reasonable types without any type declarations present (and, it is why OCaml requires record types to be declared).  Take for example a program like <tt>(Fun r -> r.x + r.y) {x = 4; y = 7}</tt> and argue why it would be difficult to infer local equations and check for inconsistency like we did for <strong>EFb</strong>.  Concretely, propose some reasonable equations that could be added but then show why they would not work.
</li>

<li>This question concerns subtyping.
  <ol class="a">
    <li>Type the following program in <strong>STFbR</strong> (note this program
  is not showing the type declarations on <code>r1/r2</code>, figure
  those out yourself):
      <pre>
      Function n:Int -> Function r1:{...} -> Function r2:{...}->
         {x = r1.x + 1; y = (If n = 0 Then r1.y - 1 Else r2.y +1); z =  r2.z + 2} </pre>
      (you only need to give a legal type, not show the full type derivation)</li>
    
    <li> Now write a nontrivial subtype of your answer to a) which changes as
      many of the record types as you can.</li>
    <li> Like b) but make a supertype.</li>
  </ol>

<li>Of the following pairs of types, is the left type a subtype of the right type, a supertype, or neither?  Justify your answer by showing the proofs in the subtype proof system of the book; if neither holds describe why in words.
<ol class="a"><li>  <code>{ x : Int; y : { z : Bool } }</code>  and  <code>{ x : Int; y : {}; w : Int }</code>,
   <li> <code>{ x : Int } -> {&nbsp;}</code> and <code>{&nbsp;} -> { x : Int }</code>
   <li> <code>({ x : Int } -> {&nbsp;}) -> {&nbsp;}</code> and <code>({&nbsp;} -> { x : Int }) -> {&nbsp;}</code></li>
</ol></li>

</ol>
<p>


          <h3>Submission</h3>

          For Part A, upload (only) your file <tt>tfbsrxtype.ml</tt> which will (hopefully) contain your fully functioning type checker, to <em>Assignment 8 code</em> target on Gradescope; upload the rest of your answers to <em>Assignment 8 written</em>.
          </ul>

    </section>
  </div>
</div>


<!--#include virtual="/pl/footer.html" -->

