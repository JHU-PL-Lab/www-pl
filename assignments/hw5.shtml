<!--#include virtual="/~scott/pl/header.html" -->

</div>

<div id="content">


<h2>Programming Languages Assignment 6</h2>
<h4>Due: Wednesday Apr 24th</h4>
<p/>

<ol>
  <li>
    <b>Part 1:</b> (65 points)
    Implement the type inference algorithm for <strong>EF&#x266d;</strong> in Caml.
    (See below for details)
  </li>
  <li>
    <b>Part 2:</b> (35 Points)
    Answer the problems in <a href="hw5.txt">hw5.txt</a>.
  </li>
</ol>

<h3>Implementing <strong>EF&#x266d;</strong></h3>

<ul>
  <li>Section 6.6.2 of the book describes <strong>EF&#x266d;</strong>.</li>
  <li>
    The syntax for <strong>EF&#x266d;</strong> is essentially the same as <strong>F&#x266d;</strong> (with the exception of Let Rec, which you can ignore).
  </li>
  <li>
   You need to implement the full algorithm <em>except</em> you do not need  to implement the cycle detection algorithm - your checker can loop forever on programs with cyclic constraints (but only on such programs).  Extra credit will be given for implementing cycle detection.  Also you don't need to include let-polymorphism.
  </li>
  <li>
    You can use FbDk to write <strong>EF&#x266d;</strong>. All you need to do is write a <code>typecheck</code> function in the file: <a href="http://pl.cs.jhu.edu/pl/book/dist/FbDK/downloads/source/fbdk-1.23/src/Fb/fbtype.ml"><code>.../src/Fb/fbtype.ml</code></a>. The function should return the inferred type
    or raise an exception if inference fails.
  <li>Types are defined in <a href="http://pl.cs.jhu.edu/pl/book/dist/FbDK/downloads/source/fbdk-1.23/src/Fb/fbast.ml"><code>.../src/Fb/fbast.ml</code></a></li>
  <li>
    By default FbDk has typechecking turned off. To enable it, do one of the following:
    <ol>
      <li>
      Set the variable <code>typecheck_default_enabled</code> in <a href="http://pl.cs.jhu.edu/pl/book/dist/FbDK/downloads/source/fbdk-1.23/src/Fb/fbtype.ml"><code>.../src/Fb/fbtype.ml</code></a> to true
      </li>
      <li>Start the <strong>F&#x266d;</strong> executable with the command line argument <b>--typecheck</b>
      </ul>
    </ol>
  </li>
</ul>
<ul>
<li>
  Some suggestions for the implementation
  <ul>
    <li>Break down your implementation into the same phases as in the book:
      <ul>
        <li>Generate the type <code>&tau; \ E</code> using the ideas in the type system (and also following the typechecker for <code>TF&#x266d;</code> in the book),</li>
        <li>Perform the closure on <code>E</code>,</li>
        <li>Check the closure for immediate inconsistencies, and</li>
        <li>Substitute equations of <code>E</code> into <code>&tau;</code> to solve.</li>
      </ul>
    </li>
    <li>
      The <code>E</code> is a set of pairs (the type equations &tau; = &tau;'); the built-in Caml types such as <code>Set</code> or <code>Map</code> may prove useful in your implementation of this data structure.
    </li>
    <li>
      In the closure outlined the book we assumed = was symmetric; in your implementation, one easy (but inefficient) method to achieve this is every time you add &tau; = &tau;' also add &tau;' = &tau;.
    </li>
    <li>The "substitute to solve" phase is the same idea as your substitution function you wrote on terms, just do it on types.</li>
    <li>Don't worry about efficiency.  <b>Do</b> worry about correctness.</li>
  </ul>
</li>
</ul>

</div>

<!--#include virtual="/~scott/pl/footer.html" -->
