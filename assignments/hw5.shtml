<!--#include virtual="/pl/header.html" -->

</div>

<div id="content">


<h2>Programming Languages Assignment 5</h2>
<h4>Due: Friday, April 24th</h4>
<p/>

<p>
    This assignment comes in two parts. For the first part, you will write a type inference algorithm for your F&#x266d; interpreter.  (Don't worry if your interpreter doesn't work correctly; you can still complete this assignment without fixing it!)  For the second part, you will answer a few supplemental questions on types.
</p>

<h3>Part I</h3>
<b>(70 points)</b>
<p>
    The F&#x266d;DK has been designed to be extensible with typechecking. It is just turned off by default. For Part-I of the homework, 
    use the F&#x266d;DK to implement the type inference algorithm for <strong>EF&#x266d;</strong> in OCaml.  You will use the book presentation (also given in class) as the "specification" of your implementation.
</p><p>
    To complete this assignment, you will need to open <tt>fbtype.ml</tt> in the <tt>src/Fb</tt> directory and implement the <tt>typecheck</tt> function.  This function must return the type of that expression as specified by the EF&#x266d; algorithm; you should use the <tt>fbtype</tt> data type which appears in <tt>fbast.ml</tt>.  You may also wish to set <tt>typecheck_default_enabled</tt> to <tt>true</tt> in <tt>fbtype.ml</tt>; if you do not do this (and also do not pass <tt>--typecheck</tt> command-line flag), then the typechecker will not be used.  <b>For this part, you should turn in your <tt>fbtype.ml</tt> file and nothing else.</b>  Do not change fbast.ml or similar files, since your code will be tested with an otherwise correct implementation of the F&#x266d;DK by dropping your <tt>fbtype.ml</tt> file in.
</p><p>
    The F&#x266d; binary from the website also supports typechecking. You can turn it on by passing <tt>--typecheck</tt> to it. As an example, a correctly working interpreter should behave as follows:
</p>
<pre>
Fb version 1.23         (typechecker enabled)

# (Function x -> Function y -> x + y) 4;;
: Int -> Int
==> Function y ->
4 + y
# Function x -> x;;    
: 'a -> 'a
==> Function x ->
x
# True + 1;;
Exception: Fbtype.TypeInferenceFailure("immediately inconsistent types")
</pre>
<p>
    Note that, by default, the type of the expression is printed. Look at the command line options with <tt>--help</tt> for more information.
</p>
<p>
    Note also that the exception which is raised by a type error is defined in the <tt>fbtype.ml</tt> module; you must define your own exception(s) to throw when the expression cannot be assigned a type.
</p><p>
    You need to implement the full algorithm <em>except</em> you do not need  to implement the cycle detection algorithm - your checker can loop forever on programs with cyclic constraints (but only on such programs).  Extra credit will be given for implementing cycle detection.  Also, you don't need to include let-polymorphism.
</p><p>
    Here are some suggestions:
</p>
<ul>
    <li>
        <p>
            The reference implementation binaries that we provide for this class already have an implementation of EF&#x266d;, so you can experiment.  Run the <tt>Fb</tt> binary with the flag <tt>--typecheck</tt>.  (Using this flag is equivalent to setting <tt>typecheck_default_enabled</tt> to <tt>true</tt>.)
        </p>
    </li>
    <li>
        <p>
            Break down your implementation into the same phases as in the book:
        </p>
        <ol>
            <li>
                <p>
                    Generate the type <code>&tau; \ E</code> using the ideas in the type system (and also following the typechecker for <code>TF&#x266d;</code> in the book),
                </p>
            </li>
            <li>
                <p>
                    Perform the closure on <code>E</code>,
                </p>
            </li>
            <li>
                <p>
                    Check the closure for immediate inconsistencies, and
                </p>
            </li>
            <li>
                <p>
                    Substitute equations of <code>E</code> into <code>&tau;</code> to solve.
                </p>
            </li>
        </ol>
    </li>
    <li>
        <p>
            The <code>E</code> is a set of pairs (the type equations &tau; = &tau;'); the built-in Caml types such as <code>Set</code> or <code>Map</code> may prove useful in your implementation of this data structure.
        </p>
    </li>
    <li>
        <p>
            In the closure outlined in the book, we assumed = was symmetric; in your implementation, one easy (but inefficient) method to achieve this to add an additional closure step: every time you add &tau; = &tau;' to the closure, also add &tau;' = &tau;.
        </p>
    </li>
    <li>
        <p>
            The "substitute to solve" phase is the same idea as your substitution function you wrote on terms; just do it on types.
        </p>
    </li>
    <li>
        <p>
            During testing, it may be useful to run your interpreter with the <tt>--show-backtrace</tt>. This will give you a stack trace for any exceptions that occur. Unfortunately this feature works only on the compiled binary and not in the interpreter.
        </p>
    </li>
    <li>
        <p>
            Don't worry about efficiency.  <b>Do</b> worry about correctness.
        </p>
    </li>
</ul>

<h3>Part II</h3>
<ol>
    <p>
        In this part, you will be answering some auxiliary questions about typing.  Your submission for this part should be a text file or a PDF containing your answers.
    </p>
    <li>
        <b>(15 points)</b>
        <p>
        Given two types <code>&tau;<sub>1</sub></code> and <code>&tau;<sub>2</sub></code>, write an OCaml function to determine whether <code>&tau;<sub>1</sub></code> is a subtype of <code>&tau;<sub>2</sub></code>.

        The types are given in terms of the abstract syntax tree defined below and correspond to the relevant types in <code>STF&#x266d;</code>.
        
        
<pre>
type label = Lab of string

type fbtype =
    TInt | TBool | TArrow of fbtype * fbtype | TRecord of (label * fbtype) list
    
let rec is_subtype t1 t2 = () ;; (* ANSWER *) 
    
(*    
# let r1 = TRecord [(Lab "x", TInt)] ;;
# let r2 = TRecord [(Lab "x", TInt); (Lab "y", TBool)] ;;
# let r3 = TRecord [(Lab "x", TInt); (Lab "y", TInt)] ;;
# let r4 = TRecord [] ;;
# let r5 = TRecord [(Lab "x", TInt); (Lab "y", TBool); (Lab "z", TRecord [(Lab "x", TInt)])] ;;
# let r6 = TArrow(r1, r2) ;;
# let r7 = TArrow(r4, r5) ;;
# is_subtype r2 r1 ;;
- : bool = true
# is_subtype r3 r2 ;;
- : bool = false
# is_subtype r7 r6 ;;
- : bool = true
*)
</pre>
        </p>
    </li>
    <li>
        <b>(15 points)</b>
        <p>
            In a previous assignment we extended Fb with lists to make <code>F&#x266d;L</code>. Here we will extend the language with types <code>TF&#x266d;L</code> - <code>F&#x266d;L</code> with types.

            We use a slightly extended grammar compared to the original question:
            <ul>
                <li><code>[[ ]]:&tau;</code>. The syntax for empty list now requires that you declare what the type of the list is.</li>
                <li> <code>e ++ e</code>. This is the regular cons operator. Remember that <code>1 ++ [[ ]]</code> is a semantically valid expression, but both <code>(1 ++ True ++ [[ ]])</code>
                      and <code>(1 ++ [[ ]]) ++ (2 ++ [[ ]])</code> are not.</li>
                <li> <code>Match e With [[ ]] -> e | (x ++ x) -> e</code>. This is the FbL specific match operation from before.</li>
            </ul>
        </p>
        <p>
           Your task is to write the new type rules (beyond those already present in TFb) required to make this work.
        </p>
        <p>
           <strong>Note</strong>: You are allowed to extend TFb's type grammar to introduce extra type terms pertaining to lists.

        </p>
    </li>
</ol>

</div>

<!--#include virtual="/pl/footer.html" -->
