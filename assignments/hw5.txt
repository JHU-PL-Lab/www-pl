600.426 - Programming Languages
JHU Spring 2012
Homework - 5 (100 points)

----------------------------------------------------------------------------------------
HEADER: PLEASE FILL THIS IN
----------------------------------------------------------------------------------------

Name                  :
List of Collaborators :

Please make a good faith effort at listing people you discussed any problems with here,
as per the course academic integrity policy. TA/CA/Prof need not be listed.

----------------------------------------------------------------------------------------
GENERAL NOTE: When answering theory questions, please do try to be as precise in your
arguments as you can. This *is* a theory course after all.
----------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------
Section 1: Objects Encore
----------------------------------------------------------------------------------------

1a. Write the FbOb code corresponding to the following simple (and quite cheesy) class
    hierarchy written out in Java:

    public class CreditCard
    {
      private int maxCredit = 0, usedCredit = 0 ;

      public int getMaxCredit() { return maxCredit; }
      public int setMaxCredit(int max) { maxCredit = max ; return maxCredit; }
      public int getAvailableCredit() { return maxCredit - usedCredit; }
      public int swipe(int money) { usedCredit += money ; return getAvailableCredit(); }
      public int pay(int money) { usedCredit -= money ; return getAvailableCredit() ; } 
    }

    public class CashbackCard extends CreditCard
    {
        private int payback = 10 ;

        public int getPayback() { return payback; }
        public int setPayback(int p) { payback = p; return payback; }

        @Override
        public int pay(int money) {
          swipe(money) ;
          if (money > 100)
            pay(payback);
          return getAvailableCredit() ;
        }
    }

    The FbOb code should mirror the features and behavior of the Java code.

    [10 Points]

1b. Provide an FbSR translation for the FbOb code that you produced for 1a. For
    reference, the translation rules and examples are in section 5.2.3 of the book.

    You can test your implementation using the FbSR binaries provided on the course
    website.

    [20 Points]

----------------------------------------------------------------------------------------
Section 2: Simple Type Systems
----------------------------------------------------------------------------------------

2a. Do the following expressions typecheck?
    1. If 0 = (1-1) Then 1 Else False
    2. Function x:int -> (x = 0) And False

    Show why or why not. For those cases where the expression typechecks you must show
    the complete type derivation. For the cases where it fails to typecheck, you must
    show the type derivation up to the point that it gets stuck.

    [15 Points]

2b. In Fb it was trivial to write programs that compute for ever or get stuck. In fact
    this is game most of you played when trying to disprove operational equivalence.

    Is it possible to write such programs in TFb? If yes, write down an example TFb
    program that does not compute to a value. If not, provide an informal argument of
    why not.

    [10 Points]

----------------------------------------------------------------------------------------
Section 3: Developing Type Rules
----------------------------------------------------------------------------------------

3a. We defined a language FbMR - Fb with Mutable Records in the previous homework. In this
    exercise we extend it to TFbMR - FbMR with typechecking. Write down the new type rules
    needed for the language (beyond those already provided by TFb).

    You can assume that the syntax of FbMR has been extended to allow the specification
    of types for records (similar to TFbSRX)

    [15 Points]

----------------------------------------------------------------------------------------
Section 4: Subtyping
----------------------------------------------------------------------------------------

4a. Write a subtype for the following type:
    ( {r:Int; t:Int} -> {in:{r:Int; t:Int}; out:{r:Int; t:Int}} ) -> {r:Int; t:Int} -> {r:Int; t:Int}

    The type {r:Int, t:Int} should NOT appear in any part of your solution.

    [15 Points]

4b. Give a type derivation in STFbR showing how the following program typechecks:
    Let getradius = (Function p : {r:Int} -> p.r) In
      getradius {r = 4; t = 180} + getradius {r = 5; t = 120; g=128}

    [15 Points]