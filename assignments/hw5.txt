600.426 - Programming Languages
JHU Spring 2016
Homework 5

--------------------------------------------------------------------------------------------------
HEADER: PLEASE FILL THIS IN
--------------------------------------------------------------------------------------------------

Name                  :
List of team Members  :
List of discussants   :

----------------------------------------------------------------------------------------
  Section 1: Type Rules and Subtyping
----------------------------------------------------------------------------------------

1a. We defined a language FbD - Fb with extensible dictionaries, in the midterm. In this
    exercise we extend it to TFbD - FbD with typechecking. Write down the new type rules
    needed for the language (beyond those already provided by TFb).  Make sure to type the
    construction as well as the append and access of dictionaries.

    You can assume that the syntax of FbD has been extended to allow the specification
    of types for dictionaries as  { `Foo => Bool ; `Bar => Int ; `Moo => Int }.


 b. Consider hypothetical language STFbD, adding subtyping to the above.  This is in fact
    very difficult due to the challenges of subtyping.  To illustrate the problem consider
    trying to typecheck

     Fun x: { `Foo => Bool } -> Fun y: { `Bar => Int } -> x @@ y

    Write a sentence or two on why the append typing rule would be difficult to write in
    the presence of subtyping.

 c. Give a type derivation in STFbR showing how the following program typechecks:
    Let getradius = (Fun p : {r:Int} -> p.r) In
      getradius {r = 4; t = 180} + getradius {r = 5; t = 120; g=128}

    [25 Points]


--------------------------------------------------------------------------------------------------
  Section 2: Actors
--------------------------------------------------------------------------------------------------

2a. For this question you are going to write a set data structure of sorts in AFbV.

    An implementation of AFbV is available in the FbDK. It is not multithreaded or
    distributed however as OCaml core libraries don't have such facilities.  Language
    extensions including Let .. In, sequencing ( ; operator ), pairs ( including keywords
    Fst and Snd to extract values ), lists ( supports construction via the :: operator and
    the standard [v1; v2; v3] notation and has keywords Head and Tail to extract the head
    and tail respectively; use "l = []" to check for empty list) and also an ability to
    print integers and booleans.  It does not include Let Rec. You can use the Y
    combinator to get around that and it is easy to do with Let .. In.  If you start the
    interpreter with the --debug flag, it will print out the current set of actors and
    messages before it processes messages. This is useful, but may be too much information
    on screen.  Note that if there is any runtime error you MUST to stop and re-start the
    intepreter, it is flakey and may not work properly otherwise.

    Some AFbV examples run in class may be found at

    http://pl.cs.jhu.edu/pl/ocaml/code/AFbV-examples.afbv


    Here is a sketch of the interface your set should obey.

    Let setbeh = (* FILL IN YOUR SET BEHAVIOR HERE *)  In
    Let s = Create(setbeh,0) In ...

    so that 

    s <- `add(1); s <- `add(2); s <- `add(3)

    would add all the indicated elements to set s (implemented by an actor).  Then,

    s <- `asList(c)

    should cause s to send all elements of its set, in the form of a list, to
    actor c.


    Overall here is a program which should be able to test your set:

    Let y = (Fun b -> Let w = Fun s -> Fun m -> b (s s) m In w w) In
    Let setbeh = (* FILL IN YOUR SET BEHAVIOR HERE *)  In
    Let testbcont = Fun m -> (Print (Head m)); (Print (Head (Tail m)));
                             (Print (Head (Tail (Tail m)))); (Fun x -> x) In
    Let testb = Fun me -> Fun d -> Fun m ->  
       Let s = Create(setbeh, 0) In
         (s <- `add(1)); (s <- `add(2)); (s <- `add(3)); (s <- `asList(me));
         (testbcont)
    In Let testa = Create(testb,0)
    In testa <- `anymessage 0

    Observe that the testbcont is the "continuation" of the test, its the behavior which will receieve the list from the set.
    
    [10 points]

 b. One property of actors discussed in class was arrival order nondeterminism, namely
    messages need not arrive in the order they were sent.  Describe how the above set
    actor is not the most reliable data structure given this property.

 c. Fix the above set and test so that it will serialize the additions appropriately, by changing the protocol for add to be

      s <- `add(1,c)

    and have your set send an `ack(0) reply to c every time it accomplishes an `add.  Also
    change the test so it waits for the `ack of each `add before sending the next add.
    You will have to use the testbcont idea in the tester above to sequence messages.

    [40 points]

--------------------------------------------------------------------------------------------------
  Section 4: Operational Equivalence
--------------------------------------------------------------------------------------------------


4. a. For each of the following Fb expressions, indicate whether operational equivalence
   holds. If it does not, show some context that evaluates differently dependent upon
   which of the two expressions you use. (Remember: it only takes one of the infinitely
   many contexts to make the two expressions operationally inequivalent).
   
   1. (Fun y -> Not y) False =~ True 
  
   2. y + x =~ x + y

   3. Fun f -> f 0 + f 1 =~ Fun f -> f 1 + f 0
  
   4. Let dummy = x y in (0 0) ~= (0 1)

   5. (Fun x -> x x)(Fun x -> x x) =~ (Fun x -> x x x)(Fun x -> x x x) 


   b. As 1a. but for FbS. Think carefully about what stateful side effects could do.

   c. As 1b. but for FbX.  Think carefully about what exception side effects could do.

   [35 points]


