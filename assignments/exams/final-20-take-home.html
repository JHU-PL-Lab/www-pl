<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>PL Take-Home Final 2020</title>
</HEAD>
<BODY LINK="#0000FF" VLINK="#800080" bgcolor="#F0FFF0">
<h3> 601.426/626, Princples of Programming Languages
<br> Spring 2020
<br> Take-Home Final Examination
<br> 
</h3>
The rules:
<ul>
  <li>The answers must be your own work.  You may ask questions during office hours and post private questions to instructors on Piazza, but you may not discuss the questions in any way with anyone else.</li>
  <li>You are free to consult the textbook, lecture notes, and any other fixed resource you can find on the Internet.  You may not ask questions on any Internet forum etc.</li>
  <li>Make sure to watch Piazza for clarifications posted by Instructors.
  <li>You must turn in your answers to Gradescope by Monday May 11th at 11:59PM.  No late days may be used.</li>
    </ul>

<strong>Good Luck!</strong>
<hr>
<ol>

  <li> [25 points] Consider the language <strong>FbP'</strong> which is
    <strong>Fb</strong> with pairs but lacking the left/right projections.  Instead, it supports pattern matching on pairs as an extension to <tt>Let</tt>.  So for example you could write
    <pre>Let (x,y) = (Fun z -> z)(True, 2+1) In If x Then y Else 0</pre>

    These new patterns are shallow only, for example you cannot write <tt>Let (x,(z,y)) = ...</tt>, and the <tt>x</tt> and <tt>y</tt> need to be variables.

    <ol type="a">
      <li>Give the BNF grammar for <strong>FbP'</strong> based on the above informal description.  Be sure to include the grammar of values as well.  Note it is a strict extension of the <strong>Fb</strong> grammar.</li>
      <li>Give the operational semantics rules for <strong>FbP'</strong> which are not already in the <strong>Fb</strong> rule set.</li>
      <li>Prove that <strong>FbP</strong> (the pairs of Section 3.1 in the book) and <strong>FbP'</strong> above have equivalent expressiveness: make an <strong>FbP</strong> macro encoding the above new pattern match, and make <strong>FbP'</strong> macros for the left/right pair projections.</li>
      <li>  Write an OCaml interpreter for <strong>FbP'</strong>, in the
	form of a function <code>eval : expr -> expr</code>.  You can leave out all the standard <strong>Fb</strong> evalaution clauses.  Define a revised <tt>expr</tt> type as part of your answer.  You are free to use "..." for the parts already in <strong>Fb</strong>.  Note your code need not run, we will not run it, but you could run it if you chose to verify it is correct.  You don't need to write out the code for the auxiliary functions like <tt>subst</tt>.
    </ol>

    <p>
<li>[10 points]
This question concerns operational equivalence for <strong>FbP'</strong>.  Its definition is completely analogous to Definition 2.16 in the book, applied to  <strong>FbP'</strong> in place of  <strong>Fb</strong>.
      <ol type="a">  <li>Propose a new <em>general</em> <strong>FbP'</strong> operational equivalence principle for <tt>Let (x,y) = ...</tt>.  One principle could be "<tt>Let (x,y) = (Fun z -> z)(True, 2+1) In If x Then y Else 0 ~= 3</tt>", but that is  non-general to the extreme.  Come up with a general principle in the spirit of the other principles in Section 2.4.2.  Be careful to make a <em>true</em> principle!</li>
      <li>Now use your new general principle to prove the non-general principle given above.  You can also use the other principles of 2.4.2 as steps in your proof.
	</ol>

    <p>
      <li> [20 points]
Consider a typed version of <strong>FbP'</strong> from the previous question, <strong>TFbP'</strong>, which extends  <strong>TFb</strong> of Section 6.2.2 of the book.  Along with pairs and the new <tt>Let</tt> pattern match syntax, <strong>TFbP'</strong> also includes regular typed-<tt>Let</tt> of the form <tt>Let x : tau = e in e</tt> (which was left out of <strong>TFb</strong>). Note that unlike OCaml there is no polymorphism on <tt>Let</tt>, this question concerns monomorphic <tt>Let</tt> only.
	        <ol type="a">
      <li> Give the BNF grammar of <strong>TFbP'</strong>.  Make sure to include a grammar for the types, and appropriate type declarations in the code to make writing a type checker feasible.</li>
      <li>Now, write out the new type rules.  Include two rules for <tt>Let</tt>, one for the normal let and one for the new pairs pattern let.</li>
      <li>Write out a <strong>TFbP'</strong> <tt>typecheck</tt> function which includes the cases for the two new <tt>Let</tt> forms as well as for pairs.  You don't need to repeat all the old <strong>TFb</strong> clauses, "..." is fine.  Look at Section 6.3 of the book to recall the <strong>TFb</strong> type checker structure.</li>
      <li>Finally, consider <strong>STFbRP'</strong> -- adding pairs to  <strong>STFbR</strong>.  Generally this is just putting together the  <strong>STFbR</strong> with the pair rules from  <strong>TFbP'</strong> as per the previous question, but some new subtyping rules <tt>tau <: tau'</tt> may be needed.  Either give the new subtyping rules or argue no new subtyping rules are needed.
      	</ol>
<p>

  <li> [15 points] This question concerns operational semantics for printing.
      <ol type="a">
	<li>  Consider language <strong>FbPrint</strong>, <strong>Fb</strong> with printing.  This printing is similar to what was in the <strong>AFbV</strong> binary, but can <em>only</em> print integers.  Additional expression <code>Print(e)</code> will print out the result of expression <tt>e</tt> assuming <tt>e</tt> evaluates to an integer.  Printing is a side effect like state and actors; propose a side-effecting operational semantics <tt>==></tt> for <strong>FbPrint</strong> (adding any extra parameters or annotations to <tt>==></tt>  as needed), and write the operational semantics rules for <code>+</code> and <code>Print</code> expressions (the other rules will be similar).   Make sure that you record prints in the order they occurred.</li>
	<li>When we did the <strong>AFbV</strong> operational semantics we did not include <tt>Print</tt> as a side-effect, only the actor side-effects (messages and newly created actors were accumulated in a set).  For this question, show how we could combine both actor and print side effects in the <tt>==></tt> relation for actors.  Make sure you keep the print side effects in order as above.
</ol>


<p>  

 <li>[15 points] Joey is a seriously spacey PL student.  In his PL homework he coded
     all his recursive functions incorrectly -- for example for the
     summate function he wrote
     <pre>
     combY (Function arg -> Function this ->
           If arg = 0 Then 0 Else arg + this (arg - 1)) 5
</pre>
     reversing <code>arg</code> and <code>this</code> in the parameter list, which will not work!
     <ol type="a">
       <li> But, we can work around Joey's error.  Give a modified definition of <code>Y</code>, <code>joeY</code>, which would work for Joey's program above, i.e.
	   
       <pre>
     joeY (Function arg -> Function this ->
           If arg = 0 Then 0 Else arg + this (arg - 1))) 5   ==> 15
</pre>
            <li> Now, write a <em>combinator</em> (i.e., <strong>Fb</strong> expression)
     <code>joeyFix</code> which we can
     put between Joey's bad code and the normal <code>Y</code> to fix his
     argument out-of-order problem so the normal <code>Y</code> will again work:
       <pre>
     combY ( joeyFix (Function arg -> Function this ->
           If arg = 0 Then 0 Else arg + this (arg - 1))) 5    ==> 15
</pre>
       <li> On some of the other examples Joey got mixed up with the object encoding and forgot that he didn't need to pass <code>this</code> to itself and he wrote a recursive
     function like
      <pre>
     combY (Function this -> Function arg ->
           If arg = 0 Then 0 Else arg + this this (arg - 1)) 5
</pre>
 (notice the extra <code>this</code> not needed with Y). Write a <code>joeYY</code>
     version of <code>Y</code> which would work around this bug so that
         <pre>
     joeYY (Function this -> Function arg ->
           If arg = 0 Then 0 Else arg + this this (arg - 1))) 5     ==> 15
</pre>
now works. Your answers need to be general combinators for these types of errors, not just for summate.
     </ol>  
<p>

      
<!-- QQQli>[10 points] Prove that operational equivalence for QQQstrong>FbQQQ/strong> is an equivalence relation: it is reflective, symmetric, transitive, and is a congruence (2.17-2.20 in the book).
QQQp>	
  -->
  
  <li>[12 points] Recall the mutable records of OCaml: some fields may be declared <tt>mutable</tt> which means they can be mutated just like refs.  Here is an OCaml dialog as a refresher:
<pre># type rt = {mutable a : int; mutable b : int};;
type rt = { mutable a : int; mutable b : int; }
# let r = { a = 5; b = 7};;
val r : rt = {a = 5; b = 7}
# r.b <- 4;;
- : unit = ()
# r;;
- : rt = {a = 5; b = 4}
# r.b;;
- : int = 4
	      </pre>

This question concerns a typed language with mutable records, <strong>TFbmR</strong>.   For simplicity, we will assume <em>all</em> fields are mutable in any record.  Compared to <strong>FbR</strong> the only additional syntax is <tt>e.l <- e</tt> for <tt>l</tt> a record label.  This is the same as the OCaml <tt>mutable</tt> fields in records, it is like having keyword <tt>mutable</tt> on every field.
    <ol type="a">
      <li><strong>TFbmR</strong> is a typed language with these mutable records.  For this question give all type rules needed for any record operation (including the new mutation operator).  You don't need to repeat any type rules of <strong>TFb</strong>, but do give all the record-related typing rules.
      <li>Now consider <strong>STFbmR</strong> in which we add subtyping like we did in <strong>STFbR</strong>, but now the fields are potentially mutable.  You don't need to write out any rules, but think about what it should be.
	Which direction is correct? <tt>{ a : Int;  b : Int } &lt;: { a : Int }</tt>, or  <tt>{ a : Int } &lt;: { a : Int; b : Int }</tt> Or, are both incorrect?  Briefly justify your answer. 
      <li>Repeat the previous question, but for <tt>{ c : { a : Int;  b : Int }}</tt> and <tt>{c : { a : Int }}</tt>.
</ol></li>

<p>
  
<li>[15 points] Last question, yay!  Since it is the last question it is going to be a hard one which we don't expect many people will get.<br>
  The <a href="https://en.wikipedia.org/wiki/Identity_of_indiscernibles">Leibnizian notion</a>
   of operational equivalence ~= we defined for <strong>Fb</strong> is a very general notion: "no observable difference in any context".  But, as we saw in lecture there is subtlety in getting the proper definition of "observable" and "context".  For this question we consider how to define operational equivalence for <strong>AFbV</strong>.  Remember we are defining equivalence of code (i.e. expressions), not the actors themselves.  One example of an equivalence we would like to have hold beyond the <tt>1 + 1 ~= 2</tt> sort of thing is
  <pre>(Let d = Create((Fun me -> Fun data -> Fun msg -> 0),0) In 5) ~= 5</pre>

Here we create an actor and put it in <tt>d</tt> but since that variable is never used and its scope ends, it is a garbage actor we could never reach! So, we may as well have never <tt>Create</tt>d it. So, even though it is in the global actor state its presence there is not observable by other code.  Fortunately, Lebnitzian notions are extremely general and even work in this case.
<ol type="a">
  <li>Define a general notion of <tt>~=</tt> for <strong>AFbV</strong> expressions such that it is an equivalance relation and also supports the two examples given above (and, does not equate too much, so for example <tt>1 ~= 2</tt> must fail).</li>
  <li>Equivalence in the presence of side effects can make equivalent pure functional programs not equal.  The question is if this is possible in <strong>AFbV</strong>:  either find two concrete <strong>Fb</strong> programs e1 and e2 (they can have free variables but are otherwise fully defined) such that e1 ~= e2 in <strong>Fb</strong>, but  e1 ~/= e2 (it fails) in <strong>AFbV</strong>.  OR, argue informally why no such e1/e2 exist.
    </ol>

      </ol>


    </body> </html>
