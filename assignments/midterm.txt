600.426 - Principles of Programming Languages
Spring 2016
Take Home Midterm

----------------------------------------------------------------------------------------
INSTRUCTIONS
----------------------------------------------------------------------------------------

This is a Take Home Midterm and as such operates on different rules from your regular
assignments. You are expected to work on solving these problems by yourself. You are
encouraged to talk to the TAs/Prof in office hours if you are stuck. You may discuss
general concepts with others but you are NOT allowed to discuss the particular questions
with anyone other than the Prof/TAs.

----------------------------------------------------------------------------------------
HEADER: PLEASE FILL THIS IN
----------------------------------------------------------------------------------------

Name : 

----------------------------------------------------------------------------------------
Questions
----------------------------------------------------------------------------------------

1. [10 Points] Its time to reverse engineer some operational semantics proofs.  For each
fragment below, build out a full instance of the application rule for Fb which has the
indicated substitution above the line.  Well, some are impossible - indicate which are
impossible if no derivation can be built.  (Recall that for e ==> v, both e and v must
be closed.)

Example question: y[4/y] ==> ..
Example Answer:

(Fun y -> y) ==> (Fun y -> y)    4 ==> 4    y[4/y] ==> 4
---------------------------------------------------------
       (Fun y -> y)(4) ==> 4

     a. (x + y)[3/x] ==> ..
     b. (Function x -> x + y)[3/y] ==> ...
     c. (Function x -> x + 1)[3/x] ==> ...
     d. x [(Function x -> x + x)/x] ==> ...


2. [10 points] The operational semantics for FbX included various rules to "bubble" up any
    exception raised; in HW4B we asked for you to write out all the bubbling rules for a
    hypothetical "Implies" extension to appreciate the subtleties of bubbling.  For this
    question, writing the "Implies" clause for an FbXI interpreter. The types will look
    something like this (... are the old Fb items):

    type exnlab = string

    type expr = ... Implies of expr * expr | ...
                 | Raise of exnlab * expr
                 | Try of expr * exnlab * ident * expr

    let rec eval e = match e with ...
       Implies(e1,e2) -> ... FILL IN ONLY THIS ...
       | ...
       
    All you need to do for this quesiton is to write out the evaluator clause for Implies.
    Make sure to get the spirit of bubbling implemented in your interpreter as it was
    specified in the rules.  Make sure to not use OCaml exceptions to implement FbXI
    exceptions.


3.  [15 points] Consider the language FbD - Fb augmented with immutable dictionaries (maps). 
   Dictionaries map keys to values. The following is the concrete syntax for dictionaries:
   - Literal syntax for creating dictionaries: { `key1 => e1 ; ... `keyn -> en } 
     E.g. { `Foo => False ; `Bar => 1 + 3 ; `Moo => 10 } 
     (Notice the special syntax for keys)
   - Accessing values by key: e[`key]
     E.g. { `Foo => False ; `Bar => 1 + 3 }[`Bar] results in 4
   - Append dictionary: e @@ e' produces a new dictionary that appends the right
   dictionary to the left.  Mappings in e' have priority over those in e.


     E.g { `Foo => 1 } @@ {`Bar => False} results in { `Foo => 1; ` Bar => False} and
         { `Foo => 1 } @@ {`Foo => False; `Bar => True} results in  { `Foo => False; `Bar => True }

    a. Write the operational semantics for FbD.


    b. Assume that the abstract syntax for FbD is like this:

       type key = Key of string
       type expr = ... | Dict of (key * expr) list | Get of expr * key | Append of expr * expr

       where (... indicates the original Fb AST) 

       Write eval function for FbD. Like for the FbXI question, you only need to specify
       the new cases that need to be added to the Fb interpreter.  Your code need not run,
       but of course you are welcome to run it to help debug it.


4.  [10 Points] For the following expressions, give TFb proof trees demonstrating the
    following typings, or show that no such proof tree can exist, i.e. the program is not
    typeable.  The "(fill in)" you can pick any type for, the idea is to try to find a
    type such that a full proof tree can be built, or argue why that is impossible by
    showing any tree construction must fail.

     a. (Fun f: (fill in) -> Not (f 4))(Fun x: Int -> x = 1)
     b. (Fun x : (fill in ) -> x x )
  
5.  [5 Points]  This question concerns STFb subtyping. Write a subtype of the following type:

(( {m : Int} -> {d : {x:Int; y:Int}} ) -> {w: Int; q: Int; p:Int}) -> Int

where none of the component-record types of your subtype should be identical to the
corresponding record types of the above type (this condition is added becase the type is a
subtype of itself but we don't want that answer).  Show your work: give the full proof
tree using the subtyping rules for STFb.

