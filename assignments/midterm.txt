600.426 - Principles of Programming Languages
Spring 2015
Take Home Midterm

----------------------------------------------------------------------------------------
INSTRUCTIONS
----------------------------------------------------------------------------------------

This is a Take Home Midterm and as such operates on different rules
from your regular assignments. You are expected to work on solving
these problems by yourself. You are encouraged to talk to the TAs/Prof
in office hours if you are stuck. You may discuss general concepts
with others but you are NOT allowed to discuss the particular
questions with anyone other than the Prof/TAs.

----------------------------------------------------------------------------------------
HEADER: PLEASE FILL THIS IN
----------------------------------------------------------------------------------------

Name : 

----------------------------------------------------------------------------------------
Questions
----------------------------------------------------------------------------------------

1. [10 points] The operational semantics for FbX included various rules to
    "bubble" up any exception raised.  Briefly outline how the bubbling rules
    could be implemented in a FbX extension to your Fb interpreter written in
    OCaml.  Note that pseudocode is fine, and you can say e.g. "- is similar to
    +" etc for cases that are clearly analogous.  You also need not define how
    Try or Raise are interpreted for this question, you can assume there are
    interpreter clauses for them that meet the operational semantics
    specification.


2. [15 Points]

   So far all of the questions we have asked about what is operationally
   equivalent to what are based on your understanding of the definition.  This
   definition is the mathematical *model* of operational equivalence.  For both
   program and typing we gave a *proof theoretic* meaning instead, a set of
   axioms and rules for proving facts.  We can in fact also play the "proof"
   game for operational equivalences: in the book Section 2.4.2 there are
   several equivalences listed that are known to hold for Fb programs.  So for
   example, "(Function x -> e) âˆ¼= ((Function z -> Function x -> e) z)",
   so-called eta-equivalence, is one such known fact.  This particular principle
   is an axiom, there are no preconditions on it.

   a. Going through definitions 2.16 through 2.25, which are axioms (no
   preconditions) and which are (non-axiom) rules?  They are not written as
   rules with a horizontal line but it should be evident from the statements
   which is which.

   b. Make a proof tree showing the following fact only using these axioms and proof rules:

           Function x -> ((Function y -> x + y) 5) =~ Function x -> x + 5

              
   c. As for b. but show

          (Function n -> 6) =~ (Function w -> (Function x -> If 0 = 0 Then 6 Else x) w


   If you are having trouble getting your head around b./c., here is an example.  
   Theorem.  1 + (Function x -> x) 4 =~ 5.
   Proof.
         (Function x -> x) 4 =~ 4 by beta (2.20) so
         1 + (Function x -> x) 4 =~ 1 + 4 by  congruence (2.19, letting C be  1 + hole) and
         1 + 4 =~ 5 by 2.23, so
         1 + (Function x -> x) 4 =~ 5 by transitivity between the two previous assertions.
   QED.

3.  [15 Points]

In a recent Piazza discussion about the definition of operational equivalence it
became clear that mathematics has some problems expressing partial
functions/relations - to be technically accurate you need to make sure each
function is only applied on elements for which the function is defined,
otherwise it has no meaningful result.

In programming we can deal with exceptional behavior more elegantly, by use of
*exceptions*.  For this question, we want you to write some FbX macros which
make it easy for programmers to define and deal with partial functions.

 - Assume there is a macro Undef which expands to Raise #Undefined 0 which is
   used to indicate a value is out of the domain of a function.  For example:

  posDouble = Fun x -> If x < 0 Then Undef Else x + x

  is defining a partial function on positive integers only.
  
 a.  Write a macro isDef(e,e') which assumes e (computes to) a function and e'
 is its argument and returns True if the function is well-defined on input e',
 and False if it is not (i.e. it raises Undefined).  e and e' can be arbitrary
 expressions; make sure that you are only looking for Undef inside the *body* of
 the function that e computes to, not in e.g. some function call that could in
 theory be in the argument e'.

 For example, isDef(posDouble,0-3) should return False.

 b. isDef has a nasty "side effect" in the presence of state: discuss how isDef
 could produce unexpected behavior in FbSX.

 c. One advantage of this exception-based view of partiality is how a function f
 that in turn invokes a partial function p on a value out of its domain
 implicitly becomes a partial function itself.  Give a concrete example of such
 a function f invoking some concrete p and how isDef(f,e) will correctly compute
 that it is partial for some e.
 

4.  [8 Points] Give proof trees demonstrating that the following expressions typecheck in TFb.

     a. Fun x: Int -> If x = 0 Then 0 Else 1
     b. (Fun f: (Int -> Int) -> (f 4) + 1)(Fun x: Int -> If x = 0  Then 0 Else 1)

  
5.  [5 Points]  This question concerns STFb subtyping. Write a subtype of the following type:

( {x : Int} -> {x : {x:Int; y:Int}} ) -> {x:Int; y: Int; z:Int}

where none of the component-record types of your subtype should be identical to
the corresponding record types of the above type (this condition is added becase
the type is a subtype of itself but we don't want that answer).  Show your work:
give the full proof tree using the subtyping rules for STFb.




     

  

