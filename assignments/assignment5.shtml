<!--#include virtual="/pl/header.html" -->	 
</div>

<!-- Main -->
<div id="main" class="wrapper style4">

<!-- Content -->
<div id="content" class="container">
<section>
<header class="major">
  <h2>Assigment 5: Types</h2>
</header>

<p>
    This assignment comes in two parts. For the first part, you will write a type inference algorithm for your <strong>Fb</strong> interpreter.  For the second part, you will answer a few supplemental questions on types.
</p>

<h3>Part I</h3>
<b>(80 points)</b>
<p>
    The FbDK has been designed to be extensible with typechecking. It is just turned off by default. For Part-I of the homework, 
    use the FbDK to implement the type inference algorithm for <strong>EFb</strong> in OCaml. Your implementation is expected to handle all of <strong>EFb</strong> with the exception of <tt>Let Rec</tt>.
</p><p>
    To complete this assignment, you will need to edit <tt>fbtype.ml</tt> in the <tt>src/Fb</tt> directory and implement the <tt>typecheck</tt> function which in the dist is just raising an exception.  This function must return the type of that expression as specified by the <strong>EFb</strong> algorithm; you should use the <tt>fbtype</tt> data type which appears in <tt>fbast.ml</tt>.  You may also wish to set <tt>typecheck_default_enabled</tt> to <tt>true</tt> in <tt>fbtype.ml</tt>; if you do not do this (and also do not pass <tt>--typecheck</tt> command-line flag), then the typechecker will not be used.  For this part, you should turn in your <tt>fbtype.ml</tt> file and nothing else.  Do not change <tt>fbast.ml</tt> or similar files, since your code will be auto-graded by dropping your <tt>fbtype.ml</tt> file into a correct implementation of <strong>Fb</strong>.
</p><p>
    The <code>Fb</code> binary from the website also supports typechecking. You can turn it on by passing <tt>--typecheck</tt> to it. As an example, a correctly working interpreter should behave as follows:
</p>
<pre>
$ ./Fb --typecheck
Fb version 1.23         (typechecker enabled)

# (Function x -> Function y -> x + y) 4;;
: Int -> Int
==> Function y ->
4 + y
# Function x -> x;;    
: 'a -> 'a
==> Function x ->
x
# True + 1;;
Exception: Fbtype.TypeInferenceFailure("immediately inconsistent types")
</pre>
<p>
    Note that, by default, the type of the expression is printed. Look at the command line options with <tt>--help</tt> for more information.
</p>
<p>
    Note also that the exception which is raised by a type error is defined in the <tt>fbtype.ml</tt> module; you must define your own exception(s) to throw when the expression cannot be assigned a type.
</p><p>
    You need to implement the full algorithm <em>except</em> you do not need  to implement the cycle detection algorithm - your checker can loop forever on programs with cyclic constraints (but only on such programs).  Extra credit will be given for implementing cycle detection.  Also, you don't need to include the let-polymorphism of <strong>PEFb</strong>.
</p><p>
    Here are some suggestions:
</p>
<ul>
    <li>
        
          The reference implementation binaries that we provide for this class already have an implementation of <strong>EFb</strong>, so you can experiment.  Run the <tt>Fb</tt> binary with the flag <tt>--typecheck</tt>.  (Using this flag is equivalent to setting <tt>typecheck_default_enabled</tt> to <tt>true</tt>.)
        
    </li>
    <li>
            Break down your implementation into the same phases as in lecture and the book:
        <ol>
            <li>
                    Generate the type <code>&tau; \ E</code> using the ideas in the type system (and also following the typechecker for <code>TFb</code> in the book),
            </li>
            <li>
                    Perform the closure on <code>E</code>,
            </li>
            <li>
                    Check the closure for immediate inconsistencies, and
            </li>
            <li>
                    Substitute equations of <code>E</code> into <code>&tau;</code> to solve.
            </li>
        </ol>
    </li>
    <li>
        
            The <code>E</code> is a set of pairs (the type equations &tau; = &tau;'); built-in Caml types such as <code>Set</code> or <code>Map</code> may prove useful in your implementation of  this data structure.  You can use any of the built-in libraries but the auto-grader cannot install any extra packages to run your type checker.
        
    </li>
    <li>
        
            In the closure outlined in the book, we assumed = was symmetric; in your implementation, one easy (but inefficient) method to achieve this to add an additional closure step: every time you add &tau; = &tau;' to the closure, also add &tau;' = &tau;.
        
    </li>
    <li>
        
            The "substitute to solve" phase is the same idea as your substitution function you wrote on terms; just do it on types.
        
    </li>
    <li>
        
            During testing, it may be useful to run your interpreter with the <tt>--show-backtrace</tt>. This will give you a stack trace for any exceptions that occur. Unfortunately this feature works only on the compiled binary and not in the interpreter.
        
    </li>
    <li>
        
            Don't worry about efficiency.  <b>Do</b> worry about correctness.
        
    </li>
</ul>

<h3>Part II</h3>
<ol>
        <b>(20 points)</b>
    
        In this part, you will be answering a question about typing.
<p>    

           In a previous assignment we extended Fb with variants pairs and let to make <strong>FbVPL</strong>. Here we will extend the variants component of that language (only) with types: <strong>TFbV</strong>. In this question you are just making a type system, the mathematical specification for the type checker.  Variant types are added to <strong>TFb</strong>'s types; they will be slightly different than OCaml syntax, they will be e.g. <pre>`good(Int) | `bad(Bool)</pre>

	We also need to add some type labels to facilitate type checking, modifying slightly the <strong>TFbV</strong> syntax:
replace <code>`n(e)</code> with <code>`n(e):&tau;</code> - all variant data is tagged with a variant type (we don't have the <tt>type</tt> declarations of OCaml so we need to manually do this; this type also needs to include all potential variants since we have no subtyping here.).  For example: <code>`good(0): `good(Int) | `bad(Bool)</code>.
        
        
          <ol class="a">
	    <li>Your task is to write the new type rules beyond those already present in <strong>TFb</strong> to make a full type system for <strong>TFbV</strong>.  Note you don't need to implement anything for this question.  Please make your rule be strict -- OCaml will sometimes give a warning if there is a case missing, you should not allow those programs to typecheck in your rule. (To model the warning we would need to include a warning flag in our type system.)
	    <li>Show your rules work by proving the simple program
	      <pre>Match (`good(0): `good(Int) | `bad(Bool)) With `good(_) -> 0 | `bad(_) -> 1</pre> typechecks: construct the type tree for it.</li>
	    <li>Describe why the same program but with the <tt>`bad</tt> case removed fails to typecheck in your rules (yes, it should fail even though that case is not invoked).
	      </ol>
        
    </li>
</ol>


<h3>Submission and Grading</h3>

<ul>
  <li>There will be two separate submissions in Gradescope for this assignment: "Assignment 5 typechecker" for part I (which will be auto-graded;  upload ONLY the file <tt>fbtype.ml</tt>), and  "Assignment 5 written" for the written question. <em>In your written question submission please include your name and list of collaborators if any.</em></li>
    </ul>
	
</section>
</div>
</div>


<!--#include virtual="/pl/footer.html" -->
