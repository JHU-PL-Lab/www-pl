<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>PL Take-Home Final 2020</title>
</HEAD>
<BODY LINK="#0000FF" VLINK="#800080" bgcolor="#F0FFF0">
<h3> 601.426/626, Princples of Programming Languages
<br> Spring 2020
<br> Take-Home Final Examination
<br> 
</h3>
The rules:
<ul>
  <li>The answers must be your own work.  You may ask questions during office hours and post private questions to instructors on Piazza, but you may not discuss the questions in any way with anyone else.</li>
  <li>You are free to consult the textbook, lecture notes, and any other fixed resource you can find on the Internet.  You may not ask questions on any Internet forum etc.</li>
  <li>Make sure to watch Piazza for clarifications posted by Instructors.
  <li>You must turn in your answers to Gradescope by Monday May 11th at 11:59PM.  No late days may be used.</li>
    </ul>

<strong>Good Luck!</strong>
<hr>
<ol>

  <li> [30 points] Consider the language <strong>FbP'</strong> which is
    <strong>Fb</strong> with pairs but lacking the left/right projections.  Instead, it supports pattern matching on pairs as an extension to <tt>Let</tt>.  So for example you could write
    <pre>Let (x,y) = (Fun z -> z)(True, 2+1) In If x Then y Else 0</pre>

    These new patterns are shallow only, for example you cannot write <tt>Let (x,(z,y)) = ...</tt>, and the <tt>x</tt> and <tt>y</tt> need to be variables.

    <ol type="a">
      <li>Give the BNF grammar for <strong>FbP'</strong> based on the above informal description.  Be sure to include the grammar of values as well.  Note it is a strict extension of the <strong>Fb</strong> grammar.</li>
      <li>Give the operational semantics rules for <strong>FbP'</strong> which are not already in the <strong>Fb</strong> rule set.</li>
      <li>Prove that <strong>FbP</strong> (the pairs of Section 3.1 in the book) and <strong>FbP'</strong> above have equivalent expressiveness: make  an <strong>Fb</strong> macro encoding the above new pattern match, and make <strong>FbP'</strong> macros for the left/right pair projections.</li>
      <li>  Write an OCaml interpreter for <strong>FbP'</strong>, in the
	form of a function <code>eval : expr -> expr</code>.  You can leave out all the standard <strong>Fb</strong> evalaution clauses.  Define a revised <tt>expr</tt> type as part of your answer.  You are free to use "..." for the parts already in <strong>Fb</strong>.  Note your code need not run, we will not run it, but you could run it if you chose to verify it is correct.  You don't need to write out the code for the auxiliary functions like <tt>subst</tt>.
    </ol>

    <p>
<li>[10 points]
This question concerns operational equivalence for <strong>FbP'</strong>.  Its definition is exactly analogous to Definition 2.16 in the book, applied to  <strong>FbP'</strong> in place of  <strong>Fb</strong>.
      <ol type="a">  <li>Propose a new <em>general</em> <strong>FbP'</strong> operational equivalence principle for <tt>Let (x,y) = ...</tt>.  One principle could be "<tt>Let (x,y) = (Fun z -> z)(True, 2+1) In If x Then y Else 0 ~= 3</tt>", but that is  non-general to the extreme.  Come up with a general principle in the spirit of the other principles in Section 2.4.2.  Be careful to make a <em>true</em> principle!</li>
      <li>Now use your new general principle to prove the non-general principle given above.  You can also use the other principles of 2.4.2 as steps in your proof.
	</ol>

    <p>
      <li> [20 points]
Consider a typed version of <strong>FbP'</strong> from the previous question, <strong>TFbP'</strong>, which extends  <strong>TFb</strong> of Section 6.2.2 of the book.  Along with pairs and the new <tt>Let</tt> pattern match syntax, <strong>TFbP'</strong> also includes regular typed-<tt>Let</tt> of the form <tt>Let x : tau = e in e</tt> (which was left out of <strong>TFb</strong> for some reason). 
	        <ol type="a">
      <li> Give the grammmar of <strong>TFbP'</strong>.  Make sure to include a grammar for the types, and appropriate type declarations in the code to make writing a type checker feasible.</li>
      <li>Now, write out the new type rules.  Include two rules for <tt>Let</tt>, one for the normal let and one for the new pairs pattern let.</li>
      <li>Write out a <strong>TFbP'</strong> <tt>typecheck</tt> function which includes the cases for the two new <tt>Let</tt> forms as well as for pairs.  You don't need to repeat all the old <strong>TFb</strong> clauses, "..." is fine.  Look at Section 6.3 of the book to recall the <strong>TFb</strong> type checker structure.</li>
      <li>Finally, consider <strong>STFbRP'</strong> -- adding pairs to  <strong>STFbR</strong>.  Generally this is just putting together the  <strong>STFbR</strong> with the pair rules from  <strong>TFbP'</strong> as per the previous question, but some new subtyping rules <tt>tau <: tau'</tt> may be needed.  Either give the new rules or argue no new subtyping rules are needed.
      	</ol>
<p>

  <li> [15 points] This question concerns operational semantics for printing.
      <ol type="a">
	<li>  Consider language <strong>FbPrint</strong>, <strong>Fb</strong> with printing.  This printing is similar to what was in the <strong>AFbV</strong> binary, but can <em>only</em> print integers.  Additional expression <code>Print(e)</code> will print out the result of expression <tt>e</tt> assuming <tt>e</tt> evaluates to an integer.  Printing is a side effect like state and actors; propose a side-effecting operational semantics <tt>==></tt> for <strong>FbPrint</strong> (adding any extra parameters or annotations to <tt>==></tt>  as needed), and write the operational semantics rules for <code>+</code> and <code>Print</code> expressions (the other rules will be similar).   Make sure that you record prints in the order they occurred.</li>
	<li>When we did the <strong>AFbV</strong> operational semantics we did not include <tt>Print</tt> as a side-effect, only the actor side-effects.  For this question, show how we could combine both actor and print side effects in the <tt>==></tt> relation for actors.  Make sure you keep the print side effects in order as above.
</ol>


<p>  

 <li>[15 points] Joey is a seriously spacey PL student.  In his PL homework he coded
     all his recursive functions incorrectly -- for example for the
     summate function he wrote
     <pre>
     combY (Function arg -> Function this ->
           If arg = 0 Then 0 Else arg + this (arg - 1)) 5
</pre>
     reversing <code>arg</code> and <code>this</code> in the parameter list, which will not work!
     <ol type="a">
       <li> Give a modified definition of <code>Y</code>, <code>joeY</code>, which would work for Joey's program above, i.e.
	   
       <pre>
     joeY (Function arg -> Function this ->
           If arg = 0 Then 0 Else arg + this (arg - 1))) 5   ==> 15
</pre>
            <li> Now, write a <em>combinator</em> (i.e., <strong>Fb</strong> expression)
     <code>joeyFix</code> which we can
     put between Joey's bad code and the normal <code>Y</code> to fix his
     argument out-of-order problem so the normal <code>Y</code> will again work:
       <pre>
     combY ( joeyFix (Function arg -> Function this ->
           If arg = 0 Then 0 Else arg + this (arg - 1))) 5    ==> 15
</pre>
       <li> On some of the other examples Joey got mixed up with the object encoding and forgot that he didn't need to pass <code>this</code> to itself and he wrote a recursive
     function like
      <pre>
     combY (Function this -> Function arg ->
           If arg = 0 Then 0 Else arg + this this (arg - 1)) 5
</pre>
 (notice the extra <code>this</code> not needed with Y). Write a <code>joeYY</code>
     version of <code>Y</code> which would work around this bug so that
         <pre>
     joeYY (Function this -> Function arg ->
           If arg = 0 Then 0 Else arg + this this (arg - 1))) 5     ==> 15
</pre>
now works.   
     </ol>  
<p>

      
<li>[10 points] Prove that operational equivalence for <strong>Fb</strong> is an equivalence relation: it is reflective, symmetric, transitive, and is a congruence (2.17-2.20 in the book).
<p>	
    
  <li>[20 points] Recall the mutable records of OCaml: some fields may be declared <tt>mutable</tt> which means they can be mutated just like refs.  Here is an OCaml dialog as a refresher:
<pre># type rt = {mutable a : int; mutable b : int};;
type rt = { mutable a : int; mutable b : int; }
# let r = { a = 5; b = 7};;
val r : rt = {a = 5; b = 7}
# r.b <- 4;;
- : unit = ()
# r;;
- : rt = {a = 5; b = 4}
# r.b;;
- : int = 4
	      </pre>

For this question you are to define a language with mutable records, <strong>FbmR</strong>.   For simplicity, we will assume <em>all</em> fields in a record are mutable.  Compared to <strong>FbR</strong> you only need to support the additional field mutation syntax <tt>e.l <- e</tt> for <tt>l</tt> a record label.
    <ol type="a">
      <li>Give the operational semantics for <strong>FbmR</strong> which should follow the analogous OCaml behavior as shown in the OCaml top loop example above. Since there is mutation you will need a store <em>S</em> as in <strong>FbS</strong>; you can make the format of the store be whatever you want.  Also as with <strong>FbS</strong> you will need to redo all of the old <strong>Fb</strong> rules to thread the state.
        Since that would take a lot of writing, for your answer here just show the revised <tt>+</tt> rule.  Do make sure to give rules for all of the record operations: record formation, projection (<tt>.</tt>) and field mutation (<tt>&lt;-</tt>).
      <li>We can extend <strong>FbmR</strong> to a typed version <strong>TFbmR</strong>.  For this question give all type rules needed for any record operation.  You don't need to repeat any type rules of <strong>TFb</strong>, but do give all the record-related typing rules.
      <li>Now consider <strong>STFbmR</strong> in which we add subtyping like we did in <strong>STFbR</strong>, but now the fields are potentially mutable.  You don't need to write out any rules, but think about what it should be.
	Which direction is correct? <tt>{ a : Int;  b : Int } &lt;: { a : Int }</tt>, or  <tt>{ a : Int } &lt;: { a : Int; b : Int }</tt> Or, are both incorrect?  Briefly justify your answer. 
      <li>Repeat the previous question, but for <tt>{ c : { a : Int;  b : Int }}</tt> and <tt>{c : { a : Int }}</tt>.
</ol></li>




    <!--
QQQp>    QQQh1>FODDERQQQ/h1>

  QQQp style="page-break-after:always;">QQQ/p>

    

  QQQli>[10 points] QQQ/li>
      The QQQstrong>FbSQQQ/strong> operational semantics in fact accumulates garbage in the state QQQem>SQQQ/em> that is never collected (and the QQQstrong>SbFRQQQ/strong> implementation we provide also doesn't collect garbage, so programs that could terminate may run out of memory just because our interpreter is not garbage collecting the heap).  Given an FbS state (e,S), describe a garbage collection algorithm over it.
    

	QQQli>
	  QQQp>In AFbv, an actor can send messages to some other actors without blocking itself. In the semantics, we know there are a global soup, where actors can send and grab message in and from it.QQQ/p>

QQQp>Imagine the universe of Fb, where lots of stars who have expressions to evaluatesQQQ/p>

QQQp>e ::= ... | Universe(e, e, ...)QQQ/p>

QQQp>QQQcode>Universe(e, e, ...)QQQ/code> can be treated as a list of multiple concurrent expressions in which each expression evaluates locally, if some expression get stuck, the other expression can still evaluate. We use QQQcode>DustQQQ/code> to indicate an obvious stuck computation or the proof tree exceeds the height of 42. (~~shiwei: the to avoid HALT problems)QQQ/p>

QQQp>e.g.QQQ/p>

QQQp>QQQcode>Universe[1, True, (0 0), (Fun x -&gt; x + 1) 1]QQQ/code> 
==> QQQcode>Universe[1, True, Dust, 2]QQQ/code>QQQ/p>

QQQp>(a)
Q: Describe informally how QQQcode>Universe[e1, e2, ..., en]QQQ/code> evaluatesQQQ/p>

QQQp>(b)
Wormholes appear in the universe. It looks like thisQQQ/p>

QQQp>v ::= ...| w (as the name of wormholes like cell names in the store)QQQ/p>

QQQp>e ::= ...
  | CreateWormhole
  | Depart(w, e)
  | Arrive(w)QQQ/p>

QQQp>Unlike the message sending in actors, the QQQcode>Depart(w, e)QQQ/code> and QQQcode>Arrive(w)QQQ/code> will block each expressions solely until they appears simultaneously in the universe. At that moment, QQQcode>Depart(w, e)QQQ/code> becomes QQQcode>0QQQ/code> while QQQcode>Arrive(w)QQQ/code> becomes QQQcode>eQQQ/code>.QQQ/p>

QQQp>A value come travel along a wormhole QQQcode>wQQQ/code> if there is exactly one Depart and one Arrive of it. If at any moment, that are more that one QQQcode>DepartQQQ/code> or QQQcode>ArriveQQQ/code>, the stars related to that wormhole becomes QQQcode>DustQQQ/code>.QQQ/p>

QQQp>QQQpre>OCaml
let w = CreateWormhole
  in let e1 = 
    let _ = Depart(w, 1) in 1
  in let e2 = 
    Arrive(w) + 1
  in Universe[e1, e2]
==&gt;
  Universe[1, 2]
QQQ/pre>QQQ/p>

QQQp>Q: Write operational semantics of the new expressions of wormholes (the rules are used locally but you may need mention the universe in the rules).QQQ/p>

QQQp>(c)
FbWormhole can mimic actors.QQQ/p>

QQQp>QQQpre>OCaml
  let whEarth = CreateWormhole
  in let whNepture = CreateWormhole
  in 
    (* FILL CODE HERE *)
  in let threebody = Arrive(earth, 1); Arrive(neptune, 1); Arrive(earth, 0); Arrive(neptune, 0); 3 QQQbr />
  in Universe [threebody, earth, neptune]
QQQ/pre>QQQ/p>

QQQp>Fill the code to make the universe to evaluate to QQQcode>Universe[3, 3, 3]QQQ/code>.
Noting QQQcode>earthQQQ/code> cannot use QQQcode>whNeptureQQQ/code> and QQQcode>neptuneQQQ/code> cannot use QQQcode>whNeptureQQQ/code>.QQQ/p>

      -->
																																


      </ol>


    </body> </html>
