600.426 - Programming Languages
JHU Spring 2013
Homework - 6 (50 Points)

----------------------------------------------------------------------------------------
HEADER: PLEASE FILL THIS IN
----------------------------------------------------------------------------------------

Name                  :
List of team Members  :
List of discussants   :

--------------------------------------------------------------------------------------------------
 Stateful Dictionaries
--------------------------------------------------------------------------------------------------

1. At the root of Python's object model is the idea of mutable dictionaries.
   For this question we will implement the language FbSMD - FbS with mutable
   dictionaries. (For the midterm we extended Fb with immutable dictionaries)

   FbSMD augments FbS with the following syntactic constructions:
    - Literal syntax for creating dictionaries: { `key1 => e1 ; ... `keyn -> en }
      E.g. { `Foo => False ; `Bar => 1 + 3 ; `Moo => 10 }
    - Accessing values by key: e[`key]
      E.g. { `Foo => False ; `Bar => 1 + 3 }[`Bar] results in 4
    - Mutating the dictionary: [Note: This does NOT create a new dictionary]
      E.g. {`Foo => 1 ; `Bar => 2} <- {`Bar => 5} results in {`Foo => 1 ; `Bar => 5}
        and Let d = {`Foo => 1 ; `Bar => 2} In d <- {`Bar => 5} ; d results in {`Foo => 1 ; `Bar => 5}
        and Let d = {`Foo => 1 } In d <- {`Moo => 5} ; d results in {`Foo => 1 ; `Moo => 5}

   Part A: Write out the operational semantics for FbSMD. You only need to
   specify the additional rules (beyond those already in FbS)

   Part B: FbSMD dictionaries are not quite as flexible as those in Python.
   What operations would you need to add to the language to make it as flexible
   as python?

   [10 Points]

--------------------------------------------------------------------------------------------------
 Acting up
--------------------------------------------------------------------------------------------------

2a. Implement an up-down counter actor in AFbV. A user can switch the counter's
    "direction" (i.e. up or down) by sending it a message. The count is
    incremented/decremented when it receives a `count message. (By default the counter
    starts at zero and counts up)
     - `up - If the payload is the boolean value True, the counter is set to count up, else it counts down
     - `count - Increments or decrements the counter based on the currently set direction. (The payload is not used)

    [8 Points]


2b. In many concurrent applications it is necessary for groups of entities to broadcast
    messages among themselves. Broadcasted messages are received by all members of the group.
    For this question we will design a (rather simplistic) broadcast system within the actor
    model.

    Implementing broadcasting directly among a set of actors is not very scalable. The
    actor model is based on explicit messaging between named actors. So broadcasting requires
    each member of the group to be actively track the names of all actors currently in the
    group and send messages to each one explicitly. This is somewhat painful. However there are
    ways to simplify this.
    
    Consider the notion of a "Group" actor:
      - A specific instance of the group actor represents a group of actors.
      - Actors can register with a group by sending a `register message to the group actor.
        The payload of the message is the actor name. Similarly you can unregister by sending
        the `unregister message to the group (again with the actor name as payload)
      - Group actors also handle a `broadcast message. The payload in this case is a message
        to broadcast. When this message is received by the group actor, it forwards the message
        (indicated by the payload) to each actor currently registered with the group.

    Write out the AFbV code for the Group actor. (For simplicity you can assume that the AFbV
    has been augmented with pairs, lists and the Let ... In ... syntax)

    [12 Points]

--------------------------------------------------------------------------------------------------
 Meta-Questions
--------------------------------------------------------------------------------------------------

3. We touched upon the topics of staged computation and metaprogramming in
   class in conjunction with C++ templates and MetaML. 

   Now consider the Fb interpreter that we wrote for Homework-3. It works by
   translating Fb code in to OCaml abstract syntax trees and evaluating them -
   a process that transforms the Fb ast in to another (generally simpler) Fb
   ast. So we were in fact doing a kind of metaprogramming without being
   explicit about it!
   
   For this question we will do some metaprogramming explicitly.
   
   Your task is to write an OCaml function that accepts a list of Fb functions
   [f1; f2; .. ;fn] (in the form of asts) and produce a new Fb function f =
   fn.fn...f3.f3.f3.f2.f2.f1 where . indicates composition.  i.e. Given an
   argument, the new function applies f1 to it once, f2 to the result twice, f3
   thrice etc up to fn applied n times.

   (* Fbast.expr list -> Fbast.expr *)
   let compose fnlist = (* ANSWER *)

   (*
     # let fns = [parse "Function x -> If x Then 1 Else 10" ; parse "Function y -> y + 1"; parse "Function z -> z + z"] ;;
     val fns : Fbast.expr list =
       [Function (Ident "x", If (Var (Ident "x"), Int 1, Int 10));
         Function (Ident "y", Plus (Var (Ident "y"), Int 1));
         Function (Ident "z", Plus (Var (Ident "z"), Var (Ident "z")))]
     
     # ppeval (compose fns) ;;
     ...
     # ppeval (Appl(compose fns, Bool true)) ;;
     ==> 24
     - : unit = ()
     # ppeval (Appl(compose fns, Bool false)) ;;
     ==> 96
     - : unit = ()
   *)

   [8 Points]

--------------------------------------------------------------------------------------------------
 A language here and a language there
--------------------------------------------------------------------------------------------------

4a. Many languages support variadic functions - i.e. Functions that accept a
    variable number of arguments. However languages tend to implement them
    differently (and consequently they have their specific features and
    limitations).

    For this question compare how variadic functions are implemented in the
    following languages: Java, Python, C and C++

    [4 Points]

4b. C/Java/Python all implement the standard || and && short-circuiting boolean
    operators. However in each case the semantics is somewhat different. Explain
    the difference in semantics.

    Can the python semantics for these operations be easily ported to Java? Why
    or why not?

    [4 Points]

4c. When Mixins are implemented in C++, they often have the following structure:

  template<class T>                                      template<class T>
  class LogTask : public T                               class TimedTask : public T
  {                                                      {
    public:                                                public:
      void Execute()                                         void Execute()
      {                                                      {
          cout << "LOG: Executing task\n" ;                      time_t start = time(NULL);
          T::Execute();                                          T::Execute();
      }                                                          double diff = time(NULL) - start;
  };                                                             cout << "LOG: Time taken to execute: " << diff << "\n";
                                                             }
                                                         };

  Notice how the mixins LogTask and TimedTask are defined. They can be used like this:
  
  class Task                                             class LoggedTimedTask : public LogTask<TimedTask<Task> >
  {                                                      {
      public:
        void Execute()                                   };
        { 
            cout << "Performing Task\n"; 
        }
  };

  Can similar code work in Java? Explain why or why not.

  [4 Points]
