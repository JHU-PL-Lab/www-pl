600.426 - Programming Languages
JHU Spring 2015
Homework - 6 (50 Points)

----------------------------------------------------------------------------------------
HEADER: PLEASE FILL THIS IN
----------------------------------------------------------------------------------------

Name                  :
List of team Members  :
List of discussants   :

--------------------------------------------------------------------------------------------------
 Acting up
--------------------------------------------------------------------------------------------------

1a. In many concurrent applications it is necessary for groups of entities to broadcast
    messages among themselves. Broadcasted messages are received by all members of the group.
    For this question we will design a (rather simplistic) broadcast system within the actor
    model.

    Implementing broadcasting directly among a set of actors is not very scalable. The
    actor model is based on explicit messaging between named actors. So broadcasting requires
    each member of the group to be actively track the names of all actors currently in the
    group and send messages to each one explicitly. This is somewhat painful. However there are
    ways to simplify this.
    
    Consider the notion of a "Group" actor:
      - A specific instance of the group actor represents a group of actors.
      - Actors can register with a group by sending a `register message to the group actor.
        The payload of the message is the actor name. Similarly you can unregister by sending
        the `unregister message to the group (again with the actor name as payload)
      - Group actors also handle a `broadcast message. The payload in this case is a message
        to broadcast. When this message is received by the group actor, it forwards the message
        (indicated by the payload) to each actor currently registered with the group.

    Write out the AFbV code for the Group actor. 
    
    You can use the template below and fill in the answer. Feel free to tweak the template if you
    feel like it; some helper functions may be useful for example. As long as the actor does what
    it is supposed to do, it should be fine.
    
    Note that to use the template in eclipse, you need the binary version of the FbDK and a copy of the
    fbdktoploop.ml from the AFbv directory of the FbDK source. Switch to the directory where the library
    files in the binary are and start a toploop. Then load the above fbdktoploop.ml file and you should
    be set to go.

    [20 Points]

let expr = parse "
    Let ycomb = (
      Function body -> Let wrapper = Function this -> Function arg -> body (this this) arg In 
      Function arg -> wrapper wrapper arg
    ) In
    Let group = 
      (* ANSWER *)
    In
    Let printer = Function myaddr -> ycomb (
      Function this -> Function localdata -> Function msg ->
        Match msg With
        `message t -> (Print \"---> \"); (Print t); (Print \"\n\") ; (this localdata)
    ) In
    Let a_group = Create(group, []) In (* TODO: Set up your own local data instead of 0 *)
    Let a1 = Create(printer, 0) In
    Let a2 = Create(printer, 0) In
    (a_group <- `register a1) ; (a_group <- `register a2) ;
    (a_group <- `broadcast (`message \"Hello\"))
" ;;

# ppeval expr ;;

(*
==> ---> Hello
---> Hello
`broadcast(`message(Hello))
- : unit = ()
*)

1b. Let us use the implementation above to build a simple chat room system.
 
    The primary components of the system are
    - A "Server" actor. This is a singleton instance that is usually created at start.
    - Chat Rooms instances. Chat rooms have (string) names. Messages sent to the room are seen by
      all clients connected to the room. (Hint: A chat room is easily implemented with a Group actor
      from above)
    - "Client" actor instances. Clients are connected to a specific chat room (in our scenario) on
      the server and can send and receive messages to the chat room.


    The Server accepts three messages `connect, `disconnect and `message.
    - The payload for `connect is a pair consisting of the name of the room and the address of the
      client. If the specified room does not exist yet, the server creates the room. It then
      generates a 'token' and sends a `registered message to the client actor with the token as the
      payload.  The token indicates that the particular client has registered with the particular
      chat room. Its exact datatype is up to you. It will be used as a parameter in other messages
      the server receives. 
    - The `disconnect message takes the token (from the registration scenario above) as payload and
      disassociates the client from the room.
    - The payload for `message is a pair consisting of the token and the text message to send. The
      server uses the token to discover which chat room the message should be sent to. It then sends
      a `receive message (with the text message as payload) to all registered clients of the
      specific chat room.

    A Client actor accepts 4 messages - `initialize, `registered, `send and `receive:
    - `initialize takes as payload a pair consisting of the name of a server actor and a channel to connect 
      to. On receiveing this message, the client must register with the server for the specific channel name.
    - For `registered, the payload is a token as indicated above. This will need to be stored and used 
      for future communication.
    - `send takes a text message as payload and broadcasts it to the chat room.
    - `receive has a payload consisting of a text message. For the current implementation, simply
      print out the message.

    Write out the AFbV code for the Server and Client actors.

    [20 Points]

let expr = parse "
    Let ycomb = (
      Function body -> Let wrapper = Function this -> Function arg -> body (this this) arg In 
      Function arg -> wrapper wrapper arg
    ) In
    Let server = 
        (* ANSWER *)
    In
    Let client =     
        (* ANSWER *)
    In
    Let a_server = Create(server, 0) In         (* TODO: Set up your own local data instead of 0 *)
    Let a_client1 = Create(client, 0) In        (* TODO: Set up your own local data instead of 0 *)
    Let a_client2 = Create(client, 0) In        (* TODO: Set up your own local data instead of 0 *) 
    (a_client1 <- `initialize (a_server, \"Foo\")) ;
    (a_client2 <- `initialize (a_server, \"Foo\")) ;
    (a_client1 <- `send \"Hello\")
" ;; 

ppeval expr ;;

(*
==> A3 ---> Hello
A2 ---> Hello`send(Hello)
- : unit = ()
*)

1c. For this question we will explore the operational semantics of the Actor system in some detail.

    Suppose the current state of the chat room system above is: 
      G = { <a_server, ...>, <a_c1, ...>, <a_c2, ...>} U { }
    where a_server is a Server instance and a_c1 and a_c2 are two client actors.

    The users do the following:
    - a_c1 connects to ChatRoom "Company"
    - After a_c1 connects, a_c2 connects to the same chat room
    - a_c1 sends "Hello World" to that chat room

    Specify in sequence the messages that will be sent by the system and at each step write out the
    global state as the corresponding Send operation finishes.

    [10 Points]
    

   
