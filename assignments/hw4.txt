600.426 - Programming Languages
JHU Spring 2012
Homework - 4 (100 points)

----------------------------------------------------------------------------------------
HEADER: PLEASE FILL THIS IN
----------------------------------------------------------------------------------------

Name                  :
List of Collaborators :

Please make a good faith effort at listing people you discussed any problems with here,
as per the course academic integrity policy. TA/CA/Prof need not be listed.


----------------------------------------------------------------------------------------
Section 1: Operational Equivalence
----------------------------------------------------------------------------------------

1a. For each of the following Fb expressions, indicate whether operational equivalence
    holds. If it does not, show some context that evaluates differently dependent upon 
    which of the two expressions you use. (Remember: it only takes one of the infinitely 
    many contexts to make the two expressions operationally inequivalent)

    In the expressions below e0 and e1 indicate *arbitrary* Fb expressions.

    [15 Points]

    1. z + z =~ z + z - z + z

    2. e0 + e1 =~ e1 + e0

    3. (Function x -> x x) =~ (Function x -> x x x)


1b. Redo the above assuming that these are FbS (Fb with State) expressions. (Naturally, 
    e0 and e1 indicate arbitrary FbS expressions for this question (and not Fb expresions))

    [15 Points]

----------------------------------------------------------------------------------------
Section 2: Mutable Records
----------------------------------------------------------------------------------------

2a. Consider a new language FbMR - Fb with Mutable Records which includes records with
    mutable fields. For simplicity *all* fields of FbMR records are implicitly mutable - 
    you don't need a special keyword like in Ocaml. 

    There are 3 operations that you can perform on a mutable record - creation, selection
    of a field, update of a field. We use a syntax similar to FbR for this. Example:
 
    Let r = { x = 3 + 4 ; y = (Function a -> a + 1) ; } In
    	(r.x <- r.x + 2); (r.y r.x)

    returns 10 (where Let and ; are macros with the usual meaning)

    The value and expression (abstract) syntax of Fb will need to be extended to accomodate 
    the new syntax for mutable records. You must provide these extensions along with the
    set of new operational semantics rules required for FbMR. (Hint: Use FbR and FbS
    definitions as your guides)

    [20 Points]


----------------------------------------------------------------------------------------
Section 3: Stateful operations and proof trees
----------------------------------------------------------------------------------------

3a. The book doesn't exhaustively describe the operational semantics rules for FbSR. But
    they are straightforward. Write out the rule(s) for the following FbSR expressions:

      1. If expression (i.e. If e Then e1 Else e2)
      2. Equal expression (i.e. e1 = e2)
      3. Let .. In expression (i.e Let x = e In e')

    [15 Points]

3b. Show the proof tree for the evaluation of the FbSR statement:
    Let c = Ref 0 In (Function dummy -> !c) ((Function x -> x := !x + 1) c) 

    [7 Points]

3c. Show the proof tree for the evaluation of the FbX statement:
    (Function x -> Try (Try (1 + Raise (#Exit 2)) With #Fail n -> 1-n) With #Exit n -> n) 0

    [8 Points]

----------------------------------------------------------------------------------------
Section 4: Classes and Objects
----------------------------------------------------------------------------------------

4a. The notion of classes can be easily encoded in FbSR. It was mentioned in class
    (and in the book) that Records and Variants are duals. So it should be possible to
    translate classes in to a language with Variants and State (FbSV).

    Provide a translation for Point and ColorPoint classes in to FbSV. The corresponding
    Record based versions are in sections 5.1.4 and 5.1.5 respectively. The translation
    in to FbSV must match the functionality and behavior of the FbSR one.

    (For simplicity, you can assume that FbSV has Let .. In syntax similar to FbSR)

    Hint: Remember that the only "useful" operation on a Variant is a Match. So it might be
    worth thinking about classes (and objects) in terms of the messages they accept and
    the responses they provide. Here is a trivial (incomplete) encoding for the simple
    object Point from section 5.1.1:

      Let point = Function msg ->
        Match msg With
            `x(dumy) -> 4
          | `y(dumy)  -> 3;
          | `magnitude(dumy) -> Function this -> ...
          | `iszero(dumy) ->  Function this ->
          
      } In ...

    [20 Points]