<!--#include virtual="/pl/header.html" -->	 
</div>

<!-- Main -->
<div id="main" class="wrapper style4">

<!-- Content -->
<div id="content" class="container">
<section>
<header class="major">
<h2>Java</h2>
</header>


Our reference here  is  the <a
href="http://docs.oracle.com/javase/specs/jls/se10/html/index.html">Java
Language Specification, SE 10 Edition</a>.<p>
<ul>
  <li>The book contains three languages which collectively cover the core of Java: <strong>FbOB</strong> (objects), <strong>STFb</strong> (subtyping), and <strong>PEFb</strong> (the P, polymorphism/generics part, not the inference part). 
  <li>An Fb family language corresponding to core Java would be "<strong>PSTFbOB</strong>"
  <li>We did not cover this but most of the aspects would not be surprising to you; a few gaps include
      <ul>
	<li><strong>STFb</strong> had subtyping on records and we need subtyping on objects for Java; <em>but</em>, as we know from the <strong>FbOB</strong> encoding, objects and records are very similar
	<li><code>this</code> imposes some additional issues in object typing.  Notice that
	          <pre>PointType = { x : Int; y : Int; magnitude: PointType -> Int -> Int; ...}</pre>
	    should be a proper type for our point object encoding, but notice how <code>PointType</code> is contravariant, it is in the domain of the magnitude method.  Consider
	    <pre>ColorPointType = { x : Int; y : Int; c : Color; magnitude: ColorPointType -> Int -> Int; ...}</pre>
 -- for <code>ColorPointType &lt;: PointType</code> to hold, <code>magnitude</code> subtyping would require 
            <code>ColorPointType -> Int -> Int &lt;: PointType -> Int -> Int</code> which would need <code>PointType &lt;: ColorPointType</code> by function subtyping, which is <strong>false!</strong>
        <li> Its false for a good reason:
          <pre>Let p1 : Point = aPoint In let p2 : Point = aColorPoint In p2.magnitude p1 {}</pre>
          would result in an attempt to look up p1's color, a runtime error.  Note we are abusing our encoding here by passing <tt>p1</tt> to <tt>p2</tt>, that is why the encoding in fact works.
	<li>Solution: pre-package the <code>self</code> into objects when created so self need not be passed in at each message send and it won't show up in object types.
	  <pre>
Let point = .. point object as in book... In
  Let prePackagedPoint = {
    x = point.x ;
    y = point.y ;
    magnitude = point.magnitude point; 
    isZero = point.isZero point; 
  };
In prePackagedPoint.magnitude () (* no self passing needed on object use (and its gone from the type) *) </pre>
	  -- with this encoding the subtyping above holds since the object type arguments have been removed
	</ul>
</ul>

<h3>Classes and inheritance</h3>
<p>
  It is not hard to make encodings of various other features of Java objects - there is nothing deep there.
<ul>
  <li>Information hiding is possible in Java via <code>private/protected</code> fields; information hiding in <strong>STFbOB</strong> is accomplished by subsumption -- use subsumption after every <code>new</code> of an object to hide the private/protected bits.  Informal idea:
    <pre>
      |-  ob : PointWithEverythingPublic     PointWithEverythingPublic <: PointHidingFields
      --------------------------------------------------------------------------------------
      |- ob : PointHidingFields </pre>
  <li>Static fields are easily encoded, think of the class as itself being an object.
  <li>Java classes can have multiple constructors, this is possible in an encoding by making other constructors besides <code>new</code> in the class-object of the previous point.
</ul>

</ul>

An example of encoding static fields and multiple constructors in <strong>FbSR</strong> taken from the book:
<pre>
(* Make a "class object" - an object with some factory methods for building points *)
Let pointClass = {
  (* constructor method on the "class object": *)
  newWithXY = Function thisClass -> 
    Function newx -> 
    Function newy -> {
    x = Ref newx;
    y = Ref newy;
    magnitude = Function this -> Function _ ->
      sqrt ((!(this.x)) + (!(this.y)))
  };
  new = Function thisClass -> Function _ -> 
    (thisClass.newWithXY) thisClass (thisClass.xdefault) 
                            (thisClass.ydefault);
  xdefault = 0;
  ydefault = 0
} In
  Let point = (pointClass.new) pointClass {} In
    (point.magnitude) point {}    </pre>

<h3>Java's Nominal Subtyping</h3>
<ul>
  <li>Subtype relationships in Java are <em>nominal</em>: they must be declared via <tt>extends</tt>/<tt>implements</tt> aclass/aninterface, except for primitive type subtyping;<br>
-- even if a class clearly implements all the methods of an interface, if the interface is not specified in the header there is no subtyping possible.
  <li>Running example: <code>Interface Iterable&lt;T&gt;</code> - if you have an <code>Iterable&lt;Integer&gt; thing</code> you can <code>thing.foreach(...)</code> it <b>but only if</b> <tt>thing</tt> is a class implementing that interface.
  <li>In <strong>STFb</strong> subtyping only
      depended on the structure of the underlying records.
      <strong>STFb</strong> subtyping is thus <em>purely
      structural</em> and Java's is not.
      <ul>
	<li>Any nominal subtyping system only adds <em>additional</em> constraints over pure structural subtyping; you need structural subtyping to hold or the system will be unsound.
	<li>Structural subtyping is more flexible: "use your own implicit interface without needing to declare it". 
	<li>Nominal subtyping lets you think about subtyping in terms of names of things, not the details of whats inside<br>
-- a helpful abstraction of detail in many cases.
      </ul>
</ul>

<h3><a
 href="http://docs.oracle.com/javase/specs/jls/se10/html/jls-4.html#jls-4.4">Generics</a>
 </h3>
 <p>
Generics are Java's version of parametric types.  These notes assume
      familiarity with them; here is a <a
      href="http://download.oracle.com/javase/tutorial/extra/generics/index.html">tutorial</a>.

<p>
The <strong>PEFb</strong> language includes both type inference and polymorphism so it is the only language we studied with polymorphism.  The main idea of how generic types are handled are expressed there, but in an inference context.<p>

 Here are some
      comparisons with the <strong>PEFb</strong> or Caml-style parametric types that we  studied:
<ul>
  <li>Caml/<strong>PEFb</strong> <em>infers</em> generic types <code>'a</code> automatically; in Java, you must
    <em>declare</em> them as <code>&lt;T&gt;</code>.
  <li>Caml variables of type <code>'a</code> you can <em>never</em> under the hood to see what structure is there; in Java you can typecast a <code>&lt;T&gt;</code> to learn about the structure.
  <li>Java generics also have <em>bounded subtyping</em>, a feature not found in Caml due to the combination of polymorphism and subtyping.
</ul>
<h4>Bounded subtyping</h4>
    <p>
      Observe that with generics you cannot  have <code>List&lt;String>
      &lt;: List&lt;Object></code> kinds of things even though <code>String &lt;:Object</code> holds - !

<ul>
  <li>The root of this  in subtpying theory is that
      <code>String/Object</code> may occur both positively and
      negatively  in <code>List</code>'s signature, so it needs to be
      invariant.  
  <li>In <strong>STFb</strong> the problem comes up in how subtyping
      is defined contravariantly on function types.   A  list type
      would at least include <code>add</code> and <code>head</code> so
      the subtyping needed for the above would be at least
 <pre>{ add: String -> {}; head : {} -> String } &lt;: { add: Object -> {}; head : {} -> Object }      </pre>
and this relation fails because it also requires <code>Object &lt;:
      String</code> due to the <code>add</code> parameter argument contravariance.  
  <li>In <strong>STFb</strong> we could in fact have such subtypings
      holding for the case they were positive  only -- imagine some
      list which you could only get the head of, nothing else:
      <pre>{ head : {} -> String } &lt;: { head : {} -> Object }      </pre>
      would be a legal subtyping in our <strong>STFb</strong> rules
      assuming <code>String &lt;: Object</code>. 
  <li>Java is
      conservatively assuming that <code>List<T></code> will have
      <code>T</code> both as argument and return type of methods  and
      so always forces invariance here.  But, for the case the list class was immutable and T was never an argument the above subtyping would hold and our <strong>STFb</strong> approach would support that.
</ul>      

To get around this weakness, Java includes <em>bounded subtyping</em>
  <ul>
    <li>You can also write things like <code>&lt;T extends Comparable&lt;T&gt;&gt; void test(List&lt;T&gt; t) </code>
  <li>the "<code>T extends Comparable&lt;T&gt;&gt;</code>" means <code>T</code> can be
    any type which extends <code>Comparable&lt;T&gt;&gt;</code> -- in other words, <code>T &lt;: Comparable&lt;T&gt;&gt;</code> in our subtyping terminology.
    <br> -- And, in English this means <code>T</code> can be compared with itself.
  <li>This adds more flexibility, <code>T</code> need not be any type,
  but from a restricted range of types which gives added flexibility later.
  <li>In terms of type theory this is the theory of <em>bounded polymorphism</em>: there are subtype bounds on the parametric types.  Its a <em>very</em> natural combination of polymorphism and subtyping.
  <li>Java also allows type variable wildcards, <code>?</code> - this is
      a form of <em>existential type</em> -- the typing  holds  for
  <em>some</em> <code>?</code>.
</ul>


<h3><a href="http://docs.oracle.com/javase/specs/jls/se10/html/jls-8.html#jls-8.4.9">Method Overloading</a></h3>
Java's notion of method overloading (also called ad hoc polymorphism) is simply described
<ul>
  <li> Java method overloading can be
  viewed as concatenating all of the argument types onto the method
  name. 
  <li>So it is really just a form of syntactic sugar. 
</ul>

<h3>Immutable Data</h3>
One  of the key lessons of Caml is the importance of immutable data: its not changing underneath your feet.<p>
<ul>
  <li>Java allows fields to not mutate if qualified with <code>final</code>.
  <li>Caml analogy: a <code>let</code>-defined variable.
  <li>Like Caml, immutability is only shallow - the field could
      contain <em>components</em> that mutate.
  <li>Unlike Caml the default case is swapped and this has a huge impact on expected programmer behavior and can confuse Java programmers when their final thing starts mutating on them.
  <li>One advantage of Java is no need for "<code>!</code>" when accessing mutable data.
</ul>

<h3>Lambdas</h3>

Java 8 has Lambdas
 <ul>
   <li>Fully higher order functions in Java, 50 years after they appeared in PLs.
   <li><a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">Here is a tutorial</a></li>
   <li>Javas Lambdas are admittedly a bit clunky to use compared to "real" higher-order functions due to how they were patched in.</li>
   <li>Java 8 higher-order functions can "pun" as any interface with only one method in it.<br>
-- the function is taken to be the body of that single method, no need to write the method name when declaring the function then.
   <li>There is also some (limited) type inference for Lambda parameters.
   <li>Lets put some spice in our latte!  Here at long last is Currying in Java: <a href="https://gist.github.com/timyates/7674005">Gist currying example</a> that we will go through.  For that example here is the <a href="https://docs.oracle.com/javase/10/docs/api/java/util/function/Function.html">Function</a> and <a href="big-bang-doc/papers/sas-17/">BiFunction</a> type.
       </ul>
 Terminology aside: <em>closure</em>
 <ul>
   <li>A <em>closure</em> is just a higher-order
 function return value
   <li>The term "closure" comes from how they are
 implemented -- all variables not local to the function must be remembered
   <li>(We didn't have this problem in our interpreters because we
 substituted when we did function application, but that is not very efficient)
   <li>Caml example:
       <pre>
       let x = 5 in
         let f y = x + y in (* f is at runtime a closure: a pair (f's-code, {x |-> 5}) *)
           let x = 22 in
             f 2 (* prints 7 because x was 5 in f's closure *)
       </pre>
   <li>Caml example writing out the let:
       <pre># let f = (fun x -> fun y -> x + y) 4;;
val f : int -> int = &lt;fun&gt;
# f 3;;
- : int = 7
       </pre>
       -- note how <code>x</code> is a function parameter and is remembered in spite of function returning, means <code>x</code> needs to be <em>copied</em> into the closure.
   <li>Closures are more difficult to deal with in C++11's lambdas due to its lower-level memory model - see <a href="cppstudy.shtml#lambdas">the C++ notes</a>.
   <li>The PL book Section 8.1 describes <em>closure conversion</em>, a method to "implement" closures in <strong>FbSR</strong> itself by modifying functions to explicitly record the information.
 </ul>

 
 <h3>Type Inference</h3>

<p>
<ul>
  <li>Java follows the "declaring types is good for code reading" philosophy - types generally need to be declared.</li>
  <li>But, in some cases it can get burdensome to declare types as there are too many of them</li>
  <li>So, Java 10 has <em>local type inference</em>, a feature it is taking from Scala (and now Kotlin and C++): <pre>var first = "Hello"</pre> is legal and will infer <tt>first</tt> to be of type <tt>string</tt>.</li>
</ul>


</p>
  
<h3>Concurrency</h3>
<p> Java has standard thread-based shared memory concurrency like C/C++/etc -- low-level locks must be used, prone to bugs.

<h3>Other points of comparison between Java and Caml / Fb</h3>
<ul>
  <li>Java variant types analogue? <br>
-- enums give no-argument version; "use subtyping and dynamic dispatch instead" (i.e. use the records side of the records/variants duality)
  <li>Java Exceptions -- very similar to Caml or <strong>TFbX</strong> but Caml has no <code>throws</code> declarations in the types: less apparent what is being thrown.
</ul>

<h3>Dimensions of Java we did not get very close to
</h3><ul>
  <li>The implementation side: the JVM, JNI, etc
  <li>Reflection
  <li>Dynamic class loading
  <li>Java packages
  <li>run-time type tags and <code>instanceof</code>
</ul>

<h3>The Java spin-offs: Scala, Kotlin, and Clojure</h3>
<ul>
  <li>All three compile to Java bytecode so can share libraries with Java</li>
  <li>Means much less work to get a language up and running</li>
  <li>Each are popular in certain spaces
    </ul>
<h4>Scala</h4>
<ul>
  <li>Scala "brings OCaml to Java" - functional programming style into O-O; it also led this trend which Java/C++ followed.</li>
  <li>It was a big deal before Java 8 but Java has been back-patching to be more Scala-like </li>
  <li>Local type inference is the latest such back-patch in Java 10</li>
  <li>Scala shares the immutabilty by default aspect of OCaml
    <br> -- you can declare things final in Java for immutability, but its not the default.</li>
  <li>Scala has an actor-based concurrency model built-in.</li>
  <li>Scala also has pattern matching built in -- <a href="https://www.tutorialspoint.com/scala/scala_pattern_matching.htm">tutorial link</a>.</li>
    </ul>
<p>
  -- in some sense Scala is the closest language to "<strong>ASTFbOBVX</strong>" -- all the <strong>Fb</strong> extensions bundled together.


<h4>Kotlin</h4>
<ul>
  <li>Kotlin is in a nutshell a cleaned-up version of Java; Java has gotten more and more crufty as it has evolved</li>
  <li>It includes higher-order functions, local type inference PLUS operator overloading a la C++, etc.</li>
  <li>One interesting novel tidbit, delegation is implicitly supported: <a href="https://kotlinlang.org/docs/reference/delegation.html">Kotlin docs of delegation</a>.
</ul>

<h4>Clojure</h4>
<ul>
  <li>Lisp is the "first implemented functional programming language", circa 1964.</li>
  <li>Lisp is dynamically typed, it was also the first dynamically-typed language preceding Python, Ruby, Perl, JavaScript, Scheme, etc.
  <li>Clojure is "modern Lisp running on the JVM"</li>
    </ul>
</section>
</div>
</div>


<!--#include virtual="/pl/footer.html" -->	 



