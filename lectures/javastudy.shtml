<!--#include virtual="/pl/header.html" -->	 
</div>

<!-- Main -->
<div id="main" class="wrapper style4">

<!-- Content -->
<div id="content" class="container">
<section>
<header class="major">
<h2>Principles Behind Java</h2>
</header>


Thesis: we covered the core ideas, we can now <em>encode</em> Java in <strong>PSTFbOB</strong>!
<ul>
  <li>The book contains three languages which put together can encode the core features of Java: <strong>FbOB</strong> (objects), <strong>STFb</strong> (subtyping), and <strong>PEFb</strong> (the P for polymorphism/generics, and the E for type inference). 
  <li>An Fb family language corresponding to core Java could be "<strong>PSTFbOB</strong>"
	</ul>

<h3>Encoding Typed Objects</h3>
We encoded objects with records, but the encoding we gave does not lift perfectly to typed objects.
<ul>
  <li><code>this</code> imposes some additional issues in object typing.  Notice that
	          <pre>PointType = { x : Int; y : Int; magnitude: PointType -> Int -> Int; ...}</pre>
	    should be a proper type for our point object encoding, but notice how <code>PointType</code> is contravariant, it is in the domain of the magnitude method.  Consider
	    <pre>ColorPointType = { x : Int; y : Int; c : Color; magnitude: ColorPointType -> Int -> Int; ...}</pre>
 -- for <code>ColorPointType &lt;: PointType</code> to hold, <code>magnitude</code> subtyping would require 
            <code>ColorPointType -> Int -> Int &lt;: PointType -> Int -> Int</code> which would need <code>PointType &lt;: ColorPointType</code> by function subtyping, which is <strong>false!</strong>
        <li> Its false for a good reason:
          <pre>Let p1 : Point = aPoint In let p2 : Point = aColorPoint In p2.magnitude p1 {}</pre>
          would result in an attempt to look up p1's color, a runtime error.  Note we are abusing our encoding here by passing <tt>p1</tt> to <tt>p2</tt>, that is why the encoding in fact works.
	<li>Solution: pre-package the <code>self</code> into objects when created so self need not be passed in at each message send and it won't show up in object types.
	  <pre>
Let point = .. point object as in book... In
  Let prePackagedPoint = {
    x = point.x ;
    y = point.y ;
    magnitude = point.magnitude point; 
    isZero = point.isZero point; 
  };
In prePackagedPoint.magnitude () (* no self passing needed on object use (and its gone from the type) *) </pre>
	  -- with this encoding the subtyping above holds since the object type arguments have been removed
	  <li>One more thing needed in the above that we skipped: notice how the <tt>PointType</tt> is self-referential, it refers to itself in its definition.  Such types are called <em>recursive types</em>.  Fortunately, we can make type systems with recursive types (but will skip that here).
</ul>

<h3>Encoding Other Java O-O Features</h3>

<ul>
  <li>Information hiding is possible in Java via <code>private/protected</code> fields; information hiding in <strong>STFbOB</strong> is accomplished by subsumption -- use subsumption after every <code>new</code> of an object to hide the private/protected bits.  Informal idea:
    <pre>
      |-  ob : PointWithEverythingPublic     PointWithEverythingPublic <: PointHidingFields
      --------------------------------------------------------------------------------------
      |- ob : PointHidingFields </pre>
  <li>Static fields are easily encoded, think of the class as itself being an object.
  <li>Java classes can have multiple constructors, this is possible in an encoding by making other constructors besides <code>new</code> in the class-object of the previous point.
</ul>

</ul>

An example of encoding static fields and multiple constructors in <strong>FbSR</strong> taken from the book:
<pre>
(* Make a "class object" - an object with some factory methods for building points *)
Let pointClass = {
  (* constructor method on the "class object": *)
  newWithXY = Function thisClass -> 
    Function newx -> 
    Function newy -> {
    x = Ref newx;
    y = Ref newy;
    magnitude = Function this -> Function _ ->
      sqrt ((!(this.x)) + (!(this.y)))
  };
  new = Function thisClass -> Function _ -> 
    (thisClass.newWithXY) thisClass (thisClass.xdefault) 
                            (thisClass.ydefault);
  xdefault = 0;
  ydefault = 0
} In
  Let point = (pointClass.new) pointClass {} In
    (point.magnitude) point {}    </pre>

<h3>Java's Nominal Subtyping</h3>
<ul>
  <li>Subtype relationships in Java are <em>nominal</em>: they must be declared via <tt>extends</tt>/<tt>implements</tt> aclass/aninterface, except for primitive type subtyping;<br>
-- even if a class clearly implements all the methods of an interface, if the interface is not specified in the header there is no subtyping possible.
  <li>Running example: <code>Interface Iterable&lt;T&gt;</code> - if you have an <code>Iterable&lt;Integer&gt; thing</code> you can <code>thing.foreach(...)</code> it <b>but only if</b> <tt>thing</tt> is a class explicitly <tt>implements</tt>-ing that interface.
  <li>In <strong>STFb</strong> subtyping only
      depended on the structure of the underlying records.
      <strong>STFb</strong> subtyping is thus <em>purely
      structural</em> and Java's is not.
      <ul>
	<li>Any nominal subtyping system only adds <em>additional</em> constraints over pure structural subtyping; you need structural subtyping to hold or the system will be unsound.
	<li>Structural subtyping is more flexible: "use your own implicit interface without needing to declare it". 
	<li>Nominal subtyping lets you think about subtyping in terms of names of things, not the details of whats inside<br>
-- a helpful abstraction of detail in many cases.
	  <li>Pretty much all major languages used nominal subtyping until TypeScript decided to take the structural approach.  Good for them!
      </ul>
</ul>

<h3><a
 href="http://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.4">Generics</a>
 </h3>
 <p>
Generics are Java's version of parametric types.  These notes assume
      familiarity with them; here is a <a
      href="http://download.oracle.com/javase/tutorial/extra/generics/index.html">tutorial</a>.

<p>
The <strong>PEFb</strong> language includes both type inference and polymorphism so it is the only language we studied with polymorphism.  The main idea of how generic types are handled are expressed there, but in an inference context.<p>

 Here are some
      comparisons with the <strong>PEFb</strong> or Caml-style parametric types that we  studied:
<ul>
  <li><tt>'a list / int list</tt> from OCaml is <tt>List &lt;T> / List &lt;Integer></tt> in Java
  <li>Caml/<strong>PEFb</strong> often <em>infers</em> generic types <code>'a</code> automatically; in Java, you need to declare them as <code>&lt;T&gt;</code>.  But you can often just write <code>&lt;&gt;</code> to instantiate a generic type: the type will be inferred.
  <li>Java generics have <em>bounded subtyping</em>, the combination of polymorphism and subtyping (note, this doesn't exist in OCaml and we didn't cover the principles in class).
</ul>
<h4>Bounded subtyping</h4>
    <p>
      Observe that with generics you cannot  have <code>List&lt;String>
      &lt;: List&lt;Object></code> kinds of things even though <code>String &lt;:Object</code> holds - !

<ul>
  <li>The root of this  in subtpying theory is that
      <code>String/Object</code> may occur both positively (rhs of function arrow) and
      negatively  (lhs of arrow) in <code>List</code>'s signature, so it needs to be
      invariant.  
  <li>Consider a list-like object encoded as a <strong>STFbR</strong> record:
 <pre>{ add: String -> {}; head : {} -> String } &lt;: { add: Object -> {}; head : {} -> Object }      </pre>
-- this relation <em>fails</em> in <strong>STFbR</strong> because it requires <code>Object &lt;:
      String</code> due to the <code>add</code> parameter argument contravariance.  
  <li>In <strong>STFb</strong> we could in fact have such subtypings
      holding for the case they were positive  only -- imagine some
      list which you could only get the head of, nothing else:
      <pre>{ head : {} -> String } &lt;: { head : {} -> Object }      </pre>
      would be a legal subtyping in <strong>STFb</strong>
      assuming <code>String &lt;: Object</code>. 
  <li>Java is
      conservatively assuming that <code>List<T></code> will have
      <code>T</code> both as argument and return type of methods  and
      so always forces invariance here.  But, for the case the list class was immutable and T was never an argument the above subtyping would hold and our <strong>STFb</strong> approach would support that.
</ul>      

To get around this weakness, Java includes <em>bounded subtyping</em>
  <ul>
    <li>You can write things like <code>&lt;T extends Comparable&lt;T&gt;&gt; void test(List&lt;T&gt; t) </code>
  <li>the "<code>&lt;T extends Comparable&lt;T&gt;&gt;</code>" means <code>T</code> can be
    any type which extends <code>Comparable&lt;T&gt;&gt;</code> -- in other words, <code>T &lt;: Comparable&lt;T&gt;</code> in our subtyping terminology.
    <br> -- And, in English this means <code>T</code> can be compared with itself.
  <li>This adds more flexibility, <code>T</code> need not be any type,
  but from a restricted range of types which gives added flexibility later.
  <li>In terms of type theory this is the theory of <em>bounded polymorphism</em>: there are subtype bounds on the parametric types.  Its a <em>very</em> natural combination of polymorphism and subtyping.
</ul>


<h3><a href="http://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.9">Method Overloading</a></h3>
<ul>
  <li> Java method overloading can be
  viewed as concatenating all of the argument types onto the method
  name. 
    <li>This makes "a new method for each different type"
  <li>So it is just simple syntactic sugar. 
</ul>

<h3>Immutable Data</h3>
One of the key lessons of Caml is the importance of immutable data.<p>
<ul>
  <li>Java allows fields to not mutate if qualified with <code>final</code>; so, it is something like  <code>let</code> in OCaml.
  <li>As with OCaml, immutability is only shallow - the field could
      contain <em>components</em> that mutate.
  <li>Unlike Caml the default case is swapped and this has a huge impact on expected programmer behavior.
  <li>One advantage of Java is no need for "<code>!</code>" when accessing mutable data.
</ul>

<h3>Lambdas</h3>

Java 8+ has Lambdas, use them!  We are probably going to skip this topic, the only real novelty is the (gross) syntax.
 <ul>
   <li>Fully higher order functions in Java, 50 years after they appeared in PLs.
   <li><a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">Here is a tutorial</a></li>
   <li>Javas Lambdas are admittedly a bit clunky to use compared to "real" higher-order functions due to how they were patched in.</li>
   <li>Java 8 higher-order functions can "pun" as any interface with only one method in it.<br>
-- the function is taken to be the body of that single method, no need to write the method name when declaring the function then.
   <li>There is also some (limited) type inference for Lambda parameters.
   <li>Lets put some spice in our latte!  Here at long last is Currying in Java: <a href="https://gist.github.com/timyates/7674005">Gist currying example</a>.  For that example here is the <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/function/Function.html">Function</a> and <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/function/BiFunction.html">BiFunction</a> type.
       </ul>
 Terminology aside: <em>closure</em>
 <ul>
   <li>A <em>closure</em> is just a higher-order
 function return value
   <li>The term "closure" comes from how they are
 implemented -- all variables not local to the function must be remembered
   <li>(We didn't have this problem in our interpreters because we
 <em>substituted</em> when we did function application, but that is not very efficient)
   <li>OCaml example:
       <pre># let f = (fun x -> fun y -> x + y) 4;;
val f : int -> int = &lt;fun&gt; (* f is at runtime the closure &lt;fun y code, {x |-> 3)&gt; *)
# f 3;;
- : int = 7   </pre>
Note how <code>x</code> is a function parameter and is remembered in spite of function returning, means <code>x</code> needs to be <em>copied</em> into the closure.
 </ul>

 
 <h3>Type Inference</h3>

<p>
<ul>
  <li>For years Java followed the "declaring types is good for code reading" philosophy - types were all declared.</li>
  <li>But, "type inference is coming to a language near you" caught on a few years ago, a trend initiated by Scala.</li>
  <li>So, Java 10+ has <em>local type inference</em>, along with Scala, Kotlin, C++, etc:
    <pre>var first = "Hello"</pre> is legal and will infer <tt>first</tt> to be of type <tt>string</tt>.</li>
</ul>


</p>
  
<h3>Other points of comparison between Java and Caml / Fb</h3>
<ul>
  <li>Java has no variant types?!? --  "Use subtyping and dynamic dispatch instead" (i.e. use the records side of the records/variants duality)
  <li>Java Exceptions -- very similar to Caml or <strong>TFbX</strong> but Caml has no <code>throws</code> declarations in the types: less apparent what is being thrown in OCaml, arguably inferior.
</ul>

<h3>The Java spin-offs: Scala, Kotlin, and Clojure</h3>
<ul>
  <li>All three compile to Java bytecode so can share libraries with Java</li>
  <li>Means much less work to get a language up and running</li>
  <li>Each are popular in certain spaces
    </ul>
<h4>Scala</h4>
<ul>
  <li>Scala "brings OCaml to Java" - functional programming style into O-O; it also led this trend which Java/C++ followed.</li>
  <li>It was a big deal before Java 8 but Java has been back-patching to be more Scala-like </li>
  <li>Local type inference is the latest such back-patch in Java 14</li>
  <li>Scala shares the immutabilty by default aspect of OCaml
    <br> -- you can declare things final in Java for immutability, but its not the default.</li>
  <li>Scala has an actor-based concurrency model built-in.</li>
  <li>Scala also has pattern matching built in -- <a href="https://www.tutorialspoint.com/scala/scala_pattern_matching.htm">tutorial link</a>.</li>
    </ul>

<h4>Kotlin</h4>
<ul>
  <li>Kotlin is in a nutshell a cleaned-up version of Java; Java has gotten more and more crufty as it has evolved</li>
  <li>It includes higher-order functions, local type inference PLUS operator overloading a la C++, etc.</li>
  <li>One interesting novel tidbit, delegation (message forwarding) is directly supported in the syntax: <a href="https://kotlinlang.org/docs/reference/delegation.html">Kotlin docs of delegation</a>.
</ul>

<h4>Clojure</h4>
<ul>
  <li>Lisp is the "first implemented functional programming language", circa 1964.</li>
  <li>Lisp is dynamically typed, it was also the first dynamically-typed language preceding Python, Ruby, Perl, JavaScript, Scheme, etc.
  <li>Clojure is "modern Lisp running on the JVM"</li>
    </ul>
</section>
</div>
</div>


<!--#include virtual="/pl/footer.html" -->	 



