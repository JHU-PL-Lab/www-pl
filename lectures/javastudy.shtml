<!--#include virtual="/pl/header.html" -->

</div>

<div id="content"> <h2>Study of Java</h2>
Our reference here  is  the <a
href="http://java.sun.com/docs/books/jls/third_edition/html/j3TOC.html">Java
Language Specification, 3rd Edition</a>.  Part of the goal of this
lecture is for  you  to gain expertise in "spec reading". Some of the examples below
are  taken from the Java spec.<p>
<ul>
  <li>In lecture we covered three languages which reflect the key principles of Java: <strong>FbOB</strong>, <strong>STFb</strong>, and <strong>PEFb</strong>. 
  <li> The former had objects but was untyped, the next added subtyping and the last added polymorphism.
  <li>The language corresponding to Java is "<strong>PSTFbOB</strong>", basically putting polymorphic types and subtypes on to <strong>FbOB</strong>.  
  <li>We did not explcitly study that combination because there is not a lot of new stuff there -- subtyping on objects is like subtyping on records.

</ul>

<h3>Classes and Inheritance</h3>
We either have or can easily encode in <strong>STFbOB</strong> nearly all of the features of basic Java class declarations and inheritance.
<ul>
  <li>Information hiding is possible in Java via private/protected fields; information hiding in <strong>FbOB</strong> is discussed in the book but we did not cover it (basically make a separate "public view" record).
  <li>Static fields can be encoded and were covered briefly in class and in the book.
  <li>Java classes can have multiple constructors, we did not cover that case (but it is possible by encoding constructors as static methods in our static method encoding)
</ul>

<h4>Java Public/Private/package protected/Protected and Caml Modules</h4>

<ul>
  <li>Caml allows arbitrary multiple views of the same module
      (different things seen by different code given the same module)
  <li>Java has 
      fixed forms of multiple view: subclasses may see more
      (protected) and within vs without a package may see more
      (package protected)
  <li>Caml is more flexible, but Java approach is simpler (on the
      surface at least).
</ul>

<h4><a href="http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.8.7">Constructors</a></h4>
<ul>
  <li>Java constructors are not that different  from the encoding of
  constructors that we covered in the book - various convenient sugar is added.
  <li>Java by default inserts <code>super();</code> in front of the
  constructor if  another constructor is not invoked at  the  start; this  is a bit of a
  hack. 
  <li>There is a default constructor w/ body <code>super();</code> if none is declared.
  <li>Inner classs and generics add a whole load of complications to constructors.
</ul>

<h3><a href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.10">Subtyping</a></h3>
<ul>
  <li>Subtype relationships must be declared via extends/implements, except for primitive type subtyping; even though a class clearly implements all the methods of an interface if that is not specified in the header there is no subtyping possible.
  <li>In <strong>STFb</strong> subtyping only
      depended on the structure of the underlying records.
      <strong>STFb</strong> subtyping is thus <em>purely
      structural</em> and Java's is not.
  <li>Used to be there  was no "deep" subtyping on objects, but now
      you can also refine the type in a subclass - <a href="http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.4.8.3">see here</a>.<br>
 - former is our record subtyping rule where type components must  be
      SAME; now they support some aspects of our rule.
  <li>Summary: <strong>STFb</strong> is more expressive but Java's is
      easier to use due to names being given.
</ul>
<h3><a href="http://java.sun.com/docs/books/jls/third_edition/html/classes.html#295574">Inner Classes</a></h3>
Lets start with reviewing what <strong>FbOB</strong> had in this area:
<ul>
  
  <li>In <strong>FbOB</strong> we had the ability to declare classes
      anywhere, including inside  other  class methods, etc.  Those
      classes could  also be returned as result values of methods, to  
      be <code>new</code>-ed in a completely different context.
  <li><strong>FbOB</strong> also has  syntax for directly defining
      objects: <code>Object Inst ... Meth ..</code>.
  <li>In general, this is an example of <em>fully higher-order</em>
      classes and objects -- no restrictions on where they can be
      defined, used or passed to.
</ul>
Java inner classes give some but not all of the above <strong>FbOB</strong> functionality.
<ul>
  <li>They do allow local classes to be defined just about anywhere.
  <li>They do support something similar to the <code>Object</code>
      syntax of  <strong>FbOB</strong>, via anonymous local classes
      which are  immediately  <code>new</code>-ed. 
  <li>They do support multiple levels of nesting: inner classes  can
      have inner classes inside  them.
  <li>At runtime, each inner class instance holds a pointer to the
      instance of the class nesting it that created it; it can access
      fields of that class via that reference (see spec linked above
      for examples).
  <li>The main lack is the ability for classes to be passed around as
      data items, e.g. methods  returning classes.
  <li>The JVM is  not "aware" of inner classes, they are implemented
      as regular classes with mangled names like <code>Foo$1Boo</code> for
      an inner class <code>Boo</code> inside  <code>Boo</code>.
 </ul>

Inner classes / <strong>FbOB</strong> object declarations vs the
 higher-order functions of Caml etc:
 <ul>
   <li><strong>FbOB</strong> objects with just one method called
 e.g. <code>theFunction</code> are a full and faithful encoding of higher-order functions.
   <li>Smalltalk takes the view of rather than having first-class
 objects just add higher-order functions directly; they are called
 <em>blocks</em> in Smalltalk.
   <li><a href="http://openjdk.java.net/projects/lambda/">Project
      Lambda</a> is a proposal to add full higher-order 
      functions to JDK 8, and that addition is looking likely at this point.
 </ul>
 Terminology aside: <em>closure</em>
 <ul>
   <li>A <em>closure</em> is just a higher-order
 function return value
   <li>The term "closure" comes from how they are
 implemented -- all variables not local to the function must be remembered
   <li>(We didn't have this problem in our interpreters because we
 substituted when we did function application, but that is not very efficient)
   <li>Caml example:
       <pre>
       let x = 5 in
         let f y = x + y in (* f is at runtime a closure: a pair (f's-code, {x |-> 5}) *)
           let x = 22 in
             f 2 (* prints 7 because x was 5 in f's closure *)
       </pre>
 </ul>

<h3><a
 href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#108850">Generics</a>
 </h3>
(other links: <a
 href="http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.1.2">their
 use in
 classes</a>; <a
 href="http://www.oracle.com/technetwork/articles/javase/generics-136597.html">an
 overview</a>)
 <p>
Generics are Java's version of parametric types.  These notes assume
      familiarity with them; read a <a
      href="http://download.oracle.com/javase/tutorial/extra/generics/index.html">tutorial</a>
      if you are not.

<p>
The <strong>PEFb</strong> language includes both type inference and polymorphism so it is the only language we studied with polymorphism.  The main idea of how generic types are handled are expressed there, but in an inference context.<p>

 Here are some
      comparisons with the <strong>PEFb</strong> or Caml-style parametric types that we  studied:
<ul>
  <li>Caml infers generic types <code>'a</code> automatically; in Java, you must
      declare them as <code>&lt;T&gt;</code>.
  <li>Java generics have some features not found in Caml due to the
      combination of polymorphism and subtyping.
</ul>
<h4>Bounded subtyping</h4>
<ul>
  <li>Recall with generics you cannot  have <code>List&lt;String>
      &lt;: List&lt;Object></code> kinds of things (see <a
      href="http://download.oracle.com/javase/tutorial/extra/generics/subtype.html">here</a>
      for description) even though <code>String &lt;:Object</code> holds.
  <li>The root of this  in subtpying theory is that
      <code>String/Object</code> may occur both positively and
      negatively  in <code>List</code>'s signature, so it needs to be
      invariant.  
  <li>In <strong>STFb</strong> the problem comes up in how subtyping
      is defined contravariantly on function types.   A  list type
      would at least include <code>add</code> and <code>head</code> so
      the subtyping needed for the above would be at least
 <pre>{ add: String -> {}; head : {} -> String } &lt;: { add: Object -> {}; head : {} -> Object }      </pre>
and this relation fails because it also requires <code>Object &lt;:
      String</code> due to the <code>add</code> parameter argument contravariance.  
  <li>In <strong>STFb</strong> we could in fact have such subtypings
      holding for the case they were positive  only -- imagine some
      list which you could only get the head of, nothing else:
      <pre>{ head : {} -> String } &lt;: { head : {} -> Object }      </pre>
      would be a legal subtyping in our <strong>STFb</strong> rules
      assuming <code>String &lt;: Object</code>. 
  <li>Java is
      basically assuming that <code>List<T></code> will have
      <code>T</code> both as argument and return type of methods  and
      so always forces invariance here.  But, for the case the list class was immutable and T was never an argument the above subtyping would hold and our <strong>STFb</strong> approach would support that.
</ul>      

To get around this  weakness, Java 5 adds <em>bounded subtyping</em>
  <ul>
    <li>In generics  you can write things like <code>&lt;T extends C &amp; I&gt; void test(T t) </code>
  <li>the "<code>extends C &amp; I</code>" means <code>T</code> can be
      any type which extends both class <code>C</code> and interface
      <code>I</code>.  
  <li>In other words, <code>T &lt;: C</code> and  <code>T &lt;:
      I</code> in our subtyping terminology.
  <li>This adds more flexibility, <code>T</code> need not be any type,
  but from a restricted range of types which gives added flexibility later.
  <li>The constraint-based
      <strong>CFbR</strong> (which we may not have covered) with let-polymorphism also allows such
      sorts of types to be expressed:
     <pre> test : 'a -> void \ { 'a <: C, 'a <: I }</pre>
  <li>Java also allows type variable wildcards, <code>?</code> - this is
      a form of <em>existential type</em> -- the typing  holds  for
  <em>some</em> <code>?</code>.
</ul>


<h3><a href="http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.4.9">Method Overloading</a></h3>
The take-home message here is brief:
<ul>
  <li> Java method  overloading can be
  viewed as concatenating all of the argument types onto the method
  name. 
  <li>So it is really just a form of syntactic sugar. 
  <li>We will briefly look at the examples in the above  spec.
</ul>

<h3>Immutable Data</h3>
One  of the key lessons  of Caml is  the importance of known immutable
data: it has universal meaning.<p>
<ul>
  <li>Java allows fields to not mutate if qualified with <code>final</code>.
  <li>Caml analogy: a <code>let</code>-defined variable.
  <li>Like Caml, immutability is only shallow - the field could
      contain <em>components</em> that mutate.
  <li>Unlike Caml the default case is swapped and this has a huge impact on expected programmer behavior.
</ul>


<h3>Concurrency</h3>
The book chapter on concurrency reviews the Java concurrency model.

<h3>Other issues of comparison between Java and Caml / Fb family of languages</h3>
<ul>
  <li>Java variant types analogue? <br>
-- used to not exist but now there are enums
      at least; "use subtyping and dynamic dispatch instead"
  <li>Type Inference -- types are declared in Java; avoids all the
      glitches in the OCaml design to support inference but requires
      more programmer typing.
  <li>Java Exceptions -- very similar to how we did them in <strong>TFbX</strong> but no <code>throws</code> declarations in our types.
</ul>

<h3>Some advanced dimensions of Java we did not really study at all
</h3><ul>
  <li>Reflection
  <li>Dynamic class loading
  <li>JNI - interfacing with native code
</ul>


</div>


<!--#include virtual="/pl/footer.html" -->
