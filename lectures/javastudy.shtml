
<!--#include virtual="/pl/header.html" -->

</div>

<div id="content"> <h2>Study of Java</h2>
Our reference here  is  the <a
href="http://docs.oracle.com/javase/specs/jls/se8/html/index.html">Java
Language Specification, SE 8 Edition</a>.<p>
<ul>
  <li>We are not going to write operational semantics for Java but we covered many of the "hard" design ideas behind Java already.
  <li>The book contains three languages which collectively cover the core of Java: <strong>FbOB</strong> (objects), <strong>STFb</strong> (subtyping), and <strong>PEFb</strong> (the P, polymorphism/generics part, not the inference part). 
  <li>An Fb family language corresponding to core Java would be "<strong>PSTFbOB</strong>"
  <li>We did not cover this but most of the aspects would not be surprising to you; a few gaps include
      <ul>
	<li><strong>STFb</strong> had subtyping on records and we need subtyping on objects for Java; <em>but</em>, as we know from the <strong>FbOB</strong> encoding, objects and records are very similar
	<li><code>this</code> imposes some additional issues in object typing.  Notice that
	          <pre>PointType = { x : Int; y : Int; magnitude: PointType -> Int -> Int; ...}</pre>
	    should be a proper type for our point object encoding, but notice how <code>PointType</code> is contravariant, it is in the domain of the magnitude method.  Consider
	    <pre>ColorPointType = { x : Int; y : Int; c : Color; magnitude: ColorPointType -> Int -> Int; ...}</pre>
 -- for <code>ColorPointType &lt;: PointType</code> to hold, <code>magnitude</code> subtyping would require 
      <code>ColorPointType -> Int -> Int &lt;: PointType -> Int -> Int</code> which would need <code>PointType &lt;: ColorPointType</code> by function subtyping, which is <strong>false!</strong>
	<li>Solution: pre-package the <code>self</code> into objects when created so they won't show up in object types.
	<li>This issue is why there is no subtyping on classes in Java: static method dispatch is ... static.</ul>
</ul>

<h3>Classes and inheritance</h3>
We can encode in <strong>STFbOB</strong> nearly all of the features of basic java class declarations and inheritance.
<ul>
  <li>Information hiding is possible in Java via <code>private/protected</code> fields; information hiding in <strong>STFbOB</strong> is accomplished by subsumption -- use subsumption after every <code>new</code> of an object to hide the private/protected bits.
  <li>Static fields are easily encoded, think of the class as itself being an object.
  <li>Java classes can have multiple constructors, this is possible in an encoding by making other constructors besides <code>new</code> in the class-object of the previous point.
  <li>Java has countless subtle features to make programming easier that make the specification very complex however:
<ul>
  <li>Java by default inserts <code>super();</code> in front of the
  constructor if  another constructor is not invoked.
  <li>There is a default constructor w/ body just <code>super();</code> if none is declared.
  <li>etc etc etc
</ul>

</ul>

An example of encoding static fields and multiple constructors in <strong>FbSR</strong> taken from the book:
<pre>
Let pointClass = {

  newWithXY = Function thisClass ->
    Function newx -> 
    Function newy -> {

    x = Ref newx;
    y = Ref newy;
    magnitude = Function this -> Function _ ->
      sqrt ((!(this.x)) + (!(this.y)))
  };

  new = Function thisClass -> Function _ -> 
    (thisClass.newWithXY) thisClass (thisClass.xdefault) 
                            (thisClass.ydefault);

  xdefault = 0;
  ydefault = 0
} In

Let point = (pointClass.new) pointClass {} In
(point.magnitude) point {}

    </pre>
<h4>Information Hiding Contrast: Java public/private/package protected/protected vs Caml module</h4>

<ul>
  <li>Caml allows arbitrary multiple views of the same module
      (different things seen by different code given the same module)
  <li>Java has 
      fixed forms of multiple view: subclasses may see more
      (protected) and within vs without a package may see more
      (package protected)
  <li>Caml is more flexible, but Java is much simpler.
</ul>


<h3>Nominal Subtyping</h3>
<ul>
  <li>Subtype relationships in Java are <em>nominal</em>: they must be declared via extends/implements aclass/aninterface, except for primitive type subtyping;<br>
-- even if a class clearly implements all the methods of an interface, if the interface is not specified in the header there is no subtyping possible.
  <li>In <strong>STFb</strong> subtyping only
      depended on the structure of the underlying records.
      <strong>STFb</strong> subtyping is thus <em>purely
      structural</em> and Java's is not.
      <ul>
	<li>Any nominal subtyping system only adds <em>additional</em> constraints over pure structural subtyping; you need structural subtyping to hold or the system will be unsound.
	<li>Structural subtyping is more flexible: "use your own implicit interface without needing to declare it". 
	<li>Nominal subtyping lets you think about subtyping in terms of names of things, not the details of whats inside<br>
-- a helpful abstraction of detail in many cases.
      </ul>
</ul>

<h3><a
 href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.4">Generics</a>
 </h3>
 <p>
Generics are Java's version of parametric types.  These notes assume
      familiarity with them; here is a <a
      href="http://download.oracle.com/javase/tutorial/extra/generics/index.html">tutorial</a>.

<p>
The <strong>PEFb</strong> language includes both type inference and polymorphism so it is the only language we studied with polymorphism.  The main idea of how generic types are handled are expressed there, but in an inference context.<p>

 Here are some
      comparisons with the <strong>PEFb</strong> or Caml-style parametric types that we  studied:
<ul>
  <li>Caml/<strong>PEFb</strong> infers generic types <code>'a</code> automatically; in Java, you must
      declare them as <code>&lt;T&gt;</code>.
  <li>Caml variables of type <code>'a</code> you can <em>never</em> under the hood to see what structure is there; in Java you can typecast a <code>&lt;T&gt;</code> to learn about the structure.
  <li>Java generics also have <em>bounded subtyping</em>, a feature not found in Caml due to the combination of polymorphism and subtyping.
</ul>
<h4>Bounded subtyping</h4>
<ul>
  <li>Recall with generics you cannot  have <code>List&lt;String>
      &lt;: List&lt;Object></code> kinds of things (see <a
      href="http://download.oracle.com/javase/tutorial/extra/generics/subtype.html">here</a>
      for description) even though <code>String &lt;:Object</code> holds.
  <li>The root of this  in subtpying theory is that
      <code>String/Object</code> may occur both positively and
      negatively  in <code>List</code>'s signature, so it needs to be
      invariant.  
  <li>In <strong>STFb</strong> the problem comes up in how subtyping
      is defined contravariantly on function types.   A  list type
      would at least include <code>add</code> and <code>head</code> so
      the subtyping needed for the above would be at least
 <pre>{ add: String -> {}; head : {} -> String } &lt;: { add: Object -> {}; head : {} -> Object }      </pre>
and this relation fails because it also requires <code>Object &lt;:
      String</code> due to the <code>add</code> parameter argument contravariance.  
  <li>In <strong>STFb</strong> we could in fact have such subtypings
      holding for the case they were positive  only -- imagine some
      list which you could only get the head of, nothing else:
      <pre>{ head : {} -> String } &lt;: { head : {} -> Object }      </pre>
      would be a legal subtyping in our <strong>STFb</strong> rules
      assuming <code>String &lt;: Object</code>. 
  <li>Java is
      conservatively assuming that <code>List<T></code> will have
      <code>T</code> both as argument and return type of methods  and
      so always forces invariance here.  But, for the case the list class was immutable and T was never an argument the above subtyping would hold and our <strong>STFb</strong> approach would support that.
</ul>      

To get around this weakness, Java includes <em>bounded subtyping</em>
  <ul>
    <li>You can also write things like <code>&lt;T extends Comparable&lt;T&gt;&gt; void test(List&lt;T&gt; t) </code>
  <li>the "<code>T extends Comparable&lt;T&gt;&gt;</code>" means <code>T</code> can be
      any type which extends <code>Comparable&lt;T&gt;&gt;</code> -- in other words, <code>T &lt;: Comparable&lt;T&gt;&gt;</code> in our subtyping terminology.
  <li>This adds more flexibility, <code>T</code> need not be any type,
  but from a restricted range of types which gives added flexibility later.
  <li>In terms of type theory this is the theory of <em>bounded polymorphism</em>: there are subtype bounds on the parametric types.  Its a <em>very</em> natural combination of polymorphism and subtyping.
  <li>Java also allows type variable wildcards, <code>?</code> - this is
      a form of <em>existential type</em> -- the typing  holds  for
  <em>some</em> <code>?</code>.
</ul>


<h3><a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.9">Method Overloading</a></h3>
The take-home message here is brief:
<ul>
  <li> Java method overloading can be
  viewed as concatenating all of the argument types onto the method
  name. 
  <li>So it is really just a form of syntactic sugar. 
  <li>We will briefly look at the examples in the above spec.
</ul>

<h3>Immutable Data</h3>
One  of the key lessons of Caml is the importance of immutable data: its not changing underneath your feet.<p>
<ul>
  <li>Java allows fields to not mutate if qualified with <code>final</code>.
  <li>Caml analogy: a <code>let</code>-defined variable.
  <li>Like Caml, immutability is only shallow - the field could
      contain <em>components</em> that mutate.
  <li>Unlike Caml the default case is swapped and this has a huge impact on expected programmer behavior.
  <li>One advantage of Java is lack of need for OCaml's "<code>!</code>" for accessing mutable data - gets real annoying real fast.
</ul>

<h3>Inner Classes and Lambdas</h3>
Lets start with reviewing what <strong>FbOB</strong> had in this area:
<ul>
  
  <li>In <strong>FbOB</strong> we had the ability to declare classes
      anywhere, including inside  other  class methods, etc.  Those
      classes could  also be returned as result values of methods, to  
      be <code>new</code>-ed in a completely different context.
  <li><strong>FbOB</strong> also has  syntax for directly defining
      objects: <code>Object Inst ... Meth ..</code>.
  <li>In general, this is an example of <em>fully higher-order</em>
      classes and objects -- no restrictions on where they can be
      defined, used or passed to.
</ul>
Java inner classes give some but not all of the above <strong>FbOB</strong> functionality.
<ul>
  <li>They do allow local classes to be defined just about anywhere.
  <li>They do support something similar to the <code>Object</code>
      syntax of  <strong>FbOB</strong>, via anonymous local classes
      which are  immediately  <code>new</code>-ed. 
  <li>They do support multiple levels of nesting: inner classes  can
      have inner classes inside  them.
  <li>At runtime, each inner class instance holds a pointer to the
      instance of the class nesting it that created it; it can access
      fields of that class via that reference.
  <li>The main lack is the ability for classes to be passed around as
      data items, e.g. methods  returning classes.
  <li>The JVM is  not "aware" of inner classes, they are implemented
      as regular classes with mangled names like <code>Foo$1Boo</code> for
      an inner class <code>Boo</code> inside  <code>Boo</code>.
 </ul>

Java 8 has Lambdas!
 <ul>
   <li>Fully higher order functions are now available in Java
   <li>Finally Java has caught up with Lisp circa 1964! It took only 50 years.
   <li><a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">Here is a tutorial</a>
   <li>Java 8 higher-order functions can "pun" as any interface with only one method in it.<br>
-- the function is taken to be the body of that single method, no need to write the method name when declaring the function then.
   <li>There is also some (limited) type inference for Lambda parameters.
   <li>Lets put some cayenne in our latte!  Here at long last is Currying in Java: <a href="https://gist.github.com/timyates/7674005">Gist currying example</a> that we will go through.
       </ul>
 Terminology aside: <em>closure</em>
 <ul>
   <li>A <em>closure</em> is just a higher-order
 function return value
   <li>The term "closure" comes from how they are
 implemented -- all variables not local to the function must be remembered
   <li>(We didn't have this problem in our interpreters because we
 substituted when we did function application, but that is not very efficient)
   <li>Caml example:
       <pre>
       let x = 5 in
         let f y = x + y in (* f is at runtime a closure: a pair (f's-code, {x |-> 5}) *)
           let x = 22 in
             f 2 (* prints 7 because x was 5 in f's closure *)
       </pre>
   <li>The PL book Section 8.1 describes <em>closure conversion</em>, a method to "implement" closures in <strong>FbSR</strong> itself by modifying functions to explicitly record the information.
 </ul>
 
<h3>Concurrency</h3>
The book chapter on concurrency reviews the Java concurrency model.

<h3>Other points of comparison between Java and Caml / Fb</h3>
<ul>
  <li>Java variant types analogue? <br>
-- used to not exist but now there are enums
      at least; "use subtyping and dynamic dispatch instead"
  <li>Type Inference -- types are declared in Java; avoids all the
      glitches in the OCaml design to support inference but requires
      more programmer typing.
  <li>Java Exceptions -- very similar to Caml or <strong>TFbX</strong> but Caml has no <code>throws</code> declarations in the types: less apparent what is being thrown.
</ul>

<h3>Dimensions of Java we did not get very close to
</h3><ul>
  <li>The implementation side: the JVM, JNI, etc
  <li>Reflection
  <li>Dynamic class loading
  <li>Java packages
  <li>run-time type tags and <code>instanceof</code>
</ul>


</div>


<!--#include virtual="/pl/footer.html" -->
