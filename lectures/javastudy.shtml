
<!--#include virtual="/pl/header.html" -->

</div>

<div id="content"> <h2>Study of Java</h2>
Our reference here  is  the <a
href="http://docs.oracle.com/javase/specs/jls/se7/html/index.html">Java
Language Specification, SE 7 Edition</a>.<p>
<ul>
  <li>In lecture we covered three languages which cover the principles underlying Java: <strong>FbOB</strong> (objects), <strong>STFb</strong> (subtyping), and <strong>PEFb</strong> (the P, polymorphism/generics part, not the inference part). 
  <li>A Fb language corresponding to Java would be "<strong>PSTFbOB</strong>"
  <li>We did not cover this but most of the aspects would not be surprising to you; a few gaps include
      <ul>
	<li><strong>STFb</strong> had subtyping on records and we need subtyping on objects for Java; <em>but</em>, as we know from the <strong>FbOB</strong> encoding, objects and records are very similar
	<li><code>this</code> imposes some additional issues in object typing.  Notice that
	          <pre>PointType = { x : Int; y : Int; magnitude: PointType -> Int -> Int; ...}</pre>
	    should be a proper type for our point object encoding, and notice how it is self-referential (recursive) and also how <code>PointType</code> is contravariant, it is in the domain of the magnitude method.  Both of these issues need to be addressed.
      </ul>
</ul>

<h3>Classes and inheritance</h3>
We can encode in <strong>STFbSR</strong> nearly all of the features of basic java class declarations and inheritance.
<ul>
  <li>Information hiding is possible in Java via <code>private/protected</code> fields; information hiding in <strong>STFbOB</strong> is accomplished by subsumption -- use subsumption after every <code>new</code> of an object to hide the private/protected bits.
  <li>Static fields are easily encoded, think of the class as itself being an object.
  <li>Java classes can have multiple constructors, this is possible in an encoding by making other constructors besides <code>new</code> in the class-object of the previous point.
  <li>The devil lies in the details however - Java has many tweaks to what the straightforward encoding does.
<ul>
  <li>Java by default inserts <code>super();</code> in front of the
  constructor if  another constructor is not invoked.
  <li>There is a default constructor w/ body just <code>super();</code> if none is declared.
  <li>etc etc etc
</ul>

</ul>

An example of encoding static fields and multiple constructors in <strong>FbSR</strong> taken from the book:
<pre>
Let pointClass = {

  newWithXY = Function thisClass ->
    Function newx -> 
    Function newy -> {

    x = Ref newx;
    y = Ref newy;
    magnitude = Function this -> Function _ ->
      sqrt ((!(this.x)) + (!(this.y)))
  };

  new = Function thisClass -> Function _ -> 
    (thisClass.newWithXY) thisClass (thisClass.xdefault) 
                            (thisClass.ydefault);

  xdefault = 0;
  ydefault = 0
} In

Let point = (pointClass.new) pointClass {} In
(point.magnitude) point {}

    </pre>
<h4>Information Hiding Contrast: Java public/private/package protected/protected vs Caml module</h4>

<ul>
  <li>Caml allows arbitrary multiple views of the same module
      (different things seen by different code given the same module)
  <li>Java has 
      fixed forms of multiple view: subclasses may see more
      (protected) and within vs without a package may see more
      (package protected)
  <li>Caml is more flexible, but Java is much simpler.
</ul>


<h3>Nominal Subtyping</h3>
<ul>
  <li>Subtype relationships in Java are <em>nominal</em>: they must be declared via extends/implements aclass/aninterface, except for primitive type subtyping;<br>
-- even if a class clearly implements all the methods of an interface, if the interface is not specified in the header there is no subtyping possible.
  <li>In <strong>STFb</strong> subtyping only
      depended on the structure of the underlying records.
      <strong>STFb</strong> subtyping is thus <em>purely
      structural</em> and Java's is not.
      <ul>
	<li>Structural subtyping is more flexible.
	<li>Nominal subtyping lets you think about subtyping in terms of names of things, not the details of whats inside.
      </ul>
  <li>In Java pre-5 there was no "deep" subtyping on objects: unlike in our <strong>STFbR</strong> subtyping of records where e.g. <pre>{ {x : Int; y : Int}; q : Bool} &lt;: { {x : Int}; q :Bool} </pre> but now Java supports this, 
      you can refine the type in a subclass - <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.5">see here</a>.<br>
</ul>

<h3><a
 href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.4">Generics</a>
 </h3>
 <p>
Generics are Java's version of parametric types.  These notes assume
      familiarity with them; read a <a
      href="http://download.oracle.com/javase/tutorial/extra/generics/index.html">tutorial</a>
      if you are not.

<p>
The <strong>PEFb</strong> language includes both type inference and polymorphism so it is the only language we studied with polymorphism.  The main idea of how generic types are handled are expressed there, but in an inference context.<p>

 Here are some
      comparisons with the <strong>PEFb</strong> or Caml-style parametric types that we  studied:
<ul>
  <li>Caml infers generic types <code>'a</code> automatically; in Java, you must
      declare them as <code>&lt;T&gt;</code>.
  <li>Caml infers generic types for functions defined by <code>let</code>; in Java you can declare generic types on classes and methods<br>
--note both of these forms are modeled by <code>Let</code>-defined functions in our <strong>FbSR</strong> object encodings, showing the form of where parametric poly is allowed is analogous
  <li>Java generics have some features not found in Caml due to the
      combination of polymorphism and subtyping.
</ul>
<h4>Bounded subtyping</h4>
<ul>
  <li>Recall with generics you cannot  have <code>List&lt;String>
      &lt;: List&lt;Object></code> kinds of things (see <a
      href="http://download.oracle.com/javase/tutorial/extra/generics/subtype.html">here</a>
      for description) even though <code>String &lt;:Object</code> holds.
  <li>The root of this  in subtpying theory is that
      <code>String/Object</code> may occur both positively and
      negatively  in <code>List</code>'s signature, so it needs to be
      invariant.  
  <li>In <strong>STFb</strong> the problem comes up in how subtyping
      is defined contravariantly on function types.   A  list type
      would at least include <code>add</code> and <code>head</code> so
      the subtyping needed for the above would be at least
 <pre>{ add: String -> {}; head : {} -> String } &lt;: { add: Object -> {}; head : {} -> Object }      </pre>
and this relation fails because it also requires <code>Object &lt;:
      String</code> due to the <code>add</code> parameter argument contravariance.  
  <li>In <strong>STFb</strong> we could in fact have such subtypings
      holding for the case they were positive  only -- imagine some
      list which you could only get the head of, nothing else:
      <pre>{ head : {} -> String } &lt;: { head : {} -> Object }      </pre>
      would be a legal subtyping in our <strong>STFb</strong> rules
      assuming <code>String &lt;: Object</code>. 
  <li>Java is
      conservatively assuming that <code>List<T></code> will have
      <code>T</code> both as argument and return type of methods  and
      so always forces invariance here.  But, for the case the list class was immutable and T was never an argument the above subtyping would hold and our <strong>STFb</strong> approach would support that.
</ul>      

To get around this weakness, Java 5 adds <em>bounded subtyping</em>
  <ul>
    <li>In generics  you can write things like <code>&lt;T extends C &amp; I&gt; void test(T t) </code>
  <li>the "<code>extends C &amp; I</code>" means <code>T</code> can be
      any type which extends both class <code>C</code> and interface
      <code>I</code> -- in other words, <code>T &lt;: C</code> and  <code>T &lt;:
      I</code> in our subtyping terminology.
  <li>This adds more flexibility, <code>T</code> need not be any type,
  but from a restricted range of types which gives added flexibility later.
  <li>Example: Suppose we had Java analogues <code>Point</code>, <code>ColorPoint</code> which were the obvious Java versions of our <strong>FbSR</strong> encodings; consider then a
      <pre>
      class Path&lt;P extends Point&gt; ...
      addPoint(P p) { ... } 
      Iterator&lt;P&gt; walk() { ... }
      double calcPathLength() { ... } </pre>
  <li>In terms of type theory this is is called <em>bounded polymorphism</em>: there are subtype bounds on the parametric types.
  <li>Java also allows type variable wildcards, <code>?</code> - this is
      a form of <em>existential type</em> -- the typing  holds  for
  <em>some</em> <code>?</code>.
</ul>


<h3><a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.9">Method Overloading</a></h3>
The take-home message here is brief:
<ul>
  <li> Java method overloading can be
  viewed as concatenating all of the argument types onto the method
  name. 
  <li>So it is really just a form of syntactic sugar. 
  <li>We will briefly look at the examples in the above spec.
</ul>

<h3>Immutable Data</h3>
One  of the key lessons of Caml is the importance of immutable data: its not changing underneath your feet.<p>
<ul>
  <li>Java allows fields to not mutate if qualified with <code>final</code>.
  <li>Caml analogy: a <code>let</code>-defined variable.
  <li>Like Caml, immutability is only shallow - the field could
      contain <em>components</em> that mutate.
  <li>Unlike Caml the default case is swapped and this has a huge impact on expected programmer behavior.
</ul>

<h3>Inner Classes</a></h3>
Lets start with reviewing what <strong>FbOB</strong> had in this area:
<ul>
  
  <li>In <strong>FbOB</strong> we had the ability to declare classes
      anywhere, including inside  other  class methods, etc.  Those
      classes could  also be returned as result values of methods, to  
      be <code>new</code>-ed in a completely different context.
  <li><strong>FbOB</strong> also has  syntax for directly defining
      objects: <code>Object Inst ... Meth ..</code>.
  <li>In general, this is an example of <em>fully higher-order</em>
      classes and objects -- no restrictions on where they can be
      defined, used or passed to.
</ul>
Java inner classes give some but not all of the above <strong>FbOB</strong> functionality.
<ul>
  <li>They do allow local classes to be defined just about anywhere.
  <li>They do support something similar to the <code>Object</code>
      syntax of  <strong>FbOB</strong>, via anonymous local classes
      which are  immediately  <code>new</code>-ed. 
  <li>They do support multiple levels of nesting: inner classes  can
      have inner classes inside  them.
  <li>At runtime, each inner class instance holds a pointer to the
      instance of the class nesting it that created it; it can access
      fields of that class via that reference.
  <li>The main lack is the ability for classes to be passed around as
      data items, e.g. methods  returning classes.
  <li>The JVM is  not "aware" of inner classes, they are implemented
      as regular classes with mangled names like <code>Foo$1Boo</code> for
      an inner class <code>Boo</code> inside  <code>Boo</code>.
 </ul>

Inner classes / <strong>FbOB</strong> object declarations vs the
 higher-order functions of Caml etc:
 <ul>
   <li><strong>FbOB</strong> objects with just one method called
 e.g. <code>theFunction</code> are a full and faithful encoding of higher-order functions.
   <li>Smalltalk takes the view of rather than having first-class
 objects just add higher-order functions directly; they are called
 <em>blocks</em> in Smalltalk.
   <li><a href="http://openjdk.java.net/projects/lambda/">Project
      Lambda</a> is a proposal to add full higher-order 
      functions to JDK 8.
 </ul>
 Terminology aside: <em>closure</em>
 <ul>
   <li>A <em>closure</em> is just a higher-order
 function return value
   <li>The term "closure" comes from how they are
 implemented -- all variables not local to the function must be remembered
   <li>(We didn't have this problem in our interpreters because we
 substituted when we did function application, but that is not very efficient)
   <li>Caml example:
       <pre>
       let x = 5 in
         let f y = x + y in (* f is at runtime a closure: a pair (f's-code, {x |-> 5}) *)
           let x = 22 in
             f 2 (* prints 7 because x was 5 in f's closure *)
       </pre>
 </ul>
 
<h3>Concurrency</h3>
The book chapter on concurrency reviews the Java concurrency model.

<h3>Other points of comparison between Java and Caml / Fb</h3>
<ul>
  <li>Java variant types analogue? <br>
-- used to not exist but now there are enums
      at least; "use subtyping and dynamic dispatch instead"
  <li>Type Inference -- types are declared in Java; avoids all the
      glitches in the OCaml design to support inference but requires
      more programmer typing.
  <li>Java Exceptions -- very similar to how we did them in <strong>TFbX</strong> but we had no <code>throws</code> declarations in our types.
</ul>

<h3>Dimensions of Java we did not get very close to
</h3><ul>
  <li>The implementation side: the JVM, JNI, etc
  <li>Reflection
  <li>Dynamic class loading
  <li>Java packages
</ul>


</div>


<!--#include virtual="/pl/footer.html" -->
