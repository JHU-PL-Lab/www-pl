
<!--#include virtual="/pl/header.html" -->

</div>

<div id="content"> <h2>Study of Java</h2>
Our reference here  is  the <a
href="http://docs.oracle.com/javase/specs/jls/se5.0/html/j3TOC.html">Java
Language Specification, 3rd Edition</a>.  Part of the goal of this
lecture is for  you  to gain expertise in "spec reading". Some of the examples below
are  taken from the Java spec.<p>
<ul>
  <li>In lecture we covered three languages which reflect the key principles of Java: <strong>FbOB</strong>, <strong>STFb</strong>, and <strong>PEFb</strong>. 
  <li> The former had objects but was untyped, the next added subtyping and the last added polymorphism.
  <li>The language corresponding to Java is "<strong>PSTFbOB</strong>", basically putting polymorphic types and subtypes on to <strong>FbOB</strong>.  
  <li>We did not explcitly study that combination because there is not a lot of new stuff there -- subtyping on objects is like subtyping on records.
  <li>(Well, there is in fact one subtle issue if we tried to directly type our object encoding in <strong>STFbSR</strong> -- the self-passing means intuitively the type of a point object is
      <pre>PointType = { x : Int; y : Int; magnitude: PointType -> Int -> Int; ...}</pre>
      -- notice how this type is <em>recursive</em>, it is self-referential.  <strong>STFbSR</strong> has no recursive types; the <strong>CFbR</strong> system in the book which we did not cover does include recursive types and subtyping, and will be able to typecheck such programs)

</ul>

<h3>Classes and inheritance</h3>
We can easily encode in <strong>STFbSR</strong> nearly all of the features of basic java class declarations and inheritance.
<ul>
  <li>information hiding is possible in Java via private/protected fields; information hiding in <strong>STFbOB</strong> is easily accomplished by subsumption (use subsumption after every <code>new</code> of an object to hide the private/protected bits).
  <li>Static fields are easily encoded, its in the book (basically make the class itself an object, <code>new</code> is just a method on the class.
  <li>Java classes can have multiple constructors, this is also easy in an encoding by making other constructors besides <code>new</code> in this class-object.
  <li>But, while the spirit of constructors is easy, they contain all sorts of hairy extensions that significantly complicate the picture:
<ul>
  <li>Java by default inserts <code>super();</code> in front of the
  constructor if  another constructor is not invoked at  the  start; this  is a bit of a
  hack. 
  <li>There is a default constructor w/ body <code>super();</code> if none is declared.
  <li>Inner classs and generics add a whole load of complications to constructors.
</ul>

</ul>

An example of some static fields and constructors in <strong>FbSR</strong> taken from the book:
<pre>
Let pointClass = {

  newWithXY = Function class ->
    Function newx -> 
    Function newy -> {

    x = Ref newx;
    y = Ref newy;
    magnitude = Function this -> Function _ ->
      sqrt ((!(this.x)) + (!(this.y)))
  };

  new = Function class -> Function _ -> 
    (class.newWithXY) class (class.xdefault) 
                            (class.ydefault);

  xdefault = 0;
  ydefault = 0
} In

Let point = (pointClass.new) pointClass {} In
(point.magnitude) point {}

    </pre>
<h4>Java Public/Private/package protected/Protected vs Caml Module information hiding</h4>

<ul>
  <li>Caml allows arbitrary multiple views of the same module
      (different things seen by different code given the same module)
  <li>Java has 
      fixed forms of multiple view: subclasses may see more
      (protected) and within vs without a package may see more
      (package protected)
  <li>Caml is more flexible, but Java approach is simpler (on the
      surface at least).
</ul>


<h3><a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.10">Subtyping</a></h3>
<ul>
  <li>Subtype relationships in Java are <em>nominal</em>: they must be declared via extends/implements aclass/aninterface, except for primitive type subtyping;<br>
-- even if a class clearly implements all the methods of an interface, if the interface is not specified in the header there is no subtyping possible.
  <li>In <strong>STFb</strong> subtyping only
      depended on the structure of the underlying records.
      <strong>STFb</strong> subtyping is thus <em>purely
      structural</em> and Java's is not.
  <li>In Java pre-5 there was no "deep" subtyping on objects: unlike in our <strong>STFbR</strong> subtyping of records where e.g. <pre>{ {x : Int; y : Int}; q : Bool} &lt;: { {x : Int}; q :Bool} </pre> but now Java supports this, 
      you can refine the type in a subclass - <a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/classes.html#8.4.8.3">see here</a>.<br>
  <li>Summary: <strong>STFb</strong> is more expressive but Java's is
      easier to use due to names being given.
</ul>
<h3><a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/classes.html#295574">Inner Classes</a></h3>
Lets start with reviewing what <strong>FbOB</strong> had in this area:
<ul>
  
  <li>In <strong>FbOB</strong> we had the ability to declare classes
      anywhere, including inside  other  class methods, etc.  Those
      classes could  also be returned as result values of methods, to  
      be <code>new</code>-ed in a completely different context.
  <li><strong>FbOB</strong> also has  syntax for directly defining
      objects: <code>Object Inst ... Meth ..</code>.
  <li>In general, this is an example of <em>fully higher-order</em>
      classes and objects -- no restrictions on where they can be
      defined, used or passed to.
</ul>
Java inner classes give some but not all of the above <strong>FbOB</strong> functionality.
<ul>
  <li>They do allow local classes to be defined just about anywhere.
  <li>They do support something similar to the <code>Object</code>
      syntax of  <strong>FbOB</strong>, via anonymous local classes
      which are  immediately  <code>new</code>-ed. 
  <li>They do support multiple levels of nesting: inner classes  can
      have inner classes inside  them.
  <li>At runtime, each inner class instance holds a pointer to the
      instance of the class nesting it that created it; it can access
      fields of that class via that reference (see spec linked above
      for examples).
  <li>The main lack is the ability for classes to be passed around as
      data items, e.g. methods  returning classes.
  <li>The JVM is  not "aware" of inner classes, they are implemented
      as regular classes with mangled names like <code>Foo$1Boo</code> for
      an inner class <code>Boo</code> inside  <code>Boo</code>.
 </ul>

Inner classes / <strong>FbOB</strong> object declarations vs the
 higher-order functions of Caml etc:
 <ul>
   <li><strong>FbOB</strong> objects with just one method called
 e.g. <code>theFunction</code> are a full and faithful encoding of higher-order functions.
   <li>Smalltalk takes the view of rather than having first-class
 objects just add higher-order functions directly; they are called
 <em>blocks</em> in Smalltalk.
   <li><a href="http://openjdk.java.net/projects/lambda/">Project
      Lambda</a> is a proposal to add full higher-order 
      functions to JDK 8.
 </ul>
 Terminology aside: <em>closure</em>
 <ul>
   <li>A <em>closure</em> is just a higher-order
 function return value
   <li>The term "closure" comes from how they are
 implemented -- all variables not local to the function must be remembered
   <li>(We didn't have this problem in our interpreters because we
 substituted when we did function application, but that is not very efficient)
   <li>Caml example:
       <pre>
       let x = 5 in
         let f y = x + y in (* f is at runtime a closure: a pair (f's-code, {x |-> 5}) *)
           let x = 22 in
             f 2 (* prints 7 because x was 5 in f's closure *)
       </pre>
 </ul>

<h3><a
 href="http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#108850">Generics</a>
 </h3>
(other links: <a
 href="http://docs.oracle.com/javase/specs/jls/se5.0/html/classes.html#8.1.2">their
 use in
 classes</a>; <a
 href="http://www.oracle.com/technetwork/articles/javase/generics-136597.html">an
 overview</a>)
 <p>
Generics are Java's version of parametric types.  These notes assume
      familiarity with them; read a <a
      href="http://download.oracle.com/javase/tutorial/extra/generics/index.html">tutorial</a>
      if you are not.

<p>
The <strong>PEFb</strong> language includes both type inference and polymorphism so it is the only language we studied with polymorphism.  The main idea of how generic types are handled are expressed there, but in an inference context.<p>

 Here are some
      comparisons with the <strong>PEFb</strong> or Caml-style parametric types that we  studied:
<ul>
  <li>Caml infers generic types <code>'a</code> automatically; in Java, you must
      declare them as <code>&lt;T&gt;</code>.
  <li>Caml infers generic types for functions defined by <code>let</code>; in Java you can declare generic types on classes and methods<br>
--note both of these forms are modeled by <code>Let</code>-defined functions in our <strong>FbSR</strong> object encodings, showing the form of where parametric poly is allowed is analogous
  <li>Java generics have some features not found in Caml due to the
      combination of polymorphism and subtyping.
</ul>
<h4>Bounded subtyping</h4>
<ul>
  <li>Recall with generics you cannot  have <code>List&lt;String>
      &lt;: List&lt;Object></code> kinds of things (see <a
      href="http://download.oracle.com/javase/tutorial/extra/generics/subtype.html">here</a>
      for description) even though <code>String &lt;:Object</code> holds.
  <li>The root of this  in subtpying theory is that
      <code>String/Object</code> may occur both positively and
      negatively  in <code>List</code>'s signature, so it needs to be
      invariant.  
  <li>In <strong>STFb</strong> the problem comes up in how subtyping
      is defined contravariantly on function types.   A  list type
      would at least include <code>add</code> and <code>head</code> so
      the subtyping needed for the above would be at least
 <pre>{ add: String -> {}; head : {} -> String } &lt;: { add: Object -> {}; head : {} -> Object }      </pre>
and this relation fails because it also requires <code>Object &lt;:
      String</code> due to the <code>add</code> parameter argument contravariance.  
  <li>In <strong>STFb</strong> we could in fact have such subtypings
      holding for the case they were positive  only -- imagine some
      list which you could only get the head of, nothing else:
      <pre>{ head : {} -> String } &lt;: { head : {} -> Object }      </pre>
      would be a legal subtyping in our <strong>STFb</strong> rules
      assuming <code>String &lt;: Object</code>. 
  <li>Java is
      basically assuming that <code>List<T></code> will have
      <code>T</code> both as argument and return type of methods  and
      so always forces invariance here.  But, for the case the list class was immutable and T was never an argument the above subtyping would hold and our <strong>STFb</strong> approach would support that.
</ul>      

To get around this weakness, Java 5 adds <em>bounded subtyping</em>
  <ul>
    <li>In generics  you can write things like <code>&lt;T extends C &amp; I&gt; void test(T t) </code>
  <li>the "<code>extends C &amp; I</code>" means <code>T</code> can be
      any type which extends both class <code>C</code> and interface
      <code>I</code> -- in other words, <code>T &lt;: C</code> and  <code>T &lt;:
      I</code> in our subtyping terminology.
  <li>This adds more flexibility, <code>T</code> need not be any type,
  but from a restricted range of types which gives added flexibility later.
  <li>Example: Suppose we had Java analogues <code>Point</code>, <code>ColorPoint</code> which were the obvious Java versions of our <strong>FbSR</strong> encodings; consider then a
      <pre>
      class Path&lt;P extends Point&gt; ...
      addPoint(P p) { ... } 
      Iterator&lt;P&gt; walk() { ... }
      double calcPathLength() { ... } </pre>
  <li>The constraint-based
      <strong>CFbR</strong> (which we may not have covered) with let-polymorphism also allows such
      sorts of types to be expressed:
     <pre> test : 'a -> void \ { 'a <: C, 'a <: I }</pre>
  <li>Java also allows type variable wildcards, <code>?</code> - this is
      a form of <em>existential type</em> -- the typing  holds  for
  <em>some</em> <code>?</code>.
</ul>


<h3><a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/classes.html#8.4.9">Method Overloading</a></h3>
The take-home message here is brief:
<ul>
  <li> Java method  overloading can be
  viewed as concatenating all of the argument types onto the method
  name. 
  <li>So it is really just a form of syntactic sugar. 
  <li>We will briefly look at the examples in the above  spec.
</ul>

<h3>Immutable Data</h3>
One  of the key lessons  of Caml is  the importance of known immutable
data: it has universal meaning.<p>
<ul>
  <li>Java allows fields to not mutate if qualified with <code>final</code>.
  <li>Caml analogy: a <code>let</code>-defined variable.
  <li>Like Caml, immutability is only shallow - the field could
      contain <em>components</em> that mutate.
  <li>Unlike Caml the default case is swapped and this has a huge impact on expected programmer behavior.
</ul>


<h3>Concurrency</h3>
The book chapter on concurrency reviews the Java concurrency model.

<h3>Other issues of comparison between Java and Caml / Fb family of languages</h3>
<ul>
  <li>Java variant types analogue? <br>
-- used to not exist but now there are enums
      at least; "use subtyping and dynamic dispatch instead"
  <li>Type Inference -- types are declared in Java; avoids all the
      glitches in the OCaml design to support inference but requires
      more programmer typing.
  <li>Java Exceptions -- very similar to how we did them in <strong>TFbX</strong> but no <code>throws</code> declarations in our types.
</ul>

<h3>Some interesting dimensions of Java we did not study in this course
</h3><ul>
  <li>Reflection
  <li>Dynamic class loading
  <li>JNI - interfacing with native code
</ul>


</div>


<!--#include virtual="/pl/footer.html" -->
