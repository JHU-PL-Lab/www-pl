<!--#include virtual="/pl/header.html" -->

</div>

<div id="content"> <h2>Study of Dynamically Typed Languages</h2>

<!-- Need to redo these notes to focus less on obscure features not used and more on actual used features.  Also lambda in Pyton is not allowed to work on non-expressions -->
<h3>Dynamic Typing</h3>
A <em>dynamically typed language</em> is a language which 
<ul>
  <li> Has no typechecker as part of the compiler which rejects
      programs based on their types
  <li> Detects type faults at runtime, e.g. adding a number and
      a function, etc, raising an exception in such cases.
</ul>

Upsides
      <ul>
	<li>Can be more freewheeling: incrementally add code to current runtime, extend objects, etc.
	<li>Even better than type inference in terms of overhead of dealing with writing out type information.
      </ul>



Downsides
  <ul>
  <li>Programs run slower due to the run-time overhead of dynamic checks and uncertain layouts.
  <li>Type errors are caught much later, making debugging much more challenging in some cases.
  <li>Freewheeling style bites you for larger apps which don't
	    fit in your mental cache anymore
</ul>

Overall verdict
      <ul>
	  <li>Dynamically-typed languages tend to be better for small- and perhaps
      medium-scale applications where speed is not critical, and tend to be worse for large-scale
      applications and speed-critical applications.
      </ul>
      
Common properties
<ul>
  <li>They often run in an environment with a top-loop and where the codebase is
      itself a mutable data structure -- can turn a string into new code and run it.
  <li>Dynamically typed languages are often at the forefront of language features: its easy to add new features to them so they have led much of the evolution of PLs (historical examples: Lisp, Smalltalk).
  <li>The modern ones have good foreign function interfaces to C(++) and use C libraries when speed is needed.
</ul>

<h3>The Different Schools of Dynamically-typed Languages</h3>
The non-OO school
<ul>
  <li>Lisp, the original dynamically-typed language, and the related Scheme which is "<code>(add1 Lisp)</code>"
  <li><a
      href="http://en.wikipedia.org/wiki/Scripting_programming_language">Scripting
      languages</a>, e.g. the  UNIX shells (sh, csh), awk, tcl, etc. 
  <li>early Perl (pre-5)
</ul>

The "classic" dynamic OO languages
<ul>
  <li>Smalltalk
      aka squeak
  <li>CLOS, the Common Lisp Object System
  <li>Dylan - based on CLOS, now in the dustbin of history
</ul>


The "modern" school
<ul>
  <li>Perl 5+
  <li><a href="http://docs.python.org/tut/">Python</a>
  <li><a
      href="http://www.ruby-doc.org/docs/ProgrammingRuby/">Ruby</a>
  <li>Javascript
</ul>
<h3>Dynamically typed languages and our <strong>Fb</strong>
series</h3>
<ul>
  <li>Our <strong>FbSRXVOB</strong> mash contains the core features of
      a dynamically typed language.
  <li>We did not cover how run-time type errors lead to exceptions but
      its simple: add a bunch of runtime type error handling rules including
       <table border='0' cellpadding='0' cellspacing='15'>   <tr> <td><strong>(<span 
class="cmtt-10">- </span>Mismatch Bool Left)</strong></td> <td> <table border='0' cellpadding='0' cellspacing='0'> <tr><td align='center'>&nbsp;<span 
class="cmmi-10">e</span>&nbsp;==&gt;&nbsp;<span 
class="cmtt-10">True</span></td></tr> <tr><td><hr noshade size='1'></td></tr> <tr><td align='center'><span 
class="cmmi-10">e</span> <span 
class="cmtt-10">-</span> <span 
class="cmmi-10">e</span><span 
class="cmsy-10">'</span>&nbsp;==&gt;&nbsp;<span 
class="cmtt-10">Raise (#</span><span 
class="cmti-10">TypeMismatch</span> <span 
class="cmmi-10">True</span><span 
class="cmtt-10">)</span></td></tr> </table> </td> </tr>  </table>
etc -- many such rules are needed.  But, thats about all there is to it.
<li>As with Java there are also some dimensions of these languages we
    missed, in particular all the reflection-type stuff and dynamic
    code loading.
</ul>
We will now look at some crosscutting aspects of these languages.
<h3>Blocks of code aka higher order functions</h3>
<ul>

 <li>Lisp/Scheme: <code>(lambda (x) ... )</code> - Lisp was the first
  language with implemented  higher-order functions
  <li>Smalltalk: <a
      href="http://en.wikipedia.org/wiki/Smalltalk#Code_blocks">code
      blocks</a>
  <li>Ruby: blocks which are similar to Smalltalk's.
  <li>Python: <a href="http://docs.python.org/tutorial/controlflow.html#lambda-forms">lambda-forms</a> (but`, Python's lambdas don't deal with nonlocal variables well)
</ul>

<h3>Flexibility of the notion of object</h3>
<h4>Smalltalk</h4>
      <ul>
	<li>Everything is an object in Smalltalk: Even <a href="http://en.wikipedia.org/wiki/Smalltalk#Control_structures">if-then-else</a> and <code>+</code> are expressed via messaging syntax (but, actual implementations are more efficient)
	<li>Global variables is nothing but a systemwide dictionary
	    (hashset).
	    <pre>     Smalltalk at: #f put: (Foo new) </pre>
	    adds a new Foo named <code>#f</code> to the globals which
	    is a dictionary affiliated  with object <code>Smalltalk</code>.
	<li>Classes themselves are nothing but atoms in this
	    dictionary -- <code>#Foo</code> in the above case is in
	    the global dictionary, <code>Smalltalk</code>.
	<li>Classes are fully objects - they can be passed around as data
	<li>Methods are not first-class in Smalltalk however, they cannot be pulled out of their object.
      </ul>  

<h4>Ruby</h4>
      <ul>
	<li>Classes are objects in Ruby. For example the
	    <code>inherited</code> method 
	    of the class is run when a new subclass is <em>defined</em>.
	<li><code>NilClass</code> is also a class, as in Smalltalk (where it is <code>Nil</code>) 
	<li>There is also a global dictionary in Ruby that contains the defined classes, <code>Objects.constants</code>
	<li>Methods are first-class in Ruby: <a href="http://ruby-doc.org/docs/ProgrammingRuby/html/ref_c_method.html">Example</a>.
	<li>Can add methods to existing objects - <a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/ref_c_object.html#Object.extend">documentation</a>
      </ul>
<h4>Python</h4>
      <ul>
	<li>Python classes are also objects.
	<li>Methods are first-class:  <a
      href="http://docs.python.org/tutorial/classes.html#method-objects">Example</a>.
	<li>Python objects are similar to our <strong>FbSR</strong> objects: <code>self</code> is an explicit parameter, classes are themselves just records, methods are just self-taking funtions in these records, etc.
	<li>In some ways they are even more flexible: their "records" are completely dynamic even for extending -- <a href="http://docs.python.org/tutorial/classes.html#instance-objects">example</a>.  <strong>FbSR</strong> records cannot be extended (we did it that way so we could type them easily).
      </ul>

<h3>Reflection</h3>
      <ul>
	<li>Given some object at runtime, can you poke around to find its class, methods,
etc? 
	<li>another term for this is it has a <em>MOP</em> - a Meta-Object Protocol
	<li>  This stuff is  very easy to do in a dynamically-typed language because the program data structure
is  around explicitly at runtime.
	<li>Another common feature is the ability to <code>eval</code> -- to invoke the compiler/interpreter directly so you can turn a string of Smallktalk/Python/Ruby source into a running program.
      </ul>

Smalltalk
      <ul>
	<li>Can easily turn a string into a method name to
      invoke.  
	<li>Objects can also <code>become</code> a completely new behavior.
      </ul>
Ruby
      <ul>
	<li> Can turn string into method  to invoke -  <a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/ospace.html#S3">documentation</a>
	<li>Can take  an object an specialize  it with its  own
	    singleton class, adding new  methods; the objects old
	    class becomes the superclass of this new class.  <a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/ospace.html#UB">example</a>
      </ul>
Python
      <ul>
	<li>Can change the class of an object at runtime.
	    Related to <code>become</code> of Smalltalk
      </ul>

Ruby is much cleaner here,  it has clean notions of adding methods and
Smalltalk and Python can blow up because methods will disappear, and
field references are wacky.
<h3>Inheritance</h3>
<ul>
  <li>Smalltalk: regular single inheritance
  <li>Python: multiple inheritance (and the associated <a
      href="http://en.wikipedia.org/wiki/Diamond_problem">Diamond
      Problem</a> of course)
  <li>Ruby: single inheritance plus arbitrary <a
      href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/classes.html#UC">mixin
      modules</a>.  Modules are like classes but since these modules are themselves at the top of
      the hierarchy (modules cannot have supermodules) there is no
      dreaded diamond property -- you can only build three of the four
      edges of the diamond.
</ul>


<h3>Overloading and shortcut syntax</h3>
<ul>
  <li>Smalltalk - can do it yourself manually since operators  are all only
      messages (but ugly); no regular expressions
  <li>Python: yes
  <li>Ruby: yes
</ul>

</div>


<!--#include virtual="/pl/footer.html" -->
