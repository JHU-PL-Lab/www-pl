<!--#include virtual="/pl/header.html" -->

</div>

<div id="content"> <h2>Study of Dynamically Typed Languages</h2>

<!-- Need to redo these notes to focus less on obscure features not used and more on actual used features.  Also lambda in Pyton is not allowed to work on non-expressions -->
<h3>Dynamic Typing</h3>
A <em>dynamically typed language</em> is a language which 
<ul>
  <li> Has no typechecker as part of the compiler which rejects
      programs based on their types
  <li> Detects type faults at runtime, e.g. adding a number and
      a function, etc, raising an exception in such cases.
</ul>

Upsides
      <ul>
	<li>Can be more freewheeling: incrementally add code to current runtime, extend objects, etc.
	<li>Even better than type inference in terms of overhead of dealing with writing out type information.
      </ul>



Downsides
  <ul>
  <li>Programs run slower due to the run-time overhead of dynamic checks and uncertain layouts.
  <li>Type errors are caught much later, making debugging much more challenging in some cases.
  <li>Freewheeling style bites you for larger apps which don't
	    fit in your mental cache anymore
</ul>

Overall verdict
      <ul>
	  <li>Dynamically-typed languages tend to be better for small- and perhaps
      medium-scale applications where speed is not critical, and tend to be worse for large-scale
      applications and speed-critical applications.
      </ul>
      
Common properties
<ul>
  <li>They often run in an environment with a top-loop and where the codebase is
      itself a mutable data structure -- can turn a string into new code and run it.
  <li>Dynamically typed languages are often at the forefront of language features: its easy to add new features to them so they have led much of the evolution of PLs (historical examples: Lisp, Smalltalk).
  <li>The modern ones have good foreign function interfaces to C(++) and use C libraries when speed is needed.
</ul>

<h3>The Different Schools of Dynamically-typed Languages</h3>
The non-OO school
<ul>
  <li>Lisp, the original dynamically-typed language, and the related Scheme which is "<code>(add1 Lisp)</code>"
  <li><a
      href="http://en.wikipedia.org/wiki/Scripting_programming_language">Scripting
      languages</a>, e.g. the  UNIX shells (sh, csh), awk, tcl, etc. 
  <li>early Perl (pre-5)
</ul>

The "classic" dynamic OO languages
<ul>
  <li>Smalltalk
      aka squeak
  <li>CLOS, the Common Lisp Object System
</ul>


The "modern" school
<ul>
  <li>Perl 5+
  <li><a href="http://docs.python.org/tut/">Python</a>
  <li><a
      href="http://www.ruby-doc.org/docs/ProgrammingRuby/">Ruby</a>
  <li>Javascript
</ul>
<h3>Dynamically typed languages and our <strong>Fb</strong>
series</h3>
<ul>
  <li>Our <strong>FbSRXVOB</strong> mash contains the core features of
      a dynamically typed language.
  <li>We did not cover how run-time type errors lead to exceptions but
      its simple: add a bunch of runtime type error handling rules including
       <table border='0' cellpadding='0' cellspacing='15'>   <tr> <td><strong>(<span 
class="cmtt-10">- </span>Mismatch Bool Left)</strong></td> <td> <table border='0' cellpadding='0' cellspacing='0'> <tr><td align='center'>&nbsp;<span 
class="cmmi-10">e</span>&nbsp;==&gt;&nbsp;<span 
class="cmtt-10">True</span></td></tr> <tr><td><hr noshade size='1'></td></tr> <tr><td align='center'><span 
class="cmmi-10">e</span> <span 
class="cmtt-10">-</span> <span 
class="cmmi-10">e</span><span 
class="cmsy-10">'</span>&nbsp;==&gt;&nbsp;<span 
class="cmtt-10">Raise (#</span><span 
class="cmti-10">TypeMismatch</span> <span 
class="cmmi-10">True</span><span 
class="cmtt-10">)</span></td></tr> </table> </td> </tr>  </table>
etc -- many such rules are needed.  But, thats about all there is to it.
<li>As with Java there are also some dimensions of these languages we
    missed, in particular all the reflection-type stuff and dynamic
    code loading.
</ul>
We will now look at some crosscutting aspects of these languages.

<h3>Universal Data Structure</h3>
Most dynamic languages are built around the philosophy that all data are "X"'s, where X is:
<ul>
  <li>Lisp: Lists
  <li>Smalltalk: Objects
  <li>Python: Dictionaries (Objects are tweaks on dictionaries)
  <li>Ruby: Objects
  <li>Javascript: Objects (Use objects as dictionaries as well)
</ul>

      <h3>Inheritance</h3>
<ul>
  <li>Smalltalk: regular single inheritance
  <li>Python: multiple inheritance (and the associated <a
      href="http://en.wikipedia.org/wiki/Diamond_problem">Diamond
      Problem</a> of course)
  <li>Ruby: single inheritance plus arbitrary <a
      href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/classes.html#UC">mixin
      modules</a> which are basically classic mixins.  Modules are like classes but since these modules are themselves at the top of
      the hierarchy (modules cannot have supermodules) there is no
      dreaded diamond property -- you can only build three of the four
      edges of the diamond.
</ul>




<h3>Higher order functions</h3>
<ul>

 <li>Lisp/Scheme: <code>(lambda (x) ... )</code>
     <ul>
       <li> Lisp was the first language with implemented  higher-order functions
       <li>But, they didn't quite get it right, they used <em>dynamic binding</em> for nonlocal variables which is bone-headed.
     </ul>
  <li>Smalltalk: <a
      href="http://en.wikipedia.org/wiki/Smalltalk#Code_blocks">code
      blocks</a> subsume higher-order functions.
  <li>Ruby: has blocks which are similar to Smalltalk's.
  <li>Python: <a href="http://docs.python.org/tutorial/controlflow.html#lambda-forms">lambda-forms</a> (but, <a href="http://stackoverflow.com/questions/141642/what-limitations-have-closures-in-python-compared-to-language-x-closures">Pre-3 Python's lambdas don't let you write to nonlocal variables</a>)
</ul>

<h3>Flexibility of the notion of object</h3>
<h4>Smalltalk</h4>
      <ul>
	<li>Everything is an object in Smalltalk: Even <a href="http://en.wikipedia.org/wiki/Smalltalk#Control_structures">if-then-else</a> and <code>+</code> are expressed via messaging syntax e.g. <code>if: ... then: .. else: ...</code> is an <code>if:then:else:</code> message
	<li>Global variables are a systemwide dictionary object
	    (a HashMap).
	    <pre>     Smalltalk at: #f put: (Foo new) </pre>
	    adds a new Foo named <code>#f</code> to the globals which
	    is a dictionary affiliated  with object <code>Smalltalk</code>.
	<li>Classes themselves are nothing but atoms in this
	    dictionary -- <code>#Foo</code> in the above case is in
	    <code>Smalltalk</code>.
	<li>Classes are fully objects - they can be passed around as data
	<li>Methods are not first-class in Smalltalk however, they cannot be pulled out of their object.
	<li>Objects are not extensible dynamically so they are weaker than dictionaries.
      </ul>  

<h4>Ruby</h4>
      <ul>
	<li>Classes are objects in Ruby. For example the
	    <code>inherited</code> method 
	    of the class is run when a new subclass is <em>defined</em>.
	<li><code>NilClass</code> is also a class, as in Smalltalk (where it is <code>Nil</code>) 
	<li>There is also a global dictionary in Ruby that contains the defined classes, <code>Objects.constants</code>
	<li>Methods are first-class in Ruby: <a href="http://ruby-doc.org/docs/ProgrammingRuby/html/ref_c_method.html">Example</a>.
	<li>Can add methods to existing objects - <a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/ref_c_object.html#Object.extend">documentation</a>
      </ul>
<h4>Python</h4>
      <ul>
	<li>Objects are duck-taped onto the more fundamental notion of "everything is a dictionary" in Python.
	<li>Unlike Ruby, the object and dictionary access syntax is different; Ruby is a more elegant design by unifying the two. 
	<li>Python objects are thus similar to our <strong>FbSR</strong> objects (a record is a restricted dictionary): <code>self</code> is an explicit parameter, classes are themselves just records, methods are just self-taking funtions in these records, etc.
	<li>Classes are objects (which are really just dictionaries)
	<li>Methods are first-class:  <a
      href="http://docs.python.org/tutorial/classes.html#method-objects">Example</a>.
	<li>Python dictionaries can be dynamically extended -- <a href="http://docs.python.org/tutorial/classes.html#instance-objects">example</a>.
      </ul>

<h3>Reflection</h3>
      <ul>
	<li>"Reflection" means given some object at runtime, can you poke around to find its class, methods, etc? 
	<li>  Reflection is easy to do in a dynamically-typed language because the program data structure is always around explicitly at runtime (its also around in Java so reflection also possible there, but the type system gets in the way).
	<li>Another common feature is the ability to <code>eval</code> -- to invoke the compiler/interpreter directly so you can turn a string of Smallktalk/Python/Ruby source into a running program.
      </ul>

Smalltalk
      <ul>
	<li>Can turn a string into a method name to
      invoke.  
	<li>Objects can also <code>become</code> a completely new behavior.
      </ul>
Ruby
      <ul>
	<li> Can turn string into method to invoke -  <a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/ospace.html#S3">documentation</a>
      </ul>
Python
      <ul>
	<li>Can change the class of an object at runtime.
	    Related to <code>become</code> of Smalltalk
      </ul>


<h3>Overloading and shortcut syntax</h3>
<ul>
  <li>Smalltalk: no
  <li>Python: no overloading but has variable-argument functions, implicit values for missing arguments, multiple syntactic conventions for invoking functions.
  <li>Ruby: operators like <code>+</code> can be overloaded since <code>+</code> is "just" a method name.  Methods can't be overloaded.  Similar variable-argument etc niceties of Python.
</ul>

None of these languages has a general pattern matching on data structures (not just strings) like OCaml does; Python 3 adds some.<p>

</div>


<!--#include virtual="/pl/footer.html" -->
