<!--#include virtual="/pl/header.html" -->

</div>

<div id="content"> <h2>Study of Dynamically Typed Languages</h2>

<!-- Need to redo these notes to focus less on obscure features not used and more on actual used features.  Also lambda in Pyton is not allowed to work on non-expressions -->
<h3>Dynamic Typing</h3>
A <em>dynamically typed language</em> is a language which 
<ul>
  <li> Has no typechecker as part of the compiler which rejects
      programs based on their types
  <li> Detects type faults at runtime, e.g. adding a number and
      a function, etc, raising an exception in such cases.
</ul>

Upsides
      <ul>
	<li>Can be more freewheeling: incrementally add code to current runtime, extend objects, etc.
	<li>ZERO overhead of dealing with writing out type information.
      </ul>



Downsides
  <ul>
  <li>Programs run slower due to the run-time overhead of dynamic checks and uncertain layouts.
  <li>You lose the types-as-specifications aspect of types.  Libraries must be typed informally and such types are sloppy.
  <li>Type errors are caught much later, making debugging much more challenging in some cases.
  <li>Freewheeling style bites you for larger apps which don't
	    fit in your mental cache anymore
</ul>

Overall verdict?
      <ul>
	  <li>Dynamically-typed languages tend to be better for small- and perhaps
      medium-scale applications where speed is not critical;
	  <li>they tend to be worse for large-scale
      applications and speed-critical applications.
      </ul>
      
Common properties
<ul>
  <li>They often run in an environment with a top-loop and where the codebase is
      itself a mutable data structure -- can turn a string into new code and run it.
  <li>Dynamically typed languages are often at the forefront of language features: its easy to add new features to them so they have led much of the evolution of PLs (historical examples: Lisp, Smalltalk).
  <li>The modern ones have good foreign function interfaces to C(++) and use C libraries when speed is needed.
</ul>

<h3>The Different Schools of Dynamically-typed Languages</h3>
The non-OO school
<ul>
  <li>Lisp, the original dynamically-typed language, and the related Scheme which is "<code>(add1 Lisp)</code>"
  <li><a
      href="http://en.wikipedia.org/wiki/Scripting_programming_language">Unix scripting
      languages</a>, e.g. sh, csh, bash, awk, tcl, etc. 
  <li>early Perl (pre-5)
</ul>

The "classic" dynamic OO languages
<ul>
  <li>Smalltalk
      aka squeak
  <li>CLOS, the Common Lisp Object System
</ul>


The "modern" school
<ul>
  <li>Perl 5+
  <li><a href="http://docs.python.org/tut/">Python</a>
  <li><a
      href="http://www.ruby-doc.org/docs/ProgrammingRuby/">Ruby</a>
  <li>Javascript
</ul>
<h3>Dynamically typed languages and our <strong>Fb</strong>
series</h3>
<ul>
  <li>Our <strong>FbSRXVOB</strong> mash contains the core features of
      a dynamically typed language.
  <li>We did not cover how run-time type errors lead to exceptions but
      its simple: add a bunch of runtime type error handling rules including
       <table border='0' cellpadding='0' cellspacing='15'>   <tr> <td><strong>(<span 
class="cmtt-10">- </span>Mismatch Bool Left)</strong></td> <td> <table border='0' cellpadding='0' cellspacing='0'> <tr><td align='center'>&nbsp;<span 
class="cmmi-10">e</span>&nbsp;==&gt;&nbsp;<span 
class="cmtt-10">True</span></td></tr> <tr><td><hr noshade size='1'></td></tr> <tr><td align='center'><span 
class="cmmi-10">e</span> <span 
class="cmtt-10">-</span> <span 
class="cmmi-10">e</span><span 
class="cmsy-10">'</span>&nbsp;==&gt;&nbsp;<span 
class="cmtt-10">Raise (#</span><span 
class="cmti-10">TypeMismatch</span> <span 
class="cmmi-10">True</span><span 
class="cmtt-10">)</span></td></tr> </table> </td> </tr>  </table>
etc. 
</ul>
We will now look at some crosscutting aspects of these languages.

<h3>Data Structures</h3>
<ul>
  <li>Lisp: Everything is a List (including your source code!  Great for metaprogramming)
  <li>Smalltalk: Everything is an Object
  <li><a href="https://docs.python.org/3.4/tutorial/datastructures.html#tuples-and-sequences">Python</a>: Lists (which are mutable so also serve as arrays), Sets, Tuples (immutable lists), Dictionaries, Objects (which are dictionaries with sugar on top)
  <li>Ruby: Objects
  <li>Javascript: Objects (Use objects as dictionaries as well)
</ul>

      <h3>Inheritance</h3>
<ul>
  <li>Smalltalk: regular single inheritance
  <li>Python: multiple inheritance (and the associated <a
      href="http://en.wikipedia.org/wiki/Diamond_problem">Diamond
      Problem</a> of course)
  <li>Ruby: single inheritance plus arbitrary <a
      href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/classes.html#UC">mixin
      modules</a> which are basically classic mixins.  Modules are like classes but since these modules are themselves at the top of
      the hierarchy (modules cannot have supermodules) there is no
      dreaded diamond property -- you can only build three of the four
      edges of the diamond.
</ul>




<h3>Higher order functions</h3>
<ul>

 <li>Lisp/Scheme: <code>(lambda (x) ... )</code>
     <ul>
       <li> Lisp was the first language with implemented  higher-order functions
       <li>But, they didn't quite get it right, they used <em>dynamic binding</em> for nonlocal variables which is bone-headed.
     </ul>
  <li>Smalltalk: <a
      href="http://en.wikipedia.org/wiki/Smalltalk#Code_blocks">code
      blocks</a> subsume higher-order functions.
  <li>Ruby: has blocks which are similar to Smalltalk's.
  <li>Python: <a href="http://docs.python.org/3.4/tutorial/controlflow.html#lambda-forms">lambda-forms</a> (but, <a href="http://stackoverflow.com/questions/141642/what-limitations-have-closures-in-python-compared-to-language-x-closures">Pre-3 Python's lambdas don't let you write to nonlocal variables</a>, and you can only put expressions, not commands, in the body)
</ul>

<h3>Flexibility of the notion of object</h3>
<h4>Smalltalk</h4>
      <ul>
	<li>Everything is an object in Smalltalk: Even <a href="http://en.wikipedia.org/wiki/Smalltalk#Control_structures">if-then-else</a> and <code>+</code> are expressed via messaging syntax e.g. <code>if: ... then: .. else: ...</code> is an <code>if:then:else:</code> message
	<li>Global variables are a systemwide dictionary object
	    (a HashMap).
	    <pre>     Smalltalk at: #f put: (Foo new) </pre>
	    adds a new Foo named <code>#f</code> to the globals which
	    is a dictionary affiliated  with object <code>Smalltalk</code>.
	<li>Classes themselves are nothing but atoms in this
	    dictionary -- <code>#Foo</code> in the above case is in
	    <code>Smalltalk</code>.
	<li>Classes are fully objects - they can be passed around as data
	<li>Methods are not first-class in Smalltalk however, they cannot be pulled out of their object.
	<li>Objects are not extensible dynamically so they are weaker than dictionaries.
      </ul>  

<h4>Ruby</h4>
      <ul>
	<li>Classes are objects in Ruby. For example the
	    <code>inherited</code> method 
	    of the class is run when a new subclass is <em>defined</em>.
	<li><code>NilClass</code> is also a class, as in Smalltalk (where it is <code>Nil</code>) 
	<li>There is also a global dictionary in Ruby that contains the defined classes, <code>Objects.constants</code>
	<li>Methods are first-class in Ruby: <a href="http://ruby-doc.org/docs/ProgrammingRuby/html/ref_c_method.html">Example</a>.
	<li>Can add methods to existing objects - <a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/ref_c_object.html#Object.extend">documentation</a>
      </ul>
<h4><a name="python_objects"></a><a href="https://docs.python.org/3.4/tutorial/classes.html#class-definition-syntax">Python</a></h4>
      <ul>
	<li>Objects are extensions of dictionaries in Python.
	<li>Python objects are thus related to our <strong>FbSR</strong> objects in that a record is a restricted dictionary: 
	    <ul>
	      <li><code>self</code> needs to be an explicit parameter on each method, 
	      <li>classes just make dictionaries;
	    </ul>
      <li>Unlike <strong>FbSR</strong>, self-passing upon method invocation is sugared to be implicit: <code>ob.foo()</code> is all that is needed.
      <li>Python also lets you pun between an object view and a class view -- <code>ObsClass.foo(ob)</code> is the same as writing <code>ob.foo()</code> if <code>ObsClass</code> was the class that created <code>ob</code>.
      <li>An <strong>FbSR</strong> view of Python objects will make this more clear:
	  <pre>
Let ObsClass = {
  new =  Function thisclass -> 
	   { x = Ref 0; class = thisclass };  (* the "object" is just the fields and my class *)

  foo = Function thisob -> Function _ -> !(thisob.x) + 1 (* adding one is so much fun! *)
} In

Let ob = (ObsClass.new  ObsClass) In (* object creation -- need to pass class to itself *)
	  (ObsClass.foo ob ());  (* message sending, need to pass object to itself *)
	  (ob.class.foo ob ());  (* message sending starting from ob only, not its class *)
	      </pre>
	  - the last line shows how the sugar <code>ob.foo()</code> can work, the runtime needs to know which class has the methods.
	<li>Classes have only one constructor; write a class method that is a factory if you want to pass an argument.
	<li>Methods are first-class:  <a
      href="https://docs.python.org/3.4/tutorial/classes.html#method-objects">Example</a>.  In the <strong>FbSR</strong> encoding we can get this behavior by <br>
<code>Let rippedOut = ob.class.foo ob In ... rippedOut() ... (* rip out method, now its just a function *) </code>
	<li>Python dictionaries can be dynamically extended -- <a href="http://docs.python.org/3.4/tutorial/classes.html#instance-objects">example</a>.  Our <strong>FbSR</strong> records don't support extension.
      </ul>

<h4>Implementing Object Dispatch</h4>
      <ul>
	<li>In all the dynamic OO languages they are <em>duck typed</em>: if an object has a <code>quack</code> method it should respond to it when sent a <code>quack()</code> message.
	<li>The runtime cannot always put <code>quack</code> method in the same slot in the method table, or it would be too inefficient.  So, some table compression is needed.
	<li>Additionally, you don't even know the names of all the methods since code could be dynamically loaded. Best answer: use the <strong>Flyweight</strong> design pattern and give each new method string a fresh integer to compress names to one word.
	<li>Slowness compared to C++'s simple following of a couple pointers is a big reason for slowness of these languages.
	<li>Java is between C++ and fully dynamic since new classes can be loaded at runtime.
      </ul>
      
<h3>Reflection</h3>
      <ul>
	<li>"Reflection" means given some object at runtime, can you poke around to find its class, methods, etc? 
	<li>  Reflection is easy to do in a dynamically-typed language because the program data structure is always around explicitly at runtime (its also around in Java so reflection also possible there, but the type system gets in the way).
	<li>Another common feature is the ability to <code>eval</code> -- to invoke the compiler/interpreter directly so you can turn a string of Smallktalk/Python/Ruby source into a running program.
      </ul>

Smalltalk
      <ul>
	<li>Can turn a string into a method name to
      invoke.  
	<li>Objects can also <code>become</code> a completely new behavior.
      </ul>
Ruby
      <ul>
	<li> Can turn string into method to invoke -  <a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/ospace.html#S3">documentation</a>
      </ul>
Python
      <ul>
	<li>Can change the class of an object at runtime.
	    Related to <code>become</code> of Smalltalk
      </ul>


<h3>Overloading and shortcut syntax</h3>
<ul>
  <li>Smalltalk: no
  <li>Python: no overloading but has variable-argument functions, implicit values for missing arguments, multiple syntactic conventions for invoking functions.
  <li>Ruby: operators like <code>+</code> can be overloaded since <code>+</code> is "just" a method name.  Methods can't be overloaded.  Similar variable-argument etc niceties of Python.
</ul>

None of these languages has a general pattern matching on data structures (not just strings) like OCaml does; Python 3 adds some.<p>

</div>


<!--#include virtual="/pl/footer.html" -->
