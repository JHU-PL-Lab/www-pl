<html>
<HEAD>
<title>Programming Languages: Compilation by Translation</title>
</HEAD>
<body LINK="#0000FF" VLINK="#800080" bgcolor="#F0FFF0">
<h1><A NAME="xtocid1441469">Compilation by Program Transformation</A></h1>
Goal: understand some of the concepts behind compilation by writing a
high-level transformational compiler.
<ul>
  <li>Compilers are faster than interpreters by several orders of magnitude.
  <li>Probably about 90% of the prodution software running is compiled
  <li>Compilation is a very complex process
  <li>Compilers these days all perform multiple passes on a program
      to get source code to target code.
  <li>Our goal: understand the most basic concepts behind compilation,
      skipping over issues needed to write a fast, efficient compiler.
</ul>
Our compiler: 
<ul>
  <li>Compile <strong>DSR</strong> to a very limited subset of C ("<em>pseudo-assembly</em>")
  <li>Use a series of <em>program transformations</em> to express compilation
  <li>Program transformations map <strong>DSR</strong> programs to
      equivalent <strong>DSR</strong>programs.
  <li> These program
       transformations remove 
       high-level features one at a time:
      <ul>
	<li>Closure conversion
	<li>A-Translation
	<li>Function hoisting
      </ul>
  <li> After transformations, arrive at something very close to assembly language, but still
       in the form of a <strong>DSR</strong> program;
  <li> Lastly, translate the primitive <strong>DSR</strong> program
      directly to C.
</ul>
Real compilers:
<ul>
  <li>Lots of technology for producing efficient code: optimization
  <li>Not so many passes on the program as out compiler
  <li>But, more passes at the lower levels for optimization
  <li>real compilers stop at some third language in the middle:
      three-address code.
  <li>Real languages are huge so the engineering effort is significant.
</ul>

Some points about the approach we will take.

<ul>
  <li> Main goal here is pedagogy: understand the gaps seperating
high- and low-level languages by bridging them one by one.  Each
transformation bridges one gap.
  <li> Program transformations are interesting in their own
right, as they give insights into the <strong>DSR</strong> language.
  <li>Due to lack of time we will give short shrift to optimization,
even though much compiler code is for this purpose.
  <li> 
The SML/NJ ML compiler is in fact implemented as a transformational compiler, so the
methodology here is not purely pedagogical.  
  <li> Our focus is more on higher-order languages, not C/C++; issues
there are somewhat different.
  <li>We will not try to catch run-time type errors or garbage collect
      unused memory.
</ul>

<p>

Desired <strong>Soundness Property</strong> for program translations:
programs before and after translation have the same execution
behavior (in our case, termination and same numerical output, but in
general the same i/o behavior).<p> 


<h2><A NAME="xtocid1022878">The Transformations</A></h2>
The <strong>DSR</strong> transformations are now covered in the order
they are applied to the source program.

<h2><A NAME="xtocid37370">Closure Conversion</A></h2>
<ul>
  <li>Closure conversion is a transformation which gets rid of nonlocal
variables in functions (<code>x</code> in <code>Function y -> x * y</code>
is nonlocal: it is not the parameter and is used in the body).
  <li>In C/C++ there are no nonlocal variables: functions can't be
      nested so variables are either local or global.
  <li>So, closure conversion is not relevant to C/C++ compilation.
      Inner classes have a form of nonlocal variable and
      closure-conversion-like transformation.
  <li><em>After</em> closure conversion the functions will look like
      C/C++ functions: variables are all local
  <li>Functions still could be defined anywhere in the code, so there
      is more work to do on them later. 
</ul>

Consider the example of a curried addition function.
<pre>
add = Function x -> Function y -> x + y
</pre>
In the body <code>x + y</code>, <code>x</code> is nonlocal and
<code>y</code> is local.<p>

What should <code>add 3</code> return?
<ul>
  <li> <code>
Function y -> x + y
</code> would be stupid because the variable <code>x</code> would not
       have a value.
  <li> <code>
Function y -> 3 + y
</code> amounts to a substitution, something a compiler <em>can't do</em> since
compiled code should be fixed (<em>code is not mutable</em>).
</ul><p>

Answer: return a <em>closure</em>, consisting of the function and an
<em>environment</em> which remembers the values of the nonlocal
variables for later use:
<pre>
(Function y -> x + y, { x |-> 3 })
</pre>
Some more structure than this is needed in order for the function to
get its <code>x</code> value when invoked; we cover that next.<p>

<em>Closure conversion</em> is a global program transformation that
explicitly performs this 
operation in the language itself. Core ideas
<ul>
  <li>Function values are not just <code>Function .. </code>, they
      are <em>closures</em>, i.e. tuples of the function and an environment remembering the
      values of nonlocal variables 
  <li>When calling one of these new-style function values,
      <em>explicitly pass it the nonlocals environment</em> which is
      in the closure so it can
      use it to find values of the nonlocals!
</ul>

The translation is introduced by way of example.
<code>add</code> above translates to 
<pre>
add' = { fn = Function xx ->
   { fn = Function yy -> (yy.envt.x) + (yy.arg); envt = { x = xx.arg } };
      envt = {} }
</pre>
Whew!  This is a pretty complicated operation.  Some comments.
<ul>
  <li>Closures we define as tuples in the form of records
      <pre>{ fn = Function ...; envt = {x = ...; ...}}</pre>,
       consisting of the 
       original function (<code>fn</code> field) and the nonlocals
      environment (<code>envt</code> field).
  <li>in the nonlocals environment <code> { x = xx.arg }</code>,
      <code>x</code>  was a nonlocal variable and its value is
      remembered in this record under a label of the same name, <code>x</code>.
  <li> Functions that used to take an argument <code>y</code> are
       modified to take an argument named 
       <code>yy</code> (double up the original
       variable name).  Note we don't really have to change the name
      but it can help save confusion.
  <li> The new arguments <code>yy</code> etc are always expected to
       be records of the form
       <code>{ envt = ..; arg = ..}</code>, passing both the
      environment and the original argument to 
       the function.
  <li> Within the body of the revised function, 
       <ul>
	 <li> <code>yy.envt.x</code> is the new way to access what
	      was a nonlocal variable <code>x</code> in the function
	      body (where the function had parameter previously named
	      <code>y</code>); 
	 <li> <code>yy.arg</code> is the new way to access what was
	      the (single) argument to the function <code>y</code>.
       </ul>
  <li>Note, in <code>{ x = xx.arg }</code>, the left <code>x</code> is a label
and the right <code>xx</code> a variable. 
</ul>
<strong>Translation of function calls</strong><p>

Function call <code>add 3</code> after closure conversion then must <em>pass in the
environment</em> since the caller needs to know it.
<pre>
(add'.fn)({ envt = add'.envt; arg = 3})
</pre>
Translation of <code>add 3 4</code> takes the result of the above, which is 
a function closure <code>{ fn = ...; envt = ... }</code>, and does the
same trick to apply 4 to it:
<pre>
Let add3' = (add'.fn)({ envt = add'.envt; arg = 3}) In
  (add3'.fn)({ envt =  add3'.envt; arg = 4})
</pre>
and the result would be 12, the same as the original result,
confirming the soundness of the translation in this case. 
<p>
In general,
<ul>
  <li> At function call time, the remembered environment in the
      closure is passed to the function in the closure.
  <li>Thus, for the <code>add' 3</code> closure above,
      <code>add3'</code>, when
       it is applied later to e.g. <code>7</code>, the
       <code>envt</code> will know it is <code>3</code> that is to be
       added to <code>7</code>.
</ul>

<strong>One more level of nesting</strong><p>
Well, its even slightly more complicated if we consider one more level
of nesting of functions, for example
<pre>
triadd = Function x -> Function y -> Function z -> x + y + z</pre>
--the <code>z</code> function needs to get the <code>x</code> value,
and since that function is defined in the <code>Function y</code>,
that function has to be an intermediary which passes <code>x</code>.<p>
Here is the translation.
<pre>
triadd' =
  { fn = Function xx ->
    { fn = Function yy -> 
      { fn = Function zz -> (zz.envt.x) + (zz.envt.x)  + (zz.arg);
        envt = { x = yy.envt.x; y = yy.arg } };
      envt = { x = xx.arg } };
    envt = {} }
</pre>
Some observations about this example
<ul>
  <li>The inner <code>z</code> function has nonlocals <code>x</code>
      and <code>y</code> so those need to be in its environment;
  <li>The <code>y</code> function doesn't directly use nonlocals, but
      it has nonlocal <code>x</code> because the function inside it,
      <code>Function z</code>, needs it.  So its envt has
      <code>x</code> in it.
  <li><code>Function z</code> can get <code>x</code> into its
      environment from y's environment, as <code>yy.envt.x</code>.
      This is <code>y</code> being middleman to get <code>x</code> to
      <code>z</code>.  Whew!
</ul>

<h3><A NAME="xtocid37371">The official translation</A></h3>
With that example in mind, we can write out the official closure
conversion translation.  We will use the notation <code>clconv(e)</code>
to express the closure conversion function, defined inductively as 
follows (this code is informal, it uses concrete DSR syntax which
in the case of e.g. records looks like Caml syntax).<p>

<ol>
  <li> <code>clconv(x) = x</code> (* variables *)
  <li> <code>clconv(n) = n</code> (* numbers *)
  <li> <code>clconv(b) = b</code> (* booleans *)
  <li> <code>clconv(Function x -> e) = </code> letting <code>x, x1, ...,
      xn</code> be precisely the free variables in <code>e</code>, the
      result is the <strong>DSR</strong> expression
      <pre>
      { fn = Function xx -> SUB[clconv(e)], 
        envt = { x1 = x1; ...; xn = xn } } </pre>
       where <code>SUB[clconv(e)]</code> is <code>clconv(e)</code> with
      substitutions <code>(xx.envt.x1)/x1,...,(xx.envt.xn)/xn</code>
      and <code>(xx.arg)/x</code> performed on it, but
      <em>not</em> substituting in <code>Function</code>'s inside
      <code>clconv(e)</code> (stop substituting when you hit a <code>Function</code>). 
  <li> <code>clconv(e e') = Let f = clconv(e) In (f.fn){ envt = f.envt;
       arg = clconv(e')}</code> 
  <li> <code>clconv(e op e') = clconv(e) op clconv(e')</code> for all other
       operators in the language (the translation is <em>homormorphic</em> in
       all of the other operators).  This is pretty clear in every
       case except maybe records which we will give just to be sure...
  <li> <code>clconv( { l1 = e1; ...; ln = en } ) = { l1 = clconv(e1);...; ln = clconv(en) }</code>
</ol>

From the above example, <code>clconv(add) = add'</code>.<p>

The desired soundness result is<br>

<strong>Theorem:</strong> <code>e</code> computes to a value if and only if <code>clconv(e)</code>
computes to a value.  Additionally, if one returns numerical value n,
the other returns the same numerical value n.
<p>

This operation results in a language that has no nonlocal variables in
functions, more like the C/C++ languages.  We are getting closer to
machine code.

<h2><A NAME="xtocid37372">The A-translation</A></h2>
<ul>
  <li>Machine language programs are a linear sequence of simple instructions
  <li>The A-translation rephrases expression-based programs to show
      linear order of operations
  <li>Translation does this by using multiple <code>Let</code>
      statements to evaluate expressions in the 
order indicated by the operational semantics.
</ul>
The idea should be self-evident from the case of
arithmetic expressions. 
Consider for instance
<pre>
4 + (2 * (3 + 2))
</pre>
Our interpreter defined a tree-notion of evaluation order on such
expressions. The order in which evaluation happens on this program can be made
explicitly linear by using <code>Let</code> to factor out the parts that are
evaluated first:

<pre>
Let v1 = 3 + 2 In
Let v2 = 2 * v1 In
Let v3 = 4 + v2 In
 v3

</pre>
<ul>
  <li>Notice how similar this is to 3-address machine code: its a
      linear sequence and operations are directly applied to variables
  <li>The <code>v1</code> etc variables are <em>temporaries</em>; in
      machine code they generally end up being registers
  <li>These temporaries are not re-used (re-assigned to) above; its not
      possible in <strong>DSR</strong> but its also how real 3-address
      intermediate language works.  In the final machine code
      generation are temporaries re-used ("register allocation").
  <li> This translation did not
change the meaning of the program
</ul>
<p>
We are in fact going to define a more simple translation, that also
first assigns constants and variables to other variables:
<pre>
Let v1 = 4 In
Let v2 = 2 In
Let v3 = 3 In
Let v4 = 2 In
Let v5 = v3 + v4 In
Let v6 = v2 * v5 In
Let v7 = v1 + v6 In
 v7

</pre>
Some points
<ul>
  <li>This simple translation very closely corresponds to the
operational semantics--every node in a derivation of <code>e |-->
v</code> is a <code>Let</code> in the above (Exercise: write out the
operational semantics derivation and compare).
  <li>
This translation has the advantage that every operation will be
between variables.  In the previous example above, <code>4+v2</code> may not be
low-level enough for some machine languages since there may be no add
immediate instruction.
  <li>
<code>Let</code> is a primitive in <code>DSR</code> -- this is not
strictly necessary, but if <code>Let</code> were defined in terms of
application, the A-translation results would be harder to manipulate.
  <li>
One easy optimization would avoid making fresh variables for constants.
</ul>

Next consider some code with higher-order functions.
<pre>
((Function x -> Function y -> y)(4))(2)
</pre>
the function that <code>2</code> is being applied to first needs to be
computed.  We can make this explicit as well:
<pre>
Let v1 = (Function x -> Function y -> y)(4) In
Let v2 = v1(2) In
 x

</pre>
The A-translation given below does even more linearization on
this example: 
<pre>
Let v1 =
  (Function x ->
     Let v1' = (Function y -> Let v1'' = y in v1'') In v1') In
Let v2 = 4 In
Let v3 = v1 v2 In
Let v4 = 2 In
Let v5 = v3 v4 In
 v5

</pre>

<!-- deal with problem of what to do about variables  -->

Every other evaluation construct can be linearized in this fashion.
Except <code>If</code>:
<pre>
If (3 = x + 2) Then 3 Else 2 * x
</pre>
can be turned into (approximately)
<pre>
Let v1 = x + 2 In
Let v2 = (3 = v1) In
If v2 Then 3 Else Let v1 = 2 * x In v1 
</pre>
but the <code>If</code> still has a branch in it.  <br>
However we 
can implement this simple form of <code>If</code> in machine code as
<pre>
v1 := x + 2
v2 := 3 = v1
BRANCH v2, L2
L1: v3 := 3
GOTO L3
L2: v4 := 4
L3:
</pre>
So, this form is quite close to machine code.<p>

We will  give the A-translation the core <strong>DSR</strong> syntax.<br>

The intermediate result of the translation is a list of tuples
<pre>
[(v1,e1); ...; (vn,en)] : (ide * term) list
</pre>
which is intended to represent
<pre>
Let v1 = e1 In .. In Let vn = en In vn ...
</pre>
but is a form easier to manipulate in Caml since lists of declarations will be
appended together at translation time. In your compilers, you may or
may not want to use this intermediate form, it is not much harder to
write the functions to work directly on the <code>Let</code>
representation. 
<p>

<h3><A NAME="xtocid1022882">The Official A-translation</A></h3>
We define the A-translation as a Caml function,
<code>atrans(e) : term -> term</code>.  We will always apply A-translation to the
result of closure conversion, but we really don't need to be aware of
that now.  We now sketch the translation for the core
primitives.<p>

We assume auxiliary functions:
<ul>
  <li>  <code>newid()</code> which returns a
fresh <strong>DSR</strong> variable every time called, 
  <li> the function <code>letize</code> 
which converts from the list-of-tuples form to the actual <code>Let</code> form,
and 
  <li> <code>resultId</code> which for list
<code>[(v1,e1); ...; (vn,en)]</code> returns result identifier <code>vn</code>.
</ul>
<pre>
let atrans e = letize (atrans0 e)

and atrans0(e) = match e with
    (Var x)  -> [(newid(),Var x)] |
    (Int n)  -> [(newid(),Int n)] |
    (Bool b) -> [(newid(),Bool b)] |
    Function(x,e) -> [(newid(),Function(x,atrans e)] |
    Appl(e,e') -> let a = atrans0 e in let a' = atrans0 e' in
                           a @ a' @ [(newid(),Appl(resultId a,resultId a')] |
    ...
   (* all other D binary operators + - = AND etc of form identical to Appl *)
    ...
    If(e1,e2,e3) -> let a1 = atrans0 e1 in
               a1 @ [(newid();If(resultId a1,atrans e2,atrans e3)] |
    ...
</pre>


At the end of the A-translation, the code is all "linear" in the way
it runs in the interpreter, not as a tree.  <br>
Machine code is also linearly ordered; we are getting much closer to
machine code.
<p>

<strong>Theorem:</strong> The A translation is sound, i.e. <code>e</code>
and  <code>atrans(e)</code> both either compute to values or both diverge.

<h3><A NAME="xtocid37373">The A-Translation for the full DSR language</A></h3>

The extra syntax of <strong>DSR</strong> (records, reference cells) does not
provide any major complication for the A-translation. 
<p>

<!--
<pre&&&
let atrans0(Var x) = [(newid(),Var x)] |
    ...
    atrans0(Raise(xn,e)) = let a = atrans0 e in a @ [(newid(),Raise(xn,resultId a)] |
    atrans0(Handle(e,xn,ide,e')) =
          let a0 = atrans0 e in val e0' = atrans e' in val x = newid() in
            a0 @ [(newid(),Handle(resultId a0,xn,ide,e0')]
</pre&&&                          
-->

<h2><A NAME="xtocid388281">Function hoisting</A></h2>

So far, the compiler has performed closure
conversion and A-translation in turn:
<pre>let intermedresult e = atrans(clconv(e))</pre>  

<ul>
  <li>Functions now have no nonlocal variables
  <li>So, we can now <em>hoist</em> all
functions in the program body to the start of the program
  <li>This makes a
C-esque program structure. 
  <li>The leftover code is then made into the <code>main</code> function.
  <li>This transformation is done by the <code>hoist</code> function.
</ul>
Informally, the operation is quite simple: take e.g. 

<pre>
4 + (Function x -> x + 1)(4)
</pre>
and replace it by
<pre>
Let f1 = Function x -> x + 1 In 4 + f1(4)
</pre>
--in general, hoist all functions to the front of the code and give
them a name via <code>Let</code>.<br>
The transformation is always sound if there are no free variables in
the function body, a property guaranteed by closure conversion.

<p>
We will define this process in a simple iterative (but inefficient)
manner:<p>

<blockquote><code>let hoist e =</code>
<br>
<code>if</code> <code>e = e1[(Function ea -> e')/f]</code> for some
<code>e1</code> with  
<code>f</code> free in it, and <code>e'</code> contains no functions
(i.e. <code>Function ea -> e'</code> is an innermost
function)<br>
<code>then</code>
<code>Let f = (Function ea -> e') In hoist(e1)</code><br>
<code>else</code> <code>e</code>.
</blockquote>
<ul>
  <li>If functions are not hoisted out innermost-first, then there will
still be some nested functions in the hoisted definitions.  So, the
order of hoisting is important.
  <li>You don't want to implement hoisting as sketched above -- its
      too inefficient.  Instead, do it all in one pass through the
      program, accumulating a list of the functions and replacing them
      by variables as you go.

</ul>
Resulting programs will be of the form
<pre>
Let f1 = Function ea -> e1 In
       ...
    fn = Function ea -> en In
  e

</pre>
Where each <code>e1,...,en,e</code> contain no function constants.
<p>

<strong>Theorem:</strong> <code>e</code> computes to a value if and
only if <code>hoist(e)</code> computes to a value.  <p>
This Theorem is easily proved from iterative application of the following Lemma<p>

<strong>Lemma:</strong>
<code> (e1[(Function ea -> e')/f])  ~= (Let f = (Function ea -> e') In e1)</code>
<p>

We lastly transform the program to 
<pre>
Let f1 = Function x1ea -> e1 In
       ...
    fn = Function -> Function xnea -> en In
    main = Function dummy -> e In
    main(anything)

</pre>
So, the program is officially nothing but a collection of functions.
This brings the program closer to the form of a C program.

<h2><A NAME="xtocid388282">Final C translation</A></h2>
To summarize up to now, we have
<pre>let frontend e =  hoist(atrans(clconv(e)))</pre> 
<ul>
  <li>We have done about all the translation that is possible within the
language.  
  <li>Programs at this point can be viewed as a collection of
      functions including a distinguished <code>main</code> function
  <li>Each function consists of a linear sequence of atomic operations (with
      exception of <code>If</code> which is a branch).  
</ul>
The translation outline:
<ul>
  <li> Map each function to a C function 
  <li>for each function body, map each atomic tuple to a primitive C
statement.
</ul>
<h4>The atomic tuples we have now</h4>
Before giving the translation, we enumerate all possible right-hand
sides of <code>Let</code> variable assignments that come out of the
A-translation (in the following <code>vi, vj, vk, f</code> are variables).
<strong>Fact:</strong> DSR programs that have passed through the first
three phases should have function bodies consisting of tuple lists
where each tuple is of one of the following forms only:
<ol>
  <li> <code>x</code> for variable <code>x</code>
  <li> <code>n</code> for number <code>n</code>
  <li> <code>b</code> for boolean <code>b</code>
  <li> <code>vi vj</code> (application)
  <li> <code>vj + vk</code>
  <li> <code>vj - vk</code>
  <li> <code>vj And vk</code>
  <li> <code>vj Or vk</code>
  <li> <code>Not vj</code>
  <li> <code>vj = vk</code>
  <li> <code>Ref vj</code>
  <li> <code>vj := vk</code>
  <li> <code>!vj</code>
  <li> <code>{ l1 = v1; ... ; ln = vn }</code>
  <li> <code>vi.l</code>
  <li> <code>If vi Then tuples1 Else tuples2</code> <br>
where <code>tuples1</code> and <code>tuples2</code> are the lists of
variable assigments for the <code>Then</code> and <code>Else</code>
bodies. 
</ol>


<ul>
  <li> Functions and LetRecs all should have been hoisted to the top
so there will be none of those in the tuples.
  <li>Observe that some of the records/selections are from the original
      program, and others are the ones we created ourselves by closure
      conversion.  Who cares, they are all the same now.
</ul>
All we need to do now is generate code for each of the above
tuples.
<h3><A NAME="xtocid388283">Memory Layout</A></h3>
Before writing any compiler, you should always design the memory layout
scheme for objects at run-time.
<ul>
  <li>Every compiler has to have a firm convention for memory layout.
  <li> It is extremely important to
carefully design the strategy beforehand.
  <li>Simple compilers use simple schemes, but for efficiency it is better
to use a more complex scheme.
<p>
</ul>
Lets consider briefly how memory is laid out in C.<br>

Values can be stored in a couple different ways:
<ul>
  <li>In registers. 
      <ul>
	<li> These must be temporary, as registers are generally local
      to each function/method.  
	<li>Also they are only one word in size
      (or a couple words, for floats) so can't directly hold arrays, etc.
      </ul>
  <li>On the run-time stack in the function's <em>activation record</em>.  
      <ul>
	<li>The value is then referenced as the memory
      location at some fixed offset from the stack pointer (which is
      in a register)
	<li> Here is some C-ish code to give you the idea of how the
	    stack pointer <code>sp</code> is used
      <pre>
      { register int sp; /* compiler will assign sp to a register */
        *(sp - 5) = 33;
        printf(*(sp - 5));
      }      </pre>
	<li>
      Stack-stored entities are also temporary in that they will be
      junk when the function/method returns.
      </ul>
  <li>In fixed memory locations (globals).  
  <li>In dynamically allocated (malloc'ed) memory locations (on the heap).
</ul>

An important issue is whether to <em>box</em> or <em>unbox</em> various values.<p>


<strong>Definition. </strong>A register/memory location
<code>vi</code>'s value is stored <em>boxed</em> if <code>vi</code>
holds a pointer to a block of memory containing the actual value.<br>
A variable's value is <em>unboxed</em> if it is directly in the
register/memory location <code>vi</code>.
<p> For multi-word
entities, storing them unboxed means variables directly hold a pointer
to the first word of the sequence of space.
<p>

Here is C's memory layout convention:
<ul>
  <li>Variables may be declared either as globals, register (the
      register directive is a request to put in a register only), or on
      the call stack (all variables declared inside a function are kept on the stack).
  <li>Variables directly holding ints, floats, structs, and arrays are
      all unboxed <br>
(examples: <code>int x; float x; int arr[10]; snork
      x</code> for <code>snork</code> a <code>struct</code>.)
  <li>There is no such thing as a variable directly holding a
      function; variables in C may only hold pointers to functions.
      Variables in C are all mutable, and code resides in a read-only
      section of memory and so its fundamentally impossible to store
      functions unboxed in C.
      It is possible to write "<code>v = f</code>" in C for f a
      previously declared function and not
      "<code>v = &f</code>", but that is because the former is really
      syntactic sugar for the latter.  A pointer to a function is in
      fact a pointer to the start of the code of the function.
  <li>Boxed variables in C are declared explicitly, as pointer variables:<br>
(examples: <code>int *x; float *x; int *arr[10]; snork
      *x</code> for <code>snork</code> a <code>struct</code>.)
  <li>All malloc'ed structures must be stored in a pointer variable
      because they are boxed: variables can't 
      directly be heap entities.  Variables are static and the heap is dynamic.
</ul>
Here is an example of a stupid C program and the SPARC assembly output
which gives some impressionistic idea of these concepts:
<pre>int glob;
main()
{
	int x;
        register int reg;
	int* mall;
	int arr[10];

	x = glob + 1;
	reg = x;
	mall = (int *) malloc(1);
	x = *mall;
	arr[2] = 4;
/*	arr = arr2; -- illegal in C -- arrays not boxed so can't do this */
}
</pre>
Assembly (<code>%o1</code> is a register, <code>[%o0]</code> means
dereference, <code>[%fp-24]</code> means subtract 24 from frame
pointer register <code>%fp</code>and dereference)
<pre>main:
	sethi	%hi(glob), %o1
	or	%o1, %lo(glob), %o0 /* load global address glob into %o0 */
	ld	[%o0], %o1  /* dereference */
	add	%o1, 1, %o0 /* increment */
	st	%o0, [%fp-20] /* store in [%fp-20], the memory 20 back from fp -- this is x */
                              /* note x directly contains a number, not a ptr */
	ld	[%fp-20], %l0 /* %l0 IS reg (its in a register directly) */
	mov	1, %o0
	call	malloc, 0 /* call malloc.  resulting address to %o0 */
	 nop
	st	%o0, [%fp-24] /* put newspace location in mall ([%fp-24]) */
	ld	[%fp-24], %o0 /* load mall into %o0 */
	ld	[%o0], %o1 /* this is a malloced structure -- UNBOX! */
	st	%o1, [%fp-20] /* store into x */
	mov	4, %o0
	st	%o0, [%fp-56] /* array is directly a sequence of memory on stack - no indirection needed */
.LL2:
	ret
	restore
</pre>
<strong>Memory layout for our compilers</strong><p>
<ul>
  <li>DSR is higher-level than C, there is no direct declaration of
      whether values will be boxed or unboxed
  <li>We will use a simple, uniform scheme in our compilers: 
<ul>
  <li>Box refs and records and function values
  <li> Keep bools and ints unboxed
</ul></ul>
Aside: Java memory layout
<ul>
  <li>All object references are boxed pointers to heap locations
  <li>primitive int and bool and float types are unboxed
</ul>
<p>
Observations:
<ul>
  <li><code>ref</code>s must be boxed to be heap-allocated since they can be referred to after a
      function returns:
      <pre>Let f = (Function x -> Ref 5) In !f(_) + 1</pre>
      --if 5 were stored on the stack, after the return it could be
      wiped out.
  <li>All of the <code>Let</code>-defined entities in our tuples (the
      <code>vi</code>) can
      be either in registers or on the call stack:
      <ul>
	<li>none of those variables are directly used outside the function due
	    to lexical scoping;
	<li>They don't directly contain values that should stay alive
	    after the fucntion returns
	<li>For efficiency, declare all of them as <code>register
	    Word</code> variables:
	    <pre>register Word v1, v2, v3, v4, ... ;</pre>
      </ul>
  <li>Boxed values will almost always be larger than one word (our one
exception is we box references and they, as pointers, are only one
word).  
  <li>But, under this simple scheme means every variable is a 1-word
      assignment.  
  <li> This scheme is not very efficient, and real compilers optimize significantly.
</ul>
All that remains is to come up with a scheme to compile each
of the above <em>atomic tuples</em> and we are done.  Records are the
most difficult so we will consider them before writing out the full
translation.  

<h4><A NAME="xtocid388284">Compiling untyped records</A></h4>

<ul>
  <li>Recall from when we covered records that the fields present in a
      record cannot be known in advance if there is no type system
  <li>Consider for example
      <pre>
      (Function x -> x.l)(If y = 0 Then {l = 3} Else {a = 4; l = 3})
      </pre>
      --field <code>l</code> will be in two different positions in these
      records so the selection will not know where to look.
  <li>Thus we will need to use a hashtable for record lookup
  <li>In a typed language such as ML this problem is avoided: the
      above code is not well-typed in ML because the if-then can't be typed.
  <li>Note that the problems with records are closely related to problems
with objects: <strong>Objects = records + refs</strong>.

</ul>

<strong>Aside:</strong> This brings out some important properties of typing and compilation
<ul>
  <li> Types are important for compilers as well as
programmers!
  <li> Our compilers are going to core dump on e.g.  <code>4
      (5)</code>; 
  <li>in Lisp/Smalltalk/Scheme these errors would be
      caught at run-time but would slow down execution; 
  <li>in a typed
      language, the compiler would throw out the program 
  <li>Thus for typed languages they will both be faster and safer.
</ul>


<strong>Our Records Compilation</strong><p>

<ul>
  <li>We must give records
a heavy implementation, as <em>hash tables</em> (i.e., a set of
      key-value pairs, where the keys are label names). 
  <li>In order to make the implementation simple, records are boxed so
      they take one word of memory (as mentioned above when we covered boxing)
  <li>A record selection operation <code>vk.l</code> is implemented by hashing on key
      "l" in the hashtable <code>vk</code> points to (at <em>run-time</em>). 
  <li>This is also pretty much how Smalltalk message send is implemented,
      since records are similar to objects and Smalltalk is untyped.
</ul>
The above is less than optimal because
<ul>
  <li> Space will be needed for the hashtable;
  <li> Record field accessing will be <em>much</em> slower than e.g. struct
      access in C.
  <li>Since closures are records, this will also
significantly slow down function call.  A simple optimization would be to
treat closure records specially since the field positions will always
be fixed, and use a struct implemetation (create a different
<code>struct</code> type for each function).
</ul>
<p>

For instance,
<pre>
(Function x -> x.l)(If y = 0 Then {l = 3} Else {a = 4; l = 3})
</pre>
the code <code>x.l</code> will invoke a call of approximate form
<code>hashlookup(x,"l")</code>.  <code>{a = 4; l = 3}</code> will create a
new hash table and add mappings of <code>"a"</code> to 4 and <code>"l"</code> to 3.

<h3><A NAME="xtocid388285">The translation</A></h3>
We are now ready to write the final translation to C, via functions
<ul>
  <li><code>toCTuple</code> mapping an atomic tuple to a C statement string, 
  <li><code>toCTuples</code> mapping a list of tuples to C statements,
  <li><code>toCFunction</code> mapping a primitive DSR function to a
      string defining a C function,
  <li><code>toC</code> mapping a list of prmitive DSR functions to a
      string of C functions.
</ul>  <p>
The translation as informally written below takes a few liberties for simplicity.
<ul>
  <li> Strings <code>"..."</code> below are sloppily written, for
      instance <code>"vi = x"</code>
      is sloppy shorthand for <code>tostring(vi) ^
      " = " ^ tostring(x)</code>
  <li> The tuples <code>Let x1 = e1 In Let ... In Let xn = en In xn
      </code> of function and then/else bodies are assumed to have
       been converted to lists of tuples
       <code>[(x1,e1),...,(xn,en)]</code>, and 
       similarly for the list of top-level function definitions. In
       your compilers, it probably will be easier just to keep them in
       <code>Let</code> form, but the choice is yours.
</ul>
<pre>
    toCTuple(vi = x) =           "vi = x;" (* x is a DSR variable *)
    toCTuple(vi = n) =           "vi = n;"
    toCTuple(vi = b) =           "vi = b;"
    toCTuple(vi = vj + vk) =     "vi = vj + vk;"
    toCTuple(vi = vj - vk) =     "vi = vj - vk;"
    toCTuple(vi = vj And vk ) =  "vi = vj && vk;"
    toCTuple(vi = vj Or vk ) =   "vi = vj || vk;"
    toCTuple(vi = Not vj ) =     "vi = !vj;"
    toCTuple(vi = vj = vk) =     "vi = (vj == vk);"
    toCTuple(vi = (vj vk) =      "vi = *vj(vk);"
    toCTuple(vi = Ref vj) =      "vi = malloc(WORDSIZE); *vi = vj;"
    toCTuple(vi = vj := vk) =    "vi = *vj = vk;"
    toCTuple(vi = !vj) =         "vi = *vj;"
    toCTuple(vi = { l1 = v1; ... ; ln = vn }) =
             /* 1. malloc a new hashtable at vi
                2. add mappings l1 -> v1 , ... , ln -> vn  */

    toCTuple(vi = vj.l) =        "vi = hashlookup(vj,"l");"
    toCTuple(vi = If vj Then tuples1 Else tuples2) =

              "if (vj) { toCTuples(tuples1) } else { toCTuples(tuples2) };"

    toCtuples([]) = ""
    toCtuples(tuple::tuples) = toCtuple(tuple) ^ toCtuples(tuples)

    toCFunction(f = Function xx -> tuples) =
                  "Word f(Word xx) {" ^ ... declare temporaries ...
                     toCtuples(tuples) ^
                     "return(resultId tuples); };"

    toCFunctions([]) = ""
    toCFunctions(Functiontuple::Functiontuples) = toCFunction(Functiontuple) ^ toCFunctions(Functiontuples)

    toC then invokes toCFunctions on its list of functions.
</pre>
<strong>Question:</strong> why is a fresh memory location malloc'ed
for a <code>Ref</code>??  This is a subtle issue, but the code
<code>vi = &vj</code> would definately not work for the
<code>Ref</code> case.<p>

This translation sketch above leaves out many details.  Here is some
elaboration.
<p>
For <strong>typing</strong>
<ul>
  <li>We designed out memory layout so that every entity takes up one
      word.  So, every variable is of some type that is one word in size.
   <li> Type all variables as 
       <code>Word</code>'s, where <code>Word</code> is a 1-word type
       (defined as e.g. <code>typedef Word char *</code>). 
  <li> Many type casts need to be inserted; we are basically turning off
       the type-checking of C, but there is no "switch" that can be
       flicked. 
  <li>So for instance <code>vi = vj + vk</code> will really
      be <code>vi = (Word (int vj) + (int vk))</code> -- cast the
       words to ints, do the addition, and cast back to a word.
 <li> To cast to a function pointer is a tongue-twister: in C you
       can use <code>(*((Word (*)()) f))(arg)</code>.        
</ul>
Some <strong>global issues</strong> you will need to deal with
<ul>
  <li>You will need to print out the result returned by the
      <code>main</code> function (so, you probably want the DSR main
      function to be called something like <code>DSRmain</code> and
      then write your own <code>main()</code> by hand which will call
      <code>DSRmain</code>);
 <li> The C functions need to declare all the temporary variables
       they use.  One solution is to declare in the function header a
       C array 
       <pre>Word v[22]</pre>  where 22 is the number of temporaries
       needed in 
       this 
       particular function, and use names <code>v[0], v[1],</code> etc
      for the temporaries.  Note, this works well only if
       the <code>newid()</code> function is instructed to start
       numbering temporaries at zero again upon compiling each new
       function. 
 <li>Every compiled program is going to have to come with a standard
     block of C code in the header, including the record hash
     implementation, <code>main()</code> as alluded to above, etc.
     
</ul>
Other subtle points.
<ul>
  <li>Record creation is only sketched; but there are many C hash set
      libraries you can reuse if you like.
  <li>  The final result (<code>resultId</code>) of the
       <code>Then</code> and <code>Else</code> 
        tuples needs to be in the <em>same</em> variable
      <code>vi</code>, which is also the variable where the result of
      the tuple is put,  for the
       <code>If</code> code to be correct; your A-translation should
       put <code>If</code> tuples in this form to make this phase
      correct so go back and patch it.
</ul>

<h3><A NAME="xtocid652586">Compilation to Assembly code</A></h3> This
C code is very close to assembly code.  It would be conceptually easy
to translate into assembly, but we skip the topic due to the large
number of cases that arise in the process (saving registers,
allocating space on the stack for temporaries.

<h2><A NAME="xtocid652587">Summary</A></h2>

<pre>
let frontend e =  hoist(atrans(clconv(e)));;
let translator e = toC(frontend(e));;
</pre>

We can assert the correctness of our translator.
<strong>Assert:</strong> <code>DSR</code> program <code>e</code>
terminates in the <strong>DSR</strong> operational semantics (or
evaluator) just when the C program <code>translator(e)</code>
terminates, provided the C program does not run out of memory. Core
dump or other run-time errors are equated with nontermination.
Furthermore, if DSR's <code>eval(e)</code> returns a number
<code>n</code>, the compiled <code>translator(e)</code> will also
produce numerical output <code>n</code>. <p>

<h2><A NAME="xtocid388286">Optimization</A></h2>

Optimization can be done at all phases of the translation process.
The above translation is embarrasingly inefficient.
In the phases before C code is produced, optimizations consist of
replacing chunks of the program with operationally equivalent chunks.
<p>

Some simple optimizations include
<ul>
  <li> Implement the special closure records <code>{fn = .., envt = .. }</code>
       as a pointer to a C <code>struct</code> with <code>fn</code>
       and <code>envt</code> fields, instead of using the very slow
       hash method.   Records which do not not have field names
       overlapping with other records can also be implemented in this
       manner (there can be two different records with the same
       fields, but not two different records with some fields the same
       and some different).
  <li> Modify the A-translation to avoid making tuples for variables
       and constants.
  <li> Fold together constant expressions such as <code>3 + 4</code>.
</ul>

More fancy optimizations require a global <em>flow analysis</em> be
performed.  Simply put, a flow analysis finds all possible
<em>uses</em> of a particular definition, and all possible
<em>definitions</em> corresponding to a particular use.  <br>
A definition
is a record, a <code>Function</code>, or a number or boolean, and a use is a
record field selection, function application, or numerical or boolean
operator.<p>

<!-- give example of use of flow information here -->

<h2><A NAME="xtocid652589">Garbage Collection</A></h2>
Our compiled code malloc's but never frees.  We will eventually run
out of memory.  A garbage collector is needed.<p>

<strong>Definition:</strong> In a run-time image, memory location n is
<em>garbage</em> if it never will be read or written to again.<p>

There are many notions of garbage detection.  The most common is to
be somewhat more conservative and take garbage to be memory locations
which are not pointed to by any known ("root") object.

<p>
<!-- hhmts start -->
Last modified: Fri Apr  5 14:25:20 EST 2002
<!-- hhmts end -->
</body></html>


