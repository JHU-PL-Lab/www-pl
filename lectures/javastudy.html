<HTML> <HEAD> <TITLE>Study of Java</TITLE> </HEAD>
<body LINK="#0000FF" VLINK="#800080" bgcolor="#F0FFF0">
<h2>Study of Java</h2>
Our reference here  is  the <a
href="http://java.sun.com/docs/books/jls/third_edition/html/j3TOC.html">Java
Language Specification, 3rd Edition</a>.  Part of the goal of this
lecture is for  you  to gain expertise in "spec reading". Some of the examples below
are  taken from the Java spec.
<h3><a href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.10">Subtyping</a></h3>
<ul>
  <li>Must be declared via extends/implements, except for primitive type subtyping
  <li>Used to be there  was no "deep" subtyping on objects, but now
      you can also refine the type in a subclass - <a href="http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.4.8.3">see here</a>.<br>
 - former is our record subtyping rule where type components must  be
      SAME; now they support some aspects of our rule.
  <li>Still, all subtype relationships must  be declared as mentioned
      in the first bullet; in <strong>STFb</strong> subtyping only
      depended on the structure of the underlying records.
      <strong>STFb</strong> subtyping is thus <em>purely
      structural</em> and Java's is not.
  <li>Summary: <strong>STFb</strong> is more expressive but Java's is
      easier to use due to names being given.
</ul>
<h3><a href="http://java.sun.com/docs/books/jls/third_edition/html/classes.html#295574">Inner Classes</a></h3>
Lets start with reviewing what <strong>FbOB</strong> had in this area:
<ul>
  
  <li>In <strong>FbOB</strong> we had the ability to declare classes
      anywhere, including inside  other  class methods, etc.  Those
      classes could  also be returned as result values of methods, to  
      be <code>new</code>-ed in a completely different context.
  <li><strong>FbOB</strong> also has  syntax for directly defining
      objects: <code>Object Inst ... Meth ..</code>.
  <li>In general, this is an example of <em>fully higher-order</em>
      classes and objects -- no restrictions on where they can be
      defined, used or passed to.
</ul>
Java inner classes give much but not all of the <strong>FbOB</strong> functionality.
<ul>
  <li>They do allow local classes to be defined just about anywhere.
  <li>They do support something similar to the <code>Object</code>
      syntax of  <strong>FbOB</strong> (and the blocks of Smalltalk and
      the ..), via anonymous local classes which are  immediately  <code>new</code>-ed.
  <li>They do support multiple levels of nesting: inner classes  can
      have inner classes insde  them.
  <li>The main lack is the ability for classes to be passed around as
      data items, e.g. methods  returning classes.
  <li>The JVM is  not "aware" of inner classes, they are implemented
      as regular classes with mangled names like <code>Foo$1Boo</code> for
      an inner class <code>Boo</code> inside  <code>Boo</code>.
</ul>
We will go through the inner classes specification and look at some of
      the crufty issues, e.g.
<ul>
  <li>How  fields in the parent objects  can be accessed
  <li>How static fields in a superclass of an inner class may not be extended
</ul>
<h3><a href="http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.1.2">Generics</a></h3>
Generics are Java's version of parametric types.  These notes assume
      familiarity with them; read a <a
      href="http://java.sun.com/docs/books/tutorial/extra/generics/index.html">tutorial</a>
      if you are not.  Here are some
      comparisons with the Caml-style parametric types that we  studied:
<ul>
  <li>Caml infers generic types <code>'a</code> automatically; in Java, you must
      declare them as <code>&lt;T&gt;</code>.
  <li>Java generics have some features not found in Caml due to the
      combination of polymorphism and subtyping.
</ul>
<h4>Bounded subtyping</h4>
<ul>
  <li>Recall with generics you cannot  have <code>List&lt;String>
      &lt;: List&lt;Object></code> kinds of things (see <a
      href="http://java.sun.com/docs/books/tutorial/extra/generics/subtype.html">here</a>
      for description)
  <li>The root of this  in subtpying theory is that
      <code>String/Object</code> may occur both positively and
      negatively  in <code>List</code>'s signature, so it needs to be
      invariant.
  <li>In <strong>STFb</strong> we could in fact have such subtypings
      holding for the case they were positive  only -- imagine some
      list which you could only get the head of, nothing else:
      <pre>{ head : {} -> String } &lt;: { head : {} -> Object }
      </pre>
      would be a legal subtyping in our <strong>STFb</strong> rules
      assuming <code>String &lt;: Object</code>. But a full list type
      would be at least like 
 <pre>{ add: String -> {}; head : {} -> String } &lt;: { add: Object -> {}; head : {} -> Object }
      </pre>
and this relation fails because it also requires <code>Object &lt;:
      String</code> due to the <code>add</code> parameter.  Java is
      basically assuming that <code>List<T></code> will have
      <code>T</code> both as argument and return type of methods  and
      so always forces invariance here.  But, we know you can do
      better than that.
</ul>      

To get around this  weakness, Java 5 adds <em>bounded subtyping</em>
  <ul>
    <li>In generics  you can write things like <code>&lt;T extends C &amp; I&gt; void test(T t) </code>
  <li>the "<code>extends C &amp; I</code>" means <code>T</code> can be
      any type which extends both class <code>C</code> and interface
      <code>I</code>.  
  <li>In other words, <code>T &lt;: C</code> and  <code>T &lt;:
      I</code> in our subtyping terminology.
  <li>This adds more flexibility, <code>T</code> need not be any type,
  but from a restricted range of types which gives added flexibility later.
  <li>Our constraint-based
      <strong>CFbR</strong> with let-polymorphism also allows such
      sorts of types to be expressed:
     <pre> test : 'a -> void \ { 'a <: C, 'a <: I }</pre>
  <li>Java also allows type variable wildcards, <code>?</code> - this is
      a form of <em>existential type</em> -- the typing  holds  for
  <em>some</em> <code>?</code>.
</ul>


<h3><a href="http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.4.9">Method Overloading</a></h3>
The take-home message here is brief:
<ul>
  <li> Java method  overloading can be
  viewed as concatenating all of the argument types onto the method
  name. 
  <li>So it is really  just a simple  form of  sugar. 
  <li>We will briefly look at the examples in the above  spec.
</ul>
<h3><a href="http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.8.7">Constructors</a></h3>
<ul>
  <li>Java constructors are not that different  from the encoding of
  constructors that we covered <a
  href="http://www.cs.jhu.edu/~scott/plbook/book/html/mainli1.html#QQ2-10-97">in
  the book</a> - various convenient sugar is added.
  <li>Java by default inserts <code>super();</code> in front of the
  constructor if  another constructor is not invoked at  the  start; this  is a bit of a
  hack. 
  <li>There is a default constructor w/ body <code>super();</code> if none is declared.
  <li>Inner classs and generics add a whole load of complications to constructors.
</ul>

<h3>Immutable Data</h3>
One  of the key lessons  of Caml is  the importance of known immutable
data: it has universal meaning.<p>
<ul>
  <li>Java allows fields to not mutate if qualified with <code>final</code>.
  <li>Caml analogy: a <code>let</code>-defined variable.
  <li>Like Caml, immutability is only shallow - the field could
      contain <em>components</em> that mutate.
</ul>

<h3>Public/Private/package protected/Protected</h3>
Compare this with Caml modules.
<ul>
  <li>Caml allows arbitrary multiple views of the same module
      (different things seen by different code given the same module)
  <li>Java has 
      fixed forms of multiple view: subclasses may see more
      (protected) and within vs without a package may see more
      (package protected)
  <li>Caml is more flexible, but Java approach is simpler (on the
      surface at least).
</ul>
<h3>Concurrency</h3>
See the <a href="concurrency.html#java">concurrency lecture notes</a> for this topic.

<h3>Other issues of comparison between Java and Caml / Fb family of languages</h3>
<ul>
  <li>Variant types analogue -- used to not exist but now there are enums
      at least; "use inheritance instead"
  <li>Inference -- generally types are declared; avoids all the
      glitches in the OCaml design to support inference but requires
      more programmer typing.
  <li>Exceptions -- same
</ul>



<br>
<hr>
<address></address>
<!-- hhmts start -->
Last modified: Mon Apr 20 13:29:14 EDT 2009
<!-- hhmts end -->
</BODY> </html>

