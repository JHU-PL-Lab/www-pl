<!--#include virtual="/pl/header.html" -->

</div>

<div id="content"> <h2>Study of C++</h2>

<h3>Explicit Memory Model</h3>
Both C and C++ have an explicit memory model which exposes the pointer
structure to the programmer:
<ul>
  <li>variables that are not pointers are either global or on the stack, and can be accessed without going through a reference of a memory location -- fast
  <li>can take the addess-of (&amp;) one of these variables to conjure a pointer
      to it;
  <li>arrays can access data out of their bounds;
  <li>dynamic allocation via <code>new</code> allocates space on a heap and returns a pointer to it; it must be manually <code>delete</code>'d.
  <li>pointers that have what they point to may have been deallocated
      and reused by someone else by mistake
  <li>deallocation can occur both by explicit <code>delete</code> of heap data and by implicit deallocation of stack data upon return from a function call (even though there still may be a pointer to the datum)
</ul>
Pluses and minuses of explicit memory
<ul>
  <li>Explicit memory accounts for a good fraction of the bugs in C/C++ programs.
  <li>Most more recent languages (Java, Ruby, Python, OCaml, etc) use an
  <em>implicit</em> memory model to avoid these bugs<br>
 -- Implicit memory has no ability to take address-of, memory
  allocation is implicit, and memory is implicitly deleted by a garbage collector
  <li>But code can be less efficient with an implicit memory since one more memory access is often needed when accessing the contents
  <li>But but compilers keep getting better and are slowly closing the gap
  <li>But but but low-level systems programs such as operating systems
  kernels and device drivers need the explicit memory model so there
  will always be a need for some explicit memory
</ul>
In this course we pretty much stuck to the implicit memory view throughout because it is becoming more and  more prevalent in code, but it will never be irrelevant.
<h3>Multiple Inheritance - good and bad</h3>
<ul>
  <li>Multiple inheritance is great: it amounts to being able to define fields and method bodies on your interfaces
  <li>The major technical  hiccup is <a
href="http://en.wikipedia.org/wiki/Diamond_problem">The Diamond
Problem</a>.  Blech! 
      <ul>
	<li>Basic solution in most languages is to have one copy of the super-super but make a priority order on when classes were defined in terms of whose copy "wins".
	<li>In C++ you need to use the keyword <code>virtual</code> on inheritance to get this behavior, otherwise you just get two copies of the super-super.
	<li>Even without this very messy problem there still is an issue of what to do when two superclasses define a method of the same name.
      </ul>  <li>In our <code>FbSR</code> encoding of objects, recall that we explicitly inherited by grabbing methods out of our "superclass object"; using this approach we could easily make two or more "superclass objects" and then explicitly pick which one we are inheriting a method from, meaning no diamond ambiguity will arise.  However there will be two copies of the "top" class in a diamond in this obvious encoding, similar to non-virtual inheritance in C++.
</ul>
<h4>Aside: Multiple inheritance, mixins, and traits</h4>
<ul>
  <li>Multiple inheritance is a generalization of mixins which is a generalization of traits<br>
-- but thats the opposite of the historical order, mixins/traits were created to solve the diamond problem and other problems.
  <li><a
	    href="http://en.wikipedia.org/wiki/Mixin">Mixins</a> support only two levels: the "super" level which is all abstract classes and the "class" level below it which can multiply inherit.  No three levels means no diamond problem.
      <ul>
	<li>Mixins are an idea originating in CLOS, the  Common Lisp Object System
	<li>Ruby also uses mixins, as does Scala (where they are confusingly called <em>traits</em>)
      </ul>
  <li>Mixins still have a priority order on mixing in terms of which super to get a certain method from.  Traits are a strict form of mixin that requires there to be no overlap or to explicitly disambiguate;<br>
-- C++ multiple inheritance takes a similar approach when two supers have overridden the same method.
</ul>
<h3><a
href="http://en.wikibooks.org/wiki/C++_Programming/RTTI">Dynamic
Typing in C++: RTTI</a></h3>
"RTTI" in C++ stands for RunTime Type Infomation.
<ul>
  <li>RTTI is a simple concept: objects carry their creating class
  name around at runtime.
  <br>&nbsp;&nbsp;&nbsp;(Recall that declared types and runtime types may differ in
      languages with subtyping: the static type there means "this type or a
      subclass / implementing class")
  <li>In general, any type information carried around at run-time is "RTTI"<br>
-- all dynamically typed languages carry types of all entities around at runtime.
  <li>In Java this always happens due to its need to ensure safety of
  runtime downcasts, instance-of, and <code>.getClass</code> queries.
  <li>The downside is there is extra runtime overhead on adding this
      information to objects.
  <li>In C++ the runtime type information is only added by the
  compiler if you need it (it infers if you are using RTTI on that object).
</ul>
We will briefly look at some  of the code linked above to see how it
is  done in practice.
<h3><a href="http://en.wikipedia.org/wiki/Generic_programming#Templates_in_C.2B.2B">Templates</a></h3>
<ul>
  <li>The C++ answer to parametric  polyorphism / generics
  <li>Templates look something like
      parametric polymorphism but in fact are a completely different beast - they are more like macros
  <li>Templates are all instantiated by a preprocessor at compile-time
      with the actual types, and  that  expanded code is what is compiled
  <li>There is no need for the fancy bounded subtyping of Java -
      just instantiate and compile; the final code may have a type
      error due to a subtyping error
  <li>The latter point makes it hard to debug type errors in
      templates -- you need to explicitly think about staged
      compilation (see below) to understand what the compiler is doing!
  <li>Here is a cool example of how mixins can be done with single inheritance but with templates: <a
	    href="http://www.artima.com/weblogs/viewpost.jsp?thread=132988">Mixin
	    classes in C++</a>
</ul>
<h3><a
      href="http://en.wikipedia.org/wiki/Template_metaprogramming">Template
      Metaprogramming</a>
 </h3>
Template metaprogramming in C++ is part of a larger topic: <em>staged
computation</em>.
<ul>
  <li>Partial evaluation: evaluate some of the program code at compile
      time,  e.g. apply functions if (enough) arguments are known at compile-time.
  <li><a
      href="http://www.usenix.org/events/dsl99/full_papers/sheard/sheard_html/node3.html">MetaML</a>
      is a cleaner and more general notion than C++ template
      metaprogramming - code is first-class, can
      be combined almost like strings, but in a well-typed way.
      <ol>
	<li>Run the first stage, which can do arbitrary computations;
	    the result returned is the second-stage program.
	<li>run the second stage, returning third stage program.
	<li>etc - run until the final program results.
	<li>... then run that to do the actual application task.
      </ol>
Observe
      <ul>
	<li>     In terms of this model, C++ template metaprogramming is a 2-stage process.
	<li> Also the default is reversed: unlabelled C++ code is
	analogous to the &lt;bracketed&gt; code in MetaML since its
	running is delayed.
      </ul></ul>
We will go through the C++ example above.

<h3><a
href="http://en.wikipedia.org/wiki/Generic_programming#Template_specialization">Template
Specialization</a></h3>
      <ul>
	<li>Another handy feature of templates, it allows implementations to be
specialized at instantiation time.
	<li>Template specialization is somewhat similar to Java overloading - different versions for different types
      </ul>
<h3><a href="http://en.wikipedia.org/wiki/Operator_overloading">C++ Overloading</a></h3>
There are three dimensions of overloading:
      <ul>
	<li>Methods only: methods can be overloaded, different bodies can handle differently-typed arguments (Java)
	<li>Existing operator overloading: the say <code>+</code> operator can be used on user-defined types, with the user defining the meaning (C++).<br>
-- can shrink code size a lot but can also make code too unreadable.
	<li>New operator creation: users can make new infix operators, e.g. <code>+*+</code> (Standard ML).<br>
-- not really overloading since operator is new.  Operator precedence and associativity is tricky here
      </ul>

Operator overloading has been hotly debated.
<ul>
  <li>Its great: such compact syntax with such great power!
  <li>Its horrible: I have no idea  which operators were
      overloaded where so I don't know what the heck this program is doing!
</ul>


<h3>Various new C++ features</h3>
<ul>
  <li>
 <a href="https://en.wikipedia.org/wiki/C%2B%2B11#Type_inference">C++ performs some local type inference now</a>.
  <li> More explicit multithreading support.
  <li> C++-11 has some support for garbage collected implementations; programmers need to pick this option and live in a restricted programming model for it to work.
  <li><a href="http://en.wikipedia.org/wiki/Anonymous_function#C.2B.2B">C++ now has anonymous functions</a>.
</ul>
</div>



<!--#include virtual="/pl/footer.html" -->


