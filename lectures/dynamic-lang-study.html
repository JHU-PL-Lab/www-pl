<HTML> <HEAD> <TITLE>Study of Dynamically Typed Languages</TITLE> </HEAD>
<body LINK="#0000FF" VLINK="#800080" bgcolor="#F0FFF0">
<h2>Study of Dynamically Typed Languages</h2>

<!-- See file in this directory for comments to improve these.. -->
<h3>Dynamic Typing</h3>
A pure dynamically typed language
<ul>
  <li> Has no typechecker as part of the compiler which rejects
      programs based on their types
  <li> Detects type faults at runtime, e.g. adding a number and
      a function, etc, raising an exception.
  <li>Tends to run slower  due to the need for run-time overhead; with
      major compiler development can be made to run somewhat fast.
  <li>These  languages tend to be better for small- and perhaps
      medium-scale applications, and tend to be worse for large-scale
      applications.
      <ul>
	<li>Can be more freewheeling: incrementally add code, no need
	    to mess with types, etc.
	<li>Freewheeling style bites you for larger apps which don't
	    fit in your mental cache anymore
      </ul>
  <li>They tend to run in an environment where the codebase is
      itself a mutable data structure
</ul>

The non-OO school
<ul>
  <li>Lisp - the original dynamically-typed language
  <li>Scheme - (add1 Lisp)
  <li><a
      href="http://en.wikipedia.org/wiki/Scripting_programming_language">Scripting
      languages</a>, e.g. the  UNIX shells (sh, csh), awk, tcl, etc. 
  <li>early Perl (pre-5)
</ul>

The "classic" dynamic OO languages
<ul>
  <li>Smalltalk
      aka squeak (<a
      href="http://www.cs.oswego.edu/~odendahl/manuals/smalltalk/tutorial/">tutorial1</a>,
      <a href="http://www.chronos-st.org/Smalltalk-Getting-the-Message.html">tutorial2</a>)
  <li>CLOS, the Common Lisp Object System
  <li>Dylan - based on CLOS
</ul>


The "modern" school
<ul>
  <li>Perl 5+
  <li><a href="http://docs.python.org/tut/">Python</a>
  <li><a
      href="http://en.wikipedia.org/wiki/Ruby_programming_language">Ruby</a>
      (Here is an easy <a
href="http://www.math.umd.edu/~dcarrera/ruby/0.3/">tutorial</a>; <a
      href="http://www.rubycentral.com/pickaxe/">another one</a>).
</ul>
<h3>Dynamically typed languages and our <strong>Fb</strong>
series</h3>
<ul>
  <li>Our <strong>FbSRXVOB</strong> mash contains the core features of
      a dynamically typed language.
  <li>We did not cover how run-time type errors lead to exceptions but
      its simple: e.g. add rules like
       <table border='0' cellpadding='0' cellspacing='15'>   <tr> <td><strong>(<span 
class="cmtt-10">- </span>Mismatch Bool Left)</strong></td> <td> <table border='0' cellpadding='0' cellspacing='0'> <tr><td align='center'>&nbsp;<span 
class="cmmi-10">e</span>&nbsp;==&gt;&nbsp;<span 
class="cmtt-10">True</span></td></tr> <tr><td><hr noshade size='1'></td></tr> <tr><td align='center'><span 
class="cmmi-10">e</span> <span 
class="cmtt-10">-</span> <span 
class="cmmi-10">e</span><span 
class="cmsy-10">'</span>&nbsp;==&gt;&nbsp;<span 
class="cmtt-10">Raise (#</span><span 
class="cmti-10">TypeMismatch</span> <span 
class="cmmi-10">True</span><span 
class="cmtt-10">)</span></td></tr> </table> </td> </tr>  </table>
etc -- many such rules are needed.  But, thats about all there is to it.
<li>As with Java there are also some dimensions of these languages we
    missed, in particular all the reflection-type stuff and dynamic
    code loading.
</ul>
We will now look at some crosscutting aspects of these languages.
<h3>Blocks of code aka higher order functions</h3>
<ul>

 <li>Lisp/Scheme: <code>(lambda (x) ... )</code> - Lisp was the first
  language with implemented  higher-order functions
  <li>Smalltalk: <a
      href="http://www.cs.oswego.edu/~odendahl/manuals/smalltalk/tutorial/val.html#6.Codeblocks">code
      blocks</a>
  <li>Ruby: blocks which are similar to Smalltalk's.
  <li>Python: <a href="http://docs.python.org/tut/node6.html#SECTION006750000000000000000">lambda-forms</a>
</ul>

<h3>"Everything is an object"</h3>
There are various degrees to what this means.  
<ul>
  <li>Smalltalk is pretty extreme.  
      <ul>
	<li>Even if-then-else and <code>+</code> are implemented
      via messaging.
	<li>Global variables is nothing but a systemwide dictionary
	    (hashset).
	    <pre>     Smalltalk at: #f put: (Foo new) </pre>
	    adds a new Foo named <code>#f</code> to the globals which
	    is a dictionary affiliated  with object <code>Smalltalk</code>.
	<li>Classes themselves are nothing but atoms in this
	    dictionary -- <code>#Foo</code> in the above case is in
	    the global dictionary, <code>Smalltalk</code>.
	<li>The "<code>Smalltalk</code>" in the above is itself a
	    class, so it is in itself!
	<li>Classes are fully objects - they can be passed around as data
	<li><a
      href="http://en.wikipedia.org/wiki/Smalltalk">Some examples to
	    look through</a>
      </ul>  
  <li>Ruby has most of this:
      <ul>
	<li>Classes are objects in Ruby. For example the
	    <code>inherited</code> method 
	    of the class is run when a new subclass is <em>defined</em>.
	<li>nil is also a class, as in Smalltalk  
	<li>There is also a global dynamic dictionary of classes in Ruby
      </ul>
  <li>Python: classes are also objects.
</ul>

<h3>Public/private/protected</h3>
<ul>
  <li>Smalltalk: fields private, methods  public.  Put things in a
      "private" protocol (category) if they are local
  <li>Python: everything public
  <li>Ruby: public/private/protected
</ul>
<h3>First-class methods</h3>
This mean methods are objects so can pull out a method and stash
      it in a variable, then call it later.  Our encoding of objects
in <strong>DOB</strong> allows something like
this in how methods are functions so you can extract the method and
then stash it somewhere.
<ul>
  <li>Smalltalk: not directly.
  <li>Python: yes. <a href="http://docs.python.org/tut/node11.html#SECTION0011340000000000000000">Example</a>.
  <li>Ruby: yes. <a href="http://www.rubycentral.com/ref/ref_c_method.html">Example</a>.
</ul>


<h3>Reflection</h3>
Given some object, can you poke around to find its class, methods,
etc? (has a MOP - meta-object protocol)  This stuff is  very easy to
do in a dynamically-typed language because the program data structure
is  around explicitly at runtime.
<ul>
  <li>Smalltalk - yes.  
      <ul>
	<li>Can easily turn a string into a method name to
      invoke.  
	<li>Objects can also <code>become</code> a completely new behavior.
      </ul>
  <li>Ruby - yes.
      <ul>
	<li> Can turn string into method  to invoke -  <a href="http://www.rubycentral.com/pickaxe/ospace.html#S3">documentation</a>
	<li>Can add methods to existing objects - <a href="http://www.rubycentral.com/pickaxe/ref_c_object.html#Object.extend">documentation</a>
	<li>Can take  an object an specialize  it with its  own
	    singleton class, adding new  methods; the objects old
	    class becomes the superclass of this new class.  <a href="http://www.rubycentral.com/pickaxe/classes.html#UB">example</a>
      </ul>
  <li>Python - yes.
      <ul>
	<li>Can change the class of an object at runtime.
	    Related to <code>become</code> of Smalltalk
      </ul>
</ul>
Ruby is much cleaner here,  it has clean notions of adding methods and
Smalltalk and Python can blow up because methods will disappear, and
field references are wacky.
<h3>Inheritance</h3>
<ul>
  <li>Smalltalk: regular single inheritance
  <li>Python: multiple inheritance (and the associated <a
      href="http://en.wikipedia.org/wiki/Diamond_problem">Diamond
      Problem</a> of course)
  <li>Ruby: single inheritance plus arbitrary <a
      href="http://www.rubycentral.com/pickaxe/classes.html#UC">mixin
      modules</a>.  Modules are like classes but since these modules are themselves at the top of
      the hierarchy (modules cannot have supermodules) there is no dreaded diamond property.
</ul>

<h3>Metaprogramming</h3>
Recall our discussion of staged programming of C++ templates and
meta-ML: code can be "run to make the code".
<ul>
  <li>Ruby allows class definitions  to contain code which then runs
      to generate  the actual class, at load time -- <a href="http://www.rubycentral.com/pickaxe/classes.html#S2">example</a>.
  <li><a
      href="http://www.cs.oswego.edu/~odendahl/manuals/smalltalk/tutorial/val.html#4.1.Creatinganewclass">This
      idea is inspired by Smalltalk</a>.
</ul>
<h3>Overloading and shortcut syntax</h3>
<ul>
  <li>Smalltalk - can do it yourself manually since operators  are all only
      messages (but ugly); no regexps
  <li>Python: built in
  <li>Ruby: built  in
</ul>
<hr>
<address></address>
<!-- hhmts start -->
Last modified: Thu Jul  9 13:59:30 EDT 2009
<!-- hhmts end -->
</BODY> </html>

