<!--#include virtual="/pl/header.html" -->	 
</div>

<!-- Main -->
<div id="main" class="wrapper style4">

<!-- Content -->
<div id="content" class="container">
<section>
<header class="major">
<h2>A Taste of Rust</h2>
</header>

OCaml meets C++ for <em>safe</em> but <em>efficient</em> systems programming</li>
<br>
Functional programming goodies:
<ul>
  <li>immutable by default with let-definition</li>
  <li>parametric polymorphism</li>
<li>first-class functions</li>
<li>algebraic data types</li>
<li>pattern matching</li>
</ul>

Systems programming goodies:
<ul>
<li>true pointer references</li>
<li>objects</li>
<li>method call syntax</li>
</ul>

Key innovation: improved memory safety in spite of low-level memory model
<ul>
<li>Invariant: memory is not touched after it’s deallocated</li>
<li>Writes/reads are deterministic so concurrent data races are prevented</li>
</ul>

How: <em>ownership</em> of data

<h4>Ownership</h4>

<ul>
<li>A function by default <em>owns</em> values it defines or receives as parameters</li>
<li>The owner of a value knows nobody else can be accessing it (no aliases to it or threads accessing it)</li>
<li>Calling a function, by default means the caller must give up access to the value (but can give back by returning it)</li>
<li>Similarly, assignment often means giving up access to the value</li>
</ul>

We will consult the <a href="https://doc.rust-lang.org/book/ownership.html">documentation on ownership</a> for details.


<h4>Borrowing</h4>
OK at this point Rust sounds nearly-useless given this rigidity.  But there are weakenings possible.

<ul>
<li>A function can accept arguments by-value or by-reference
<li>by-value transfers ownership as we saw up to now</li>
<li>by-reference <em>borrows</em> ownership</li>
</ul>

We will consult the <a href="https://doc.rust-lang.org/book/references-and-borrowing.html">documentation on borrowing</a> for details.

<h4>Lifetimes</h4>

<ul>
<li>Every value has a (statically known) <em>lifetime</em>, written <tt>'a</tt></li>
<li>Usually, this can be inferred, but can declare if inference is not working</li>
<li>They are used to track borrowing and make sure references will not be dangling
</li>
</ul>

Again we will consult the <a href="https://doc.rust-lang.org/book/lifetimes.html">documentation on lifetimes</a> for details.

<h4>Efficiency</h4>
Why all the pain compared to Java, python, etc?  Efficiency is the gain!
<ul>
<li>Static dispatch by default - like C++ non-virtual, very efficient
<li>No required runtime, and no garbage collection overhead</li>
</ul>
<h4>Freeing (finalizing) data</h4>
<ul>
<li>Summary Similar to C++'s informal "RAII" (Resource Acquisition Is Initialization) philosophy but enforced by compiler</li>
<li>No manual free</li>
<li>Key concept: Memory freed and destructor called when value leaves owner’s scope (in reverse order of initialization, due to dependencies)
<li>Particularly useful for resources like file handles, gets closed when scope over</li>
</ul>
<ul>
Example:
<pre>
struct HasDrop {x:i32}
impl Drop for HasDrop {
fn drop(&amp;mut self) {  // drop method in Drop trait called when scope exits
        println!("Dropping {}!", self.x);
    }
}
fn takes(x:HasDrop) {}        // value parameter, takes x
fn borrows(x:&amp;HasDrop) {} // reference parameter, only borrows x
fn main() {
    let x = HasDrop{x:1};
    let x = HasDrop{x:2};
    {
      let x = HasDrop{x:3};
      let x = HasDrop{x:4};
    }
    let x = HasDrop{x:5};
    takes(x);
    let x = HasDrop{x:6};
    borrows(&amp;x);
    let x = HasDrop{x:7};
}
</pre>
Output:
<pre>
Dropping 4!
Dropping 3!
Dropping 5!
Dropping 7!
Dropping 6!
Dropping 2!
Dropping 1!
</pre>

<h4>Relaxing Restrictions</h4>
<p>
  Rust up to now is reasonable for many programming tasks, but is still extremely annoying in a few cases; there are advanced tools to help.

<ul>
  <li><tt>Rc&lt;T&gt;</tt> types: allows multiple “owners”; reference couting is used to prevent too-early free</li>
<li><tt>Arc&lt;T&gt;</tt>: atomic version of the above</li>
<li><tt>~*const T~</tt> and <tt>~*mut T~</tt>: raw pointers, aliasing is allowed, but dereferencing is unsafe.
<li><tt>Cell&lt;T&gt;</tt>: allow mutation from multiple sources</li>
<li>Real corner cases may need unsafe escapes: Dereferencing raw pointers, violating “read XOR write” reference scope, unsafe typecasts
</ul>
	
</section>
</div>
</div>


<!--#include virtual="/pl/footer.html" -->	 
