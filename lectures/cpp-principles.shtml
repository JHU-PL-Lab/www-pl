<!--#include virtual="/pl/header.html" -->	 
</div>

<!-- Main -->
<div id="main" class="wrapper style4">

<!-- Content -->
<div id="content" class="container">
<section>
<header class="major">
<h2>Principles of C++</h2>
</header>

<h3>Explicit Memory Model</h3>
Both C and C++ have an explicit memory model:
<ul>
  <li>Exposes pointers to the programmer directly </li>
  <li>Heap data explicitly needs de-allocating</li> 
    </ul>
Plus and minus:
<ul>
  <li>-: Explicit memory errors accounts for a good fraction of the bugs in C/C++ programs.
  <li>+: Implicit freeing via garbage collection adds run-time overhead and may not work in soe real-time settings.</li>
</ul>
<h3><a href="https://en.wikipedia.org/wiki/Smart_pointer">Smart pointers in C++11</a></h3>
<ul>
  <li>The reference counting approach of Swift back-ported to C++
  <li>Swift strong reference == C++11's <code>std::shared_ptr</code>
  <li>Swift weak or unowned reference == C++ <code>std::weak_ptr</code>.
</ul>
A limited notion of Rust-style ownership type is in C++11
<ul>
  <li> <code>std::unique_ptr</code> pointers should have no aliases: the one pointer "owns" the data.
  <li>Since the contract is no aliases, when the (one) pointer is nulled, compiler can free the memory.
  <li>You can <code>std::move</code> a shared pointer, transferring ownership to new spot.  Pass a move'd pointer if you are giving the callee ownership (e.g. if its a class constructor and the new class gets to own the data).
  <li>Unique pointers can't be directly assigned to other pointers or passed as parameters - would violate contract.
</ul>


<h3><a
href="http://en.wikibooks.org/wiki/C++_Programming/RTTI">Dynamic
Typing in C++: RTTI</a></h3>
"RTTI" in C++ stands for RunTime Type Infomation.
<ul>
  <li>RTTI in C++ means objects carry their creating class
    name around at runtime (note Java always does this, it is why <tt>instance-of</tt> works)</li>
  <li>With RTTI can do <tt>typeid(obj)</tt> to return the runtime class of <tt>obj</tt>, and you can do downcasts a la Java via <tt>dynamic_cast</tt>.
  <li>C++ by default does not do this, to avoid overhead.  Compiler infers when you need it and adds.
</ul>

<h3><a href="http://en.wikipedia.org/wiki/Generic_programming#Templates_in_C.2B.2B">Templates</a></h3>
<ul>
  <li>The C++ answer to parametric  polyorphism / generics
  <li>Templates look something like
      parametric polymorphism but in fact are a completely different beast - they are fancy macros
  <li>Templates are all instantiated by a preprocessor at compile-time
      with the actual types, and  that  expanded code is what is compiled
  <li>Templates are "evaluated"/"run" to get the results - they are programs taking and producing programs - <em>metaprograms</em>.
  <li>There is no need for Java's bounded subtyping  -
      just instantiate and compile; the final code may have a type
      error due to a subtyping error
  <li>Downsides: hard to debug since type errors show up in expanded code which you can't actually see; and, templates really do produce new code and can bloat code size.
</ul>
<h3><a
      href="http://en.wikipedia.org/wiki/Template_metaprogramming">Templates and

      Metaprogramming</a>
</h3>
(We will probably skip this; here for your reading interest)
<ul>
  <li>Simplest form of metaprogramming is a macro preprocesser, e.g. <code>cpp</code><br>
-- macro language takes program, runs all the macros and inlines the results in the source code.
  <li>C++ templates generalize such macro mechanisms; they are in fact Turing complete -- see the examples in <a
      href="http://en.wikipedia.org/wiki/Template_metaprogramming">the wikipedia page</a>.

  <li><em>Compile-time metaprogramming:</em> a general term for code that runs at compile time and generates more code (e.g. macros) but possibly allows more general programming such as recursion, etc
      <ul>
	<li>C++ templates started out as fancy macros and evolved to compile-time metaprogramming (unintentionally)
	<li>Template Haskell is a better example, was designed that way from the start
      </ul>
  <li><a href="http://www.haskell.org/haskellwiki/Template_Haskell">Template Haskell</a>
is a cleaner and more general notion than C++ templates 
      <ul>
	<li>"macro" and "main" language use the same syntax
	<li>code in the "main" is data to the "macro" language.
	<li>"macro" level explicitly specifies where to splice code it produces into "main".
      </ul>
  <li><a href="http://en.wikipedia.org/wiki/Eval"><code>eval</code></a> for <em>run-time</em> (as opposed to compile-time like Templates) metaprogramming
      <ul>
	<li><code>eval</code> is the standard name for a program which takes a program-as-data as argument (either in the form of a string or an abstract syntax tree) and runs it.
	<li><code>eval</code> is found in Lisp, Scheme, Python, Ruby, Javascript, etc.<br>
-- it fits very nicely in dynamically typed languages; statically typed languages don't know what type it returns so hard to fit.
	<li>Subtle issue of how nonlocal variables behave (<code>x = 5; eval("x + 1")</code>)
	<li> <a
      href="http://www.usenix.org/events/dsl99/full_papers/sheard/sheard_html/node3.html">MetaML</a>  is a "typed" version of <code>eval</code>: the argument to <code>eval</code> is of type <code>&lt;t&gt;</code> for some type <code>t</code>, the <code>&lt;&gt;</code> meaning "code of".
      </ul>

</ul>

<h3><a href="http://en.wikipedia.org/wiki/Operator_overloading">C++ Overloading</a></h3>
There are three dimensions of overloading:
      <ul>
	<li>Methods only: methods can be overloaded, different bodies can handle differently-typed arguments (Java)
	<li>Existing operator overloading: the say <code>+</code> operator can be used on user-defined types, with the user defining the meaning (C++).<br>
-- can shrink code size a lot but can also make code unreadable.
	<li>New operator creation: users can make new infix operators, e.g. <code>+*+</code> (Standard ML).<br>
-- not really overloading since operator is new.  Operator precedence and associativity is tricky here
      </ul>


<a name="lambdas"></a><h3>Lambda expressions in C++11</h3>
<ul>
  <li>Everyone is joining the Lambda party!
  <li>Details <a href="http://en.wikipedia.org/wiki/Anonymous_function#C.2B.2B_.28since_C.2B.2B11.29">here</a>.  Closures are a headache due to different low-level ways data can be accessed in C++.</ul>
<h3>Local Type Inference in C++</h3>
<ul>
  <li>
 <a href="https://en.wikipedia.org/wiki/C%2B%2B11#Type_inference">C++ performs local type inference now</a>, e.g. <code>auto mydata = 22;</code>. <tt>auto</tt> is like <tt>var</tt> in Java.
  <li>C++-14 adds <a href="http://en.wikipedia.org/wiki/C++14#Generic_lambdas">generic lambdas</a> which look like the polymorphic types of OCaml/Java but are really just fancy macros.
</ul>


<h3>Multiple Inheritance - good and bad</h3>
<ul>
  <li>Multiple inheritance is great: it amounts to being able to define fields and method bodies on your interfaces
  <li>The major technical  hiccup is <a
href="http://en.wikipedia.org/wiki/Diamond_problem">The Diamond
Problem</a>.
      <ul>
	<li>Basic solution in most languages is to have one copy of the super-super but make a priority order on when classes were defined in terms of whose copy "wins".
	<li>In C++ you need to use the keyword <code>virtual</code> on inheritance to get this behavior, otherwise you just get two copies of the super-super.
	<li>Even without this messy problem there still is an issue of what to do when two superclasses define a method of the same name.
	<li>Java 8 also has some of the Diamond Problem peeking in, because Java interfaces now support <a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">default methods</a>.
      </ul>  <li>In our <code>FbSR</code> encoding of objects, recall that we explicitly inherited by grabbing methods out of our "superclass object"; using this approach we could easily make two or more "superclass objects" and then explicitly pick which one we are inheriting a method from, meaning no diamond ambiguity will arise.  However there will be two copies of the "top" class in a diamond in this obvious encoding, similar to non-virtual inheritance in C++.
</ul>
<h4>Aside: Multiple inheritance, mixins, and traits</h4>
<ul>
  <li>Multiple inheritance is a generalization of mixins which is a generalization of traits<br>
-- but thats the opposite of the historical order, mixins/traits were created to solve the diamond problem and other problems.
  <li><a
	    href="http://en.wikipedia.org/wiki/Mixin">Mixins</a> support only two levels: the "super" level which is all abstract classes and the "class" level below it which can multiply inherit.  No three levels means no diamond problem.
      <ul>
	<li>Mixins are an idea originating in CLOS, the  Common Lisp Object System
	<li>Ruby also uses mixins, as does Scala (where they are confusingly called <em>traits</em>)
      </ul>
  <li>Mixins still have a priority order on mixing in terms of which super to get a certain method from.  Traits are a strict form of mixin that requires there to be no overlap or to explicitly disambiguate;<br>
-- C++ multiple inheritance takes a similar approach when two supers have overridden the same method.
</ul>

</section>
</div>
</div>


<!--#include virtual="/pl/footer.html" -->	 


