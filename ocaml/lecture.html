<!DOCTYPE HTML>
<!--
 Solarize by TEMPLATED
 templated.co @templatedco
 Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
 <head>
  <title>Principles of Programming Languages</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="description" content="" />
  <meta name="keywords" content="" />
  <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
  <script src="/pl/js/jquery.min.js"></script>
  <script src="/pl/js/jquery.dropotron.min.js"></script>
  <script src="/pl/js/skel.min.js"></script>
  <script src="/pl/js/skel-layers.min.js"></script>
  <script src="/pl/js/init.js"></script>
  <noscript>
   <link rel="stylesheet" href="/pl/css/skel.css" />
   <link rel="stylesheet" href="/pl/css/style.css" />
  </noscript>
  <!--[if lte IE 8]><link rel="stylesheet" href="/pl/css/ie/v8.css" /><![endif]-->
 </head>
 <body>

  <!-- Header Wrapper -->
   <div class="wrapper style1">
   
   <!-- Header -->
    <div id="header">
     <div class="container">
       
      <!-- Logo -->
       <h1><a href="/pl/index.html" id="logo">Principles of PL</a></h1>
      
      <!-- Nav -->
       <nav id="nav">
        <ul>
         <li class="active"><a href="/pl/index.html">Home</a></li>
         <li>
          <a href="/pl/logistics.html">Logistics</a>
          <ul class="menu">
           <li><a href="/pl/dateline.html">Dateline</a></li>
           <li><a href="https://gradescope.com">Gradescope</a></li>
           <li><a href="https://TBA.TBA">Q&amp;A</a></li>
           <li><a href="/pl/contact.html">Contact Us</a></li>
          </ul>
         </li>
         <li><a href="/pl/book">The Book</a>
         <ul class="menu">
         <li><a href="/pl/book/book.pdf">The book PDF</a></li>
         <li><a href="/pl/book/dist/">The FbDK dist</a></li>
       </ul></li>

         <li><a href="/pl/ocaml/index.html">OCaml</a>
         </li>
         <li><a href="">Assignments</a>
         <ul class="menu">
         <li><a href="/pl/assignments/assignment1.html">Assignment 1</a></li>
         <li><a href="/pl/assignments/assignment2.html">Assignment 2</a></li>
         <li><a href="/pl/assignments/assignment3.html">Assignment 3</a></li>
         <li><a href="/pl/assignments/assignment4.html">Assignment 4</a></li>
         <li><a href="/pl/assignments/assignment5.html">Assignment 5</a></li>
         <li><a href="/pl/assignments/assignment6.html">Assignment 6</a></li>
         <li><a href="/pl/assignments/assignment7.html">Assignment 7</a></li>
         <li><a href="/pl/assignments/assignment8.html">Assignment 8</a></li>
         <li><a href="/pl/assignments/assignment9.html">Assignment 9</a></li>
       </ul></li>
        </ul>
       </nav>
 
     </div>
    </div>
<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/pl/css/friendly.css" />
<meta charset="utf-8" />
    
<h2 id="introduction-to-ocaml-programming">Introduction to OCaml Programming</h2>

<ul>
  <li>OCaml is a <em>strongly typed functional programming language</em>
    <ul>
      <li>Strongly typed means the compiler will detect type errors; you won’t get them at runtime like in JavaScript/Python</li>
      <li>Functional means an emphasis on <em>functions</em> as a key building block and use of functions as data (functions that themselves can take functions as arguments and return functions as results)</li>
    </ul>
  </li>
</ul>

<p>(Note if you want to get all the code (only) in this webpage into a <code>.ml</code> file to load into your editor, download the file <a href="lecture.ml">lecture.ml</a>.)</p>

<h3 id="the-top-loop">The top loop</h3>

<ul>
  <li>We will begin exploration of OCaml in the interactive <em>top loop</em></li>
  <li>The top loop is the same as the read-eval-print loop or the console window for other languages</li>
  <li>To get the top loop we are using, <code>utop</code>, follow the course <a href="../index.html">OCaml install instructions</a>.</li>
</ul>

<h4 id="simple-integer-operations-in-the-top-loop">Simple integer operations in the top loop</h4>

<pre><code class="language-ocaml">3 + 4;; (* ";;" denotes end of input, somewhat archaic. *)
let x = 3 + 4;; (* give the value a name via let keyword. *)
let y = x + 5;; (* can use x now *)
let z = x + 5 in z - 1;; (* let .. in defines a local variable z *)
</code></pre>

<h4 id="boolean-operations">Boolean operations</h4>

<pre><code class="language-ocaml">let b = true;;
b &amp;&amp; false;;
true || false;;
1 = 2;; (* = not == for equality comparison - ! *)
1 &lt;&gt; 2;;  (* &lt;&gt; not != for not equal *)
</code></pre>

<h4 id="other-basic-data--see-documentation-for-details">Other basic data – see documentation for details</h4>
<pre><code class="language-ocaml">4.5;; (* floats *)
4.5 +. 4.3;; (* operations are +. etc not just + which is for ints only *)
30980314323422L;; (* 64-bit integers *)
'c';; (* characters *)
"and of course strings";;
</code></pre>

<h4 id="simple-functions-on-integers">Simple functions on integers</h4>

<p>To declare a function <code>squared</code> with <code>x</code> its one parameter.  <code>return</code> is  implicit.</p>
<pre><code class="language-ocaml">let squared x = x * x;; 
squared 4;; (* to call a function -- separate arguments with S P A C E S *)
</code></pre>
<ul>
  <li>OCaml has no <code>return</code> statement; value of the whole body-expression is what gets returned</li>
  <li>Type is automatically <strong>inferred</strong> and printed as domain <code>-&gt;</code> range</li>
  <li>OCaml functions in fact always take only one argument - !  multiple arguments can be encoded (later)</li>
</ul>

<h4 id="fibonacci-series-example---0-1-1-2-3-5-8-13-">Fibonacci series example - <code>0 1 1 2 3 5 8 13 ...</code></h4>

<p>Let’s write a well-known function with recursion and if-then-else syntax</p>

<pre><code class="language-ocaml">let rec fib n =     (* the "rec" keyword needs to be added to allow recursion *)
  if n &lt;= 0 then 0
  else if n = 1 then 1
  else fib (n - 1) + fib (n - 2);; (* notice again everything is an expression, no "return" *)

fib 10;; (* get the 10th Fibonacci number *)
</code></pre>

<h4 id="anonymous-functions-basics">Anonymous functions basics</h4>

<ul>
  <li>Key advantage of FP: functions are just expressions; put them in variables, pass and return from other functions, etc.</li>
  <li>Much of this course will be showing how this is useful, we are just getting started now</li>
</ul>

<pre><code class="language-ocaml">let add1 x = x + 1;; (* a normal add1 definition *)
let anon_add1 = (function x -&gt; x + 1);; (* equivalent anonymous version; "x" is argument here *)
anon_add1 3;;
(anon_add1 4) + 7;; 
((function x -&gt; x + 1) 4) + 7;; (* can inline anonymous function definition *)
((fun x -&gt; x + 1) 4) + 7;; (*  shorthand notation -- cut off the "ction" *)
</code></pre>

<p><a name="ii"></a></p>

<h2 id="ocaml-lecture-ii">OCaml Lecture II</h2>

<ul>
  <li>Multiple arguments - just leave s p a c e s between multiple arguments in both definitions and uses</li>
</ul>

<pre><code class="language-ocaml">let add x y = x + y;;
add 3 4;;
(add 3) 4;; (* same meaning as previous application -- two applications, " " associates LEFT *)
let add3 = add 3;; (* No need to give all arguments at once!  Type of add is int -&gt; (int -&gt; int) - "CURRIED" *)
add3 4;;
add3 20;;
(+) 3 4;; (* Putting () around any infix operator turns it into a 2-argument function *)
</code></pre>

<p>Conclusion: add is a function taking an integer, and returning a <strong>function</strong> which takes ints to ints.<br />
So, add is a <strong>higher-order function</strong>: it returns a function as result.</p>

<p>Observe <code>int -&gt; int -&gt; int</code> is parenthesized as <code>int -&gt; (int -&gt; int)</code> – unusual <strong>right</strong> associativity</p>

<p>Be careful on operator precedence with this goofy way that function application doesn’t need parens!</p>
<pre><code class="language-ocaml">add3 (3 * 2);;
add3 3 * 2;; (* NOT the previous - this is the same as (add3 3) * 2 - application binds tighter than * *)
add3 @@ 3 * 2;; (* LIKE the original - @@ is like the " " for application but binds LOOSER than other ops *)
</code></pre>

<h3 id="simple-structured-data-types-option-and-result">Simple Structured Data Types: Option and Result</h3>

<ul>
  <li>Before getting into “bigger” data types and how to declare our own, let’s use one of the simplest structured data types, the built-in <code>option</code> type.</li>
</ul>

<pre><code class="language-ocaml">Some 5;;
- : int option = Some 5
</code></pre>

<ul>
  <li>all this does is “wrap” the 5 in the <code>Some</code> tag</li>
</ul>

<pre><code class="language-ocaml">None;;
- : 'a option = None
</code></pre>

<ul>
  <li>Notice these are both in the <code>option</code> type .. either you have <code>Some</code> data or you have <code>None</code>.</li>
  <li>These kinds of types with the capital-letter-named tags are called <strong>variants</strong> in OCaml; each tag wraps a different variant.</li>
  <li>The <code>option</code> type is very useful; here is a super simple example.</li>
</ul>

<pre><code class="language-ocaml"># let nice_div m n = if n = 0 then None else Some (m / n);;
val nice_div : int -&gt; int -&gt; int option = &lt;fun&gt;
# nice_div 10 0;;
- : int option = None
# nice_div 10 2;;
- : int option = Some 5
</code></pre>

<p>There is a downside with this though, you can’t just use <code>nice_div</code> like <code>/</code>:</p>

<pre><code class="language-ocaml"># (nice_div 5 2) + 7;;
Line 1, characters 0-14:
Error: This expression has type int option
       but an expression was expected of type int
</code></pre>

<p>This type error means the <code>+</code> lhs should be type <code>int</code> but is a <code>Some</code> value which is not an <code>int</code>.</p>

<p>Here is a non-solution to that:</p>
<pre><code class="language-ocaml"># let not_nice_div m n = if n = 0 then None else m / n;;
Line 1, characters 47-52:
Error: This expression has type int but an expression was expected of type
         'a option
</code></pre>
<ul>
  <li>The <code>then</code> and <code>else</code> branches must return the same type, here they do not.</li>
  <li>The <code>int</code> and <code>int option</code> types have no overlap of members!  Generally true across OCaml.</li>
</ul>

<h4 id="pattern-matching-first-example">Pattern matching first example</h4>

<p>Here is a real solution to the above issue:</p>
<pre><code class="language-ocaml"># match (nice_div 5 2) with 
   | Some i -&gt; i + 7 (* i is bound to the result, 2 here *)
   | None -&gt; failwith "This should never happen, we divided by 2";;
- : int = 9
</code></pre>
<ul>
  <li>This shows how OCaml lets us <em>destruct</em> option values, via the <code>match</code> syntax.</li>
  <li><code>match</code> is similar to <code>switch</code> in C/Java/.. but is much more flexible in OCaml</li>
  <li>The LHS in OCaml can be a general pattern which binds variables (the <code>i</code> here), etc</li>
  <li>Note that we turned <code>None</code> into a runtime exception via <code>failwith</code>.</li>
</ul>

<p>Lastly, the function could itself raise an exception</p>

<pre><code class="language-ocaml">let div_exn m n = if n = 0 then failwith "divide by zero is bad!" else m / n;;
div_exn 3 4;;
</code></pre>

<ul>
  <li>This has the property of not needing a match on the result.</li>
  <li>Note that the built-in <code>/</code> also raises an exception.</li>
  <li>Exceptions are side effects though, we want to minimize their usage to avoid error-at-a-distance.</li>
  <li>The above examples show how exceptional conditions can either be handled via exceptions or in the return value;
    <ul>
      <li>the latter is the C approach</li>
    </ul>
  </li>
</ul>

<h3 id="everything-is-an-expression">Everything is an expression</h3>

<p>Everything in OCaml returns values (i.e. is an ‘expression’) - no commands</p>
<pre><code class="language-ocaml">if (x = 3) then (5 + 35) else 6;; (* ((x==3)?5:6)+1 in C *)
(if (x = 3) then 5 else 6) * 2;;
(if (x = 3) then 5.4 else 6) * 2;; (* type errors:  two branches of if must have same type *)
</code></pre>

<h3 id="lists">Lists</h3>

<ul>
  <li>Lists are pervasive in OCaml</li>
  <li>They are <strong>immutable</strong> (cannot update elements in an existing list) so while they look something like arrays or vectors they are not</li>
</ul>

<pre><code class="language-ocaml">let l1 = [1; 2; 3];;
let l2 = [1; 1+1; 1+1+1];;
let l3 = ["a"; "b"; "c"];;
let l4 = [1; "a"];; (* error - All elements must have same type *)
let l5 = [];; (* empty list *)
</code></pre>

<h4 id="operations-on-lists">Operations on lists.</h4>

<p>Lists are represented internally as <strong>binary trees</strong> with left child a leaf.</p>
<pre><code class="language-ocaml">0 :: l1;; (* "::" is 'consing' 0 to the top of the tree - fast *)
0 :: (1 :: (2 :: (3 :: [])));; (* equivalent to [0;1;2;3] *)
[1; 2; 3] @ [4; 5];; (* appending lists - slower, needs to cons 3/2/1 on front of [4;5] *)
let z = [2; 4; 6];;
let y = 0 :: z;;
z;; (* Observe z itself did not change -- recall lists are immutable in OCaml *)
</code></pre>

<h4 id="destructing-lists-with-pattern-matching">Destructing Lists with pattern matching</h4>

<ul>
  <li>Before writing real programs here is a simple example of pattern matching on a list.</li>
  <li>This function gets the head, the first element.</li>
</ul>

<pre><code class="language-ocaml">let hd l =
  match l with
  |  [] -&gt; None
  |  x :: xs -&gt; Some x (* the pattern x :: xs  binds x to the first elt, xs to ALL the others *)
;;
hd [1;2;3];;
hd [1];; (* [1] is 1 :: [] - !  So the head is 1. *)
hd [];;
</code></pre>

<ul>
  <li>Lists are not random access like arrays; if you want to get the nth element, you need to work for it.</li>
</ul>

<pre><code class="language-ocaml">let rec nth l n =
  match l with
  |  [] -&gt; failwith "no nth element in this list"
  |  x :: xs -&gt; if n = 0 then x else nth xs (n-1)
;;
nth [33;22;11] 1;;
nth [33;22;11] 3;;
</code></pre>
<ul>
  <li>Pattern priority: pick the first matched clause</li>
  <li>The above two patterns are mutually exclusive so order irrelevant, but not in all cases.</li>
</ul>

<p>Don’t use non-exhaustive pattern matches!</p>

<pre><code class="language-ocaml">let dumb l = match l with
      | x :: y -&gt; x;;
dumb [1;2;3];; (* this works to return head of list but.. *)
dumb [];; (* runtime error here *)
</code></pre>

<p>Built-in <code>List.hd</code> is the same as <code>dumb</code> and it is nearly always a <strong>dumb</strong> function, don’t use it unless it is 100% obvious that the list is not empty.</p>

<h3 id="list-library-functions">List library functions</h3>
<p>Fortunately many common list operations are in the <code>List</code> module in the standard library:</p>

<pre><code class="language-ocaml"># List.nth [1;2;3] 2;;
- : int = 3
</code></pre>
<ul>
  <li>We will discuss modules later, but for now just think of them as containers of a collection of functions types etc.  Something like a <code>package</code> in Java, or a Java <code>class</code> with only <code>static</code> methods.</li>
</ul>

<p>Some more handy <code>List</code> library functions</p>
<pre><code class="language-ocaml">List.length ["d";"ss";"qwqw"];;
List.concat [[1;2];[22;33];[444;5555]];;
List.append [1;2] [3;4];; 
[1;2] @ [3;4] (* Use this equivalent infix syntax for append *)
</code></pre>

<ul>
  <li>Type <code>#show List;;</code> into utop to get a dump of all the functions in <code>List</code>.</li>
  <li>The <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html">Standard Library Reference page for lists</a> contains descriptions as well.</li>
  <li>There are similar modes for <code>Int</code>, <code>String</code>, <code>Float</code>, etc modules which similarly contain handy functions.</li>
</ul>

<h4 id="types-of-these-library-functions">Types of these library functions</h4>

<ul>
  <li>The types of the functions are additional hints to their purpose, get used to reading them</li>
  <li>Much of the time when you mis-use a function you will get a type error</li>
  <li><code>'a list</code> etc is a polymorphic aka generic type, <code>'a</code> can be <em>any</em> type<br />
```ocaml
    <h1 id="listlength">List.length;;</h1>
  </li>
  <li>: ‘a list -&gt; int = <fun>
</fun>    <h1 id="listconcat">List.concat;;</h1>
  </li>
  <li>: ‘a list list -&gt; ‘a list = <fun>
</fun>    <h1 id="listappend">List.append;;</h1>
  </li>
  <li>: ‘a list -&gt; ‘a list -&gt; ‘a list = <fun>
```</fun></li>
</ul>

<p>A cool feature of OCaml is how it automatically <em>infers</em> polymorphic types, unlike Java where generics usually need to be declared explicitly.</p>

<h3 id="correctness-of-recursive-functions">Correctness of recursive Functions</h3>

<p>Consider list reverse (no need to code as it is <code>List.rev</code>; this is just an example):</p>
<pre><code class="language-ocaml">let rec rev l =
  match l with
  |  [] -&gt; []
  | x :: xs -&gt; rev xs @ [x]
;;
rev [1;2;3];; (* recall [1;2;3] is equivalent to 1 :: ( 2 :: ( 3 :: [])) *)
</code></pre>

<p>Let us argue why this works.</p>

<p>We assume we have a notion of “program fragments behaving the same”, <code>~=</code>.</p>
<ul>
  <li>e.g. <code>1 + 2 ~= 3</code>, <code>1 :: [] ~= [1]</code>, etc.</li>
  <li>(<code>~=</code> is called “operational equivalence”, we will define it later in the course)</li>
</ul>

<p>Before doing the general case, here are some equivalences we can see from the above program run <br />
(by running it in our heads):</p>
<pre><code class="language-ocaml">rev [1;2;3] 
~= rev (1 :: [2;3]) (by the meaning of the [...] list syntax)
~= (rev [2;3]) @ [1]  (the second pattern is matched: x is 1, xs is [2;3] and run the match body)
~= (rev [3] @ [2]) @ [1]  (same thing for the rev [2;3] expression - plug in its elaboration)
~= ((rev [] @ [3]) @ [2]) @ [1]
~= (([] @ [3]) @ [2]) @ [1]
~= [3;2;1] (by the meaning of append)
</code></pre>

<p>But, what we really want to show is it reverses ANY list.. use induction!</p>

<p>Let P(n) mean “for any list l of length n, <code>rev l ~=</code> its reverse”.</p>

<p>Recall an induction principle:<br />
To show P(n) for all in, it suffices to show <br />
  1) P(0), and <br />
  2) P(k) holds implies P(k+1) holds for any natural number k.</p>

<ul>
  <li>Induction is not explained well by mathematicians which causes confusion</li>
  <li>It is easier for us CS-ers, the induction step 2) is really just a <strong>proof macro</strong> with k a parameter</li>
  <li>Induction is justified by repeatedly instantiating the macro for 1,2,3,..</li>
</ul>

<p>So, if we showed 1) and 2) above,</p>
<ul>
  <li>P(0) is true by 1)</li>
  <li>P(1) is true because letting k=0 in 2) we have P(0) implies P(1),<br />
  and we just showed we have P(0), so we also have P(1).</li>
  <li>P(2) is true because letting k=1 in 2) we have P(1) implies P(2),<br />
  and we just showed we have P(1), so we also have P(2).</li>
  <li>P(3) is true because letting k=2 in 2) we have P(2) implies P(3),<br />
  and we just showed we have P(2), so we also have P(3).</li>
  <li>… etc for all k</li>
</ul>

<p>Let us now prove by induction.</p>

<p>Theorem: For any list <code>l</code> of length n, <code>rev l ~=</code> the reverse of <code>l</code> .<br />
Proof.  Proceed by induction to show this property for any n.<br />
  1) for n = 0, <code>l ~= []</code> since that is the only 0-length list.<br />
     <code>rev [] ~= []</code> which is <code>[]</code> reversed, check!<br />
  2) Assume for any k-length list <code>l</code> that <code>rev l ~= l</code> reversed.<br />
     Show for any k+1 length list, i.e. for any list <code>x :: l</code><br />
     that <code>rev (x :: l) ~= (x :: l)</code> reversed:</p>

<p>OK, by computing, <code>rev (x :: l) ~= rev l @ [x]</code>.<br />
Now by the induction hypothesis, <code>rev l</code> is <code>l</code> reversed.<br />
So, since <code>(l</code> reversed<code>) @ [x]</code> reverses the whole list <code>x :: l</code>,<br />
<code>rev (x :: l) ~= (x :: l)</code> reversed.<br />
This completes the induction step.</p>

<p>QED.</p>

<p><a name="iii"></a></p>

<h2 id="ocaml-lecture-iii">OCaml Lecture III</h2>

<h3 id="tuples">Tuples</h3>

<p>Think of tuples as fixed length lists, where the types of each element can differ, unlike lists</p>

<pre><code class="language-ocaml">(2, "hi");;        (* type is int * string -- '*' is like "x" of set theory, a product *)
let tuple = (2, "hi");;
(1,1.1,'c',"cc");;
</code></pre>
<p>Tuple pattern matching</p>
<pre><code class="language-ocaml">let tuple = (2, "hi", 1.2);;

match tuple with
  (f, s, th) -&gt; s;;

(* shorthand for the above - only one pattern, can use let syntax *)
let (f, s, th) = tuple in s;;
</code></pre>

<h4 id="consequences-of-immutable-variable-declarations-on-the-top-loop">Consequences of immutable variable declarations on the top loop</h4>

<ul>
  <li>All variable declarations in OCaml are <strong>immutable</strong> – value will never change</li>
  <li>Helps in reasoning about programs, we know the variable’s value is fixed</li>
  <li>But can be confusing when shadowing (re-definition) happens</li>
</ul>

<p>Consider the following sequence of inputs into the top loop:</p>
<pre><code class="language-ocaml">let y = 3;;
let x = 5;;
let f z = x + z;;
let x = y;; (* this is a shadowing re-definition, not an assignment! *)
f y;; (* 3 + 3 or 5 + 3 - ??   Answer: the latter. *)
</code></pre>

<ul>
  <li>To understand the above, realize that the top loop is conceptually an open-ended series of let-ins which never close:</li>
</ul>

<pre><code class="language-ocaml">(let y = 3 in
 ( let x = 5 in
   ( let f z = x + z in
     ( let x = y in  (* this is a shadowing re-definition of x, NOT an assignment *)
       (f y)
     )
   )
 )
)
;;
</code></pre>

<p>The above might make more sense if you consider similar-in-spirit C pseudo-code:</p>
<pre><code class="language-c"> { int y = 3;
   { int x = 5;
     { int (int) f = z -&gt; return(x + z); (* imagining higher-order functions in C *)
       { int x = y; (* shadows previous x in C *)
         return(f(y)); 
  }}}})
</code></pre>

<p>Function definitions are similar, you can’t mutate an existing definition.</p>

<pre><code class="language-ocaml">let f x = x + 1;;
let g x = f (f x);;
let shad = f;; (* make a new name for f above *)
(* lets "change" f, say we made an error in its definition above *)
let f x = if x &lt;= 0 then 0 else x + 1;;
g (-5);; (* g still refers to the initial f - !! *)
let g x = f (f x);; (* FIX to get new f: resubmit (identical) g code *)
g (-5);; (* works now *)
</code></pre>

<ul>
  <li>Moral: don’t code (too much) directly in the top-loop since this behavior can cause anomalies</li>
  <li>For Assignment 1, you will be able to say <code>dune test</code> in the terminal to run tests on your code, and <code>dune utop</code> will load it all into <code>utop</code> so you can then play with your functions.</li>
</ul>

<h4 id="mutually-recursive-functions">Mutually recursive functions</h4>

<p>Warm up to the next function - write a (useless) copy function on lists</p>

<pre><code class="language-ocaml">let rec copy l =
  match l with
  | [] -&gt; []
  | hd :: tl -&gt;  hd::(copy tl);;

let result = copy [1;2;3;4;5;6;7;8;9;10]
</code></pre>
<ul>
  <li>Argue by induction that this will copy the input list <code>l</code>.</li>
  <li>(List copy is in fact useless because lists are immutable - compiler can <em>share</em>)
    <ul>
      <li>This property is a form of <em>referential transparency</em></li>
    </ul>
  </li>
</ul>

<p>Refine copy to flip back and forth between copying and not</p>

<pre><code class="language-ocaml">let rec copyodd l = match l with
  | [] -&gt; []
  | hd :: tl -&gt;  hd::(copyeven tl)
and  (* new keyword for declaring mutually recursive functions *)
  copyeven l = match l with
  |  [] -&gt; []
  | x :: xs -&gt; copyodd xs;;

copyodd [1;2;3;4;5;6;7;8;9;10];;
copyeven [1;2;3;4;5;6;7;8;9;10];;
</code></pre>

<h3 id="using-let--in-to-define-local-functions">Using <code>let .. in</code> to define local functions</h3>

<p>Here is a version that hides the <code>copyeven</code> function – make both internal and export one</p>

<pre><code class="language-ocaml">let copyodd ll =
  let rec copyoddlocal l = match l with
    |  [] -&gt; []
    | hd :: tl -&gt;  hd::(copyevenlocal tl)
  and
    copyevenlocal l = match l with
    |        [] -&gt; []
    | x :: xs -&gt; copyoddlocal xs
  in
  copyoddlocal ll;;

assert(copyodd [1;2;3;4;5;6;7;8;9;10] = [1;3;5;7;9]);;
</code></pre>

<ul>
  <li>If functions are <em>only</em> used locally, use this syntax to define them locally and avoid polluting rest of code.</li>
</ul>

<h3 id="higher-order-functions">Higher Order Functions</h3>

<p>Higher order functions are functions that either</p>
<ul>
  <li>take other functions as arguments</li>
  <li>or return functions as results</li>
  <li>or both</li>
</ul>

<p>Why?</p>
<ul>
  <li>“pluggable” programming by passing in and out chunks of code</li>
  <li>greatly increases reusability of code since any varying code can be pulled out as a function to pass in</li>
  <li>Lets show the power by extracting out some pluggable code</li>
</ul>

<p>Example: append <code>"gobble"</code> to each word in a list of strings</p>

<pre><code class="language-ocaml">let rec appendgobblelist l =
  match l with
  | [] -&gt; []
  | hd::tl -&gt; (hd ^"gobble") :: appendgobblelist tl;;

appendgobblelist ["have";"a";"good";"day"];;
("have" ^"gobble") :: ("a"^"gobble") :: appendgobblelist ["good";"day"];;
</code></pre>

<ul>
  <li>Lets pull out the “append gobble” action as a function parameter, make it code we can plug in</li>
  <li>At a high level, the common pattern is “apply a given operation to every list element”</li>
  <li>The resulting function is called <code>map</code> (note it is built-in as <code>List.map</code>):
    <pre><code class="language-ocaml">let rec map f l =  (* function f is an argument here *)
match l with
| [] -&gt; []
| hd::tl -&gt; (f hd) :: map f tl;;
</code></pre>
  </li>
</ul>

<pre><code class="language-ocaml">let middle = map (function s -&gt; s^"gobble");;
middle ["have";"a";"good";"day"];;
</code></pre>

<p>Mapping on lists of pairs - in and out lists can be different types.</p>
<pre><code class="language-ocaml">map (fun (x,y) -&gt; x + y) [(1,2);(3,4)];;
let flist = map (fun x -&gt; (fun y -&gt; x + y)) [1;2;4] ;; (* make a list of functions - why not? *)
</code></pre>
<ul>
  <li>This aligns with the type of <code>map</code>, <code>('a -&gt; 'b) -&gt; 'a list -&gt; 'b list </code> - <code>'a</code> and <code>'b</code> can differ.</li>
</ul>

<p><a name="iv"></a></p>

<h2 id="ocaml-lecture-iv">OCaml Lecture IV</h2>

<h3 id="folds">Folds</h3>

<ul>
  <li>fold_left/right use a binary function to combine list elements</li>
  <li>As with <code>map</code> let us first write a concrete combiner and then pull out the particular combination code as a parameter</li>
</ul>

<h4 id="folding-right">Folding right</h4>

<pre><code class="language-ocaml">let rec summate_right l init = match l with
    | []   -&gt; init
    | hd::tl -&gt;  (+) hd (summate_right tl init) (* assume by induction this will summate tl, add hd *)
    ;;
summate_right [1;2;3] 0;;
</code></pre>

<pre><code class="language-ocaml">let rec fold_right f l init = match l with
  | [] -&gt; init
  | hd::tl -&gt; f hd (fold_right f tl init) (* same code as above just extracting (+) as a parameter *)
;;
let summate_right' = fold_right (+);;
fold_right (+) [1;2;3] 0;; (* = (1+(2+(3+0))) - observe the 0 is on the right *)
</code></pre>

<ul>
  <li>Many functions on lists have this common skeleton and can be written succinctly with <code>fold_right</code></li>
  <li>(It is so important that it is in the standard library as well, as <code>List.fold_right</code>)</li>
</ul>

<pre><code class="language-ocaml">let filter f l = List.fold_right (fun elt accum -&gt; if f elt then elt::accum else accum) l [];; 
let rev l = List.fold_right (fun elt accum -&gt; accum @ [elt]) l [];;
let map f l = List.fold_right (fun elt accum -&gt; (f elt)::accum) l [];;
</code></pre>

<h4 id="folding-left">Folding left</h4>

<ul>
  <li><code>fold_left</code> accumulates “on the way down” (we pass down the accumulated value), whereas <code>fold_right</code> accumulated “on the way up”</li>
  <li>It is a little less intuitive at first so let us again do a concrete case and extract the general one.</li>
  <li>In <code>fold_right</code> we kept passing down the same <code>init</code> value; in the left approach we instead pass down the currently accumulated <em>result</em>, <code>accum</code>.</li>
  <li>List and value arguments are swapped compared to <code>fold_right</code>, be careful !</li>
</ul>

<pre><code class="language-ocaml">let rec summate_left accum l = match l with
    | []   -&gt; accum
    | hd::tl -&gt; summate_left ((+) accum hd) tl (* pass down accum + hd as new "accum" -- accumulating *)
    ;;
summate_left 0 [1;2;3];; (* = summate_left (0+1) [2;3] = summate_left (1+2) [3] = summate_left (3+3) [] = 6 *)
</code></pre>

<ul>
  <li>Again let us extract the <code>(+)</code> as a new parameter <code>f</code> to get a general template for this</li>
</ul>

<pre><code class="language-ocaml">let rec fold_left f accum l = match l with
    | []   -&gt; accum
    | hd::tl -&gt; fold_left f (f accum hd) tl
    ;;
</code></pre>

<ul>
  <li>Type is <code>('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'a</code> which parenthesizes as <code>('a -&gt; 'b -&gt; 'a) -&gt; ('a -&gt; ('b list -&gt; 'a))</code></li>
</ul>

<p>Summing elements of a list can now be succinctly coded:</p>
<pre><code class="language-ocaml">fold_left (+) 0 [1;2;3];;
</code></pre>

<ul>
  <li>As with <code>fold_right</code> this skeleton lets us plug in different <code>f</code> to make many natural functions on lists.</li>
</ul>

<pre><code class="language-ocaml">let length l = List.fold_left (fun accum elt -&gt; accum + 1) 0 l;; (* adds accum, ignores elt *)
let rev l = List.fold_left (fun accum elt -&gt; elt::accum) [] l;; (* e.g. rev [1;2;3] = (3::(2::(1::[]))) *)
</code></pre>

<p>Example where left and right folds produce a different result:</p>

<pre><code class="language-ocaml">fold_left (fun elt -&gt; fun accum -&gt; "("^elt^"+"^accum^")") "0" ["1";"2";"3"] ;; 
fold_right (fun accum -&gt; fun elt -&gt; "("^accum^"+"^elt^")") ["1";"2";"3"] "0" ;; 
</code></pre>

<h3 id="pipeling-and-composition">Pipeling and composition</h3>

<p>Pipelining Example: get the nth-from the end from a list, by first reversing and then getting nth element.</p>

<p>Obvious version:</p>
<pre><code class="language-ocaml">let nth_end l n = List.nth (List.rev l) n;;
</code></pre>

<ul>
  <li>But, from the analogy of shell pipes <code>|</code>, we are “piping” the output of <code>rev</code> into <code>nth</code> for some fixed n.</li>
  <li>Here is an equivalent way to code that using OCaml pipe notation, <code>|&gt;</code></li>
</ul>

<pre><code class="language-ocaml">let nth_end l n = l |&gt; List.rev |&gt; (Fun.flip(List.nth) n);;
</code></pre>
<ul>
  <li>All <code>[1;2] |&gt; List.rev</code> in fact does is apply the second argument to the first - very simple!</li>
  <li>The type gives it away: <code>(|&gt;)</code> has type <code>'a -&gt; ('a -&gt; 'b) -&gt; 'b</code></li>
  <li>The <code>Fun.flip</code> is needed to put the list argument second, not first
    <ul>
      <li>it is another interesting higher-order function, with type <code>('a -&gt; 'b -&gt; 'c) -&gt; 'b -&gt; 'a -&gt; 'c</code>.</li>
    </ul>
  </li>
</ul>

<h4 id="function-composition-functions-in-functions-out">Function Composition: functions in, functions out</h4>

<p>Composition function g o f: take two functions, return their composition</p>
<pre><code class="language-ocaml">let compose g f = (fun x -&gt; g (f x));;
compose (fun x -&gt; x+3) (fun x -&gt; x*2) 10;;
</code></pre>

<h3 id="currying">Currying</h3>

<ul>
  <li>Names the way multi-argument functions work in OCaml</li>
  <li>Logician Haskell Curry originally came up with the idea in the 1930’s</li>
  <li>First lets recall how multi-argument functions work in OCaml</li>
</ul>

<pre><code class="language-ocaml">let add_c x y = x + y;;
add_c 1 2;; (* recall this is the same as '(add_c 1) 2' *)
let tmp = add_c 1 in tmp 2;; (* the partial application of arguments - tmp is a function *)
(* An equivalent way to define `add_c`, clarifying what the above means *)
let add_c = fun x -&gt; (fun y -&gt; x + y);;
(* and, yet another identical way .. *)
let add_c = fun x y -&gt; x + y;;
(* yet one more, the built-in (+) *)
(+);;
</code></pre>

<p>Here is the so-called non-Curried version: use a <em>pair of arguments</em> instead</p>
<pre><code class="language-ocaml">let add_nc p =
    match p with (x,y) -&gt; x+y;;
</code></pre>

<p>Here is an equivalent OCaml syntax which looks like a standard C function</p>
<ul>
  <li>This is <em>still</em> a one-argument function, but you can pattern match in a function parameter
    <pre><code class="language-ocaml">let add_nc (x, y) = x + y;;
</code></pre>
  </li>
  <li>Notice how the type of <code>add_nc</code> differs from <code>add_c</code>: <code>int * int -&gt; int</code> vs <code>int -&gt; int -&gt; int</code>.</li>
  <li>Fact: these two approaches to defining a 2-argument function are isomorphic:<br />
<code>'a * 'b -&gt; 'c</code> ~= <code>'a -&gt; 'b -&gt; 'c</code></li>
  <li>(This isomorphism also holds in set theory, you may have already seen it)</li>
</ul>

<p>To “prove” this we make functions to convert from one form to the other</p>
<ul>
  <li><code>curry</code>   - takes in non-curry’ing 2-arg function and returns a curry’ing version</li>
  <li><code>uncurry</code> - takes in curry’ing 2-arg function and returns an non-curry’ing version</li>
</ul>

<p>Since we can then go back and forth between the two representations, they are <strong>isomorphic</strong>.</p>

<pre><code class="language-ocaml">let curry fnc = fun x -&gt; fun y -&gt; fnc (x, y);;
let uncurry fc = fun (x, y) -&gt; fc x y;;

let new_add_nc = uncurry add_c;;
new_add_nc (2,3);;
let new_add_c  = curry   add_nc;;
new_add_c 2 3;;
</code></pre>

<p>Observe the types themselves pretty much specify the behavior</p>
<pre><code class="language-ocaml">curry : ('a * 'b -&gt; 'c) -&gt; 'a -&gt; 'b -&gt; 'c
uncurry : ('a -&gt; 'b -&gt; 'c) -&gt; 'a * 'b -&gt; 'c
</code></pre>

<pre><code class="language-ocaml">let noop1 = curry (uncurry add_c);; (* a no-op *)
let noop2 = uncurry (curry add_nc);; (* another no-op; noop1 &amp; noop2 together show isomorphism *)
</code></pre>
<h3 id="misc-ocaml">Misc OCaml</h3>

<p>See <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Stdlib.html">module Stdlib</a> for various functions available in the OCaml top-level like <code>+</code>, <code>^</code> (string append), <code>print_int</code> (print an integer), etc.</p>

<p>See <a href="http://caml.inria.fr/pub/docs/manual-ocaml/stdlib.html">the Standard Library</a> for modules of functions for <code>List</code>s, <code>String</code>s, <code>Int</code>egers, as well as <code>Set</code>s, <code>Map</code>s, etc, etc.</p>

<pre><code class="language-ocaml">print_string ("hi\n");;
</code></pre>

<p>Some <code>Stdlib</code> built-in exception generating functions (more on exceptions later)</p>
<pre><code class="language-ocaml">(failwith "BOOM!") + 3 ;;
</code></pre>

<p>Invalid argument exception <code>invalid_arg</code>:</p>
<pre><code class="language-ocaml">let f x = if x &lt;= 0 then invalid_arg "Let's be positive, please!" else x + 1;;
f (-5);;
</code></pre>

<ul>
  <li>OCaml infers types most of the time</li>
  <li>But, you can optionally declare types on any expression</li>
  <li>Put parens around any such declaration as in the examples</li>
  <li>It is good practice to paste in the inferred types in your code to have types as documentation</li>
</ul>

<pre><code class="language-ocaml">let add (x: float) (y: float) = x +. y;;
let add (x: int) (y: int) = (((x: int) + y) : int);;
</code></pre>

<p>Type abbreviations are also possible via keyword <code>type</code></p>
<pre><code class="language-ocaml">type intpair = int * int;;
let f (p : intpair) = match p with
                      (l, r) -&gt; l + r
;;
(2,3);; (* ocaml doesn't call this an intpair by default *)
f (2, 3);; (* still, can pass it to the function expecting an intpair *)
((2,3):intpair);; (* can also explicitly tag data with its type *)
</code></pre>

<h3 id="solving-some-simple-problems">Solving some simple problems</h3>

<p>Some practice problems and their solutions which will not have time to cover in lecture.</p>

<ol>
  <li>Write a function <code>to_upper_case</code> which takes a list (l) of characters and returns a list which has the same characters as l, but capitalized (if not already).</li>
</ol>

<p>Notes: <br />
a. Assume that the capital of characters other than alphabets<br />
            (A - Z or a - z), are the characters themselves e.g.</p>

<pre><code>                character               corresponding capital character

                    a                             A
                    z                             Z
                    A                             A
                    1                             1
                    %                             %
</code></pre>

<p>b. You can only use <code>Char.code</code> and <code>Char.chr</code> library functions. You <strong>cannot</strong> use <code>Char.uppercase</code>.</p>

<p><strong>Answer:</strong></p>
<pre><code class="language-ocaml">let to_upper_char c =
  let c_code = Char.code c in
  if c_code &gt;= 97 &amp;&amp; c_code &lt;= 122 then
    Char.chr (c_code - 32)
  else c;;


let rec to_upper_case l =
  match l with
    [] -&gt; []
  | c :: cs -&gt; to_upper_char c :: to_upper_case cs
;;
</code></pre>

<p>Test</p>
<pre><code class="language-ocaml">assert(to_upper_case ['a'; 'q'; 'B'; 'Z'; ';'; '!'] = ['A'; 'Q'; 'B'; 'Z'; ';'; '!']);;
</code></pre>

<p>Could have used map instead (note map is built in as <code>List.map</code>):</p>

<pre><code class="language-ocaml">let to_upper_case l = List.map to_upper_char l ;;
</code></pre>

<p>Could have also defined it even more simply - partly apply the Curried map:</p>

<pre><code class="language-ocaml">let to_upper_case = List.map to_upper_char ;;
</code></pre>

<ol>
  <li>Write a function <code>partition</code> which takes a predicate (<code>p</code>) and a list (<code>l</code>) as arguments  and returns a tuple <code>(l1, l2)</code> such that <code>l1</code> is the list of all the elements of <code>l</code> that satisfy the predicate p and l2 is the list of all the elements of <code>l</code> that do NOT satisfy <code>p</code>. The order of the elements in the input list (<code>l</code>) should be preserved.</li>
</ol>

<p>Note: A predicate is any function which returns a boolean. e.g. <code>let is_positive n = (n &gt; 0);;</code></p>

<p><strong>Answer:</strong></p>
<pre><code class="language-ocaml">let rec partition p l =
  match l with
  |[] -&gt; ([],[])
  | hd :: tl -&gt;
    let (posl,negl) = partition p tl in
    if (p hd)
    then
      (hd :: posl,negl)
    else
      (posl,hd::negl);;
</code></pre>
<p>Test</p>

<pre><code class="language-ocaml">let is_positive n = n &gt; 0 in
assert(partition isPositive [1; -1; 2; -2; 3; -3] = ([1; 2; 3], [-1; -2; -3]))
</code></pre>

<ol>
  <li>Write a function <code>diff</code> which takes in two lists l1 and l2 and returns a list containing all elements in l1 not in l2.</li>
</ol>

<p>Note: You will need to write another function <code>contains x l</code> which checks  whether an element <code>x</code> is contained in a list <code>l</code> or not.</p>

<p><strong>Answer:</strong></p>
<pre><code class="language-ocaml">let rec contains x l =
  match l with
    [] -&gt; false
  | y :: ys -&gt; x = y || contains x ys
;;

let rec diff l1 l2 =
  match l1 with
    [] -&gt; []
  | x :: xs -&gt;
      if contains x l2 then
    diff xs l2
      else
    x :: diff xs l2
;;
</code></pre>

<p>Tests</p>
<pre><code class="language-ocaml">assert(contains 1 [1; 2; 3])
assert(not(contains 5 [1; 2; 3]))
assert(diff [1;2;3] [3;4;5] = [1; 2])
assert(diff [1;2] [1;2;3] = [])
</code></pre>

<h3 id="variants">Variants</h3>

<p>We saw a simple examples of variants above, the <code>option</code> type; now we go into the full possibilities</p>
<ul>
  <li>Related to <code>union</code> types in C or <code>enum</code>s in Java: “this OR that OR theother”</li>
  <li>Like OCamls lists/tuples they are <strong>immutable</strong> data structures</li>
  <li>Each case of the union is identified by a name called a ‘Constructor’ which serves for both
    <ul>
      <li>constructing values of the variant type</li>
      <li>destructing them by pattern matching</li>
    </ul>
  </li>
  <li>Constructors must start with Capital Letter to distinguish from variables</li>
  <li>The <code>of</code> indicates what type is under the wrapper</li>
  <li>Type declarations are needed but once they are in place type inference on them works</li>
</ul>

<p>Example of how to declare a new variant type for doing mixed arithmetic (integers and floats)</p>

<pre><code class="language-ocaml">type mynumber = Fixed of int | Floating of float;;  (* read "|" as "or" *)

Fixed(5);; (* tag 5 as a Fixed *)
Floating 4.0;; (* tag 4.0 as a Floating *)
</code></pre>

<p>Note constructors look like functions but they are <strong>not</strong> – you always need to give the argument</p>

<p>Destruct variants by pattern matching like we did for <code>Some/None</code> option type values:</p>

<pre><code class="language-ocaml">let ff_as_int x =
    match x with
    | Fixed n -&gt; n    (* variants fit well into pattern matching syntax *)
    | Floating z -&gt; int_of_float z;;

ff_as_int (Fixed 5);;
</code></pre>

<p>A non-trivial function using the above variant</p>

<pre><code class="language-ocaml">let add_num n1 n2 =
   match (n1, n2) with    (* note use of pair here to parallel-match on two variables  *)
     | (Fixed i1, Fixed i2) -&gt;       Fixed   (i1       +  i2)
     | (Fixed i1,   Floating f2) -&gt;  Floating(float i1 +. f2)       (* need to coerce *)
     | (Floating f1, Fixed i2)   -&gt;  Floating(f1       +. float i2) (* ditto *)
     | (Floating f1, Floating f2) -&gt; Floating(f1       +. f2)
;;

add_num (Fixed 123) (Floating 3.14159);;
</code></pre>

<p>Multiple data items in a single variant case?  Use tuple types</p>

<pre><code class="language-ocaml">type complex = CZero | Nonzero of float * float;;

let com = Nonzero(3.2,11.2);;
let zer = CZero;;
</code></pre>

<h4 id="recursive-data-structures">Recursive data structures</h4>
<ul>
  <li>A key use of variant types</li>
  <li>Functional programming is fantastic for computing over tree-structured data</li>
  <li>Recursive types can refer to themselves in their own definition</li>
  <li>Similar in spirit to how C structs can be recursive (but, no pointer needed here)</li>
</ul>

<p>Warm-up: homebrew lists - built-in list type not needed<br />
First just int lists</p>

<pre><code class="language-ocaml">type myintlist = Mt | Cons of int * myintlist;; (* Observe: self-referential type *)
let mylisteg = Cons(3,Cons(5,Cons(7,Mt)));; (* equivalent to [3;5;7] *)
</code></pre>
<p>Let us extend the above to be just like built-in polymorphic lists</p>

<pre><code class="language-ocaml">type 'a mylist = Mt | Cons of 'a * ('a mylist);;
</code></pre>
<ul>
  <li>Observe how above type takes a (prefix) argument, <code>'a</code> – <code>mylist</code> is a type function</li>
  <li>Perhaps better syntax would have been <code>type mylist(t) = Mt | Cons of t * (mylist(t))</code></li>
  <li>This <code>'a</code> is not the same as the generic type <code>'a</code> - can be confusing</li>
</ul>

<pre><code class="language-ocaml">let mylisteg = Cons(3,Cons(5,Cons(7,Mt)));;
</code></pre>
<p>Coding is very similar to built-in lists</p>
<pre><code class="language-ocaml">let rec map ml f =
  match ml with
    | Mt -&gt; Mt
    | Cons(hd,tl) -&gt; Cons(f hd,map tl ~f)

let map_eg = map hb_eg (fun x -&gt; x - 1) mylisteg
</code></pre>

<p><a name="v"></a></p>

<h2 id="ocaml-lecture-v">OCaml Lecture V</h2>

<h4 id="trees">Trees</h4>

<ul>
  <li>Binary trees are like lists but with two self-referential sub-structures not one</li>
  <li>Here is one tree definition; note the data is (only) in the nodes here</li>
  <li>n-ary trees are a direct generalization of this pattern</li>
</ul>

<pre><code class="language-ocaml">type 'a btree = Leaf | Node of 'a * 'a btree * 'a btree;;
</code></pre>

<p>Example trees</p>

<pre><code class="language-ocaml">let whack = Node("whack!",Leaf, Leaf);;
let bt = Node("fiddly ",
            Node("backer ",
               Leaf,
               Node("crack ",
                  Leaf,
                  Leaf)),
            whack);;

let bt2 = Node("fiddly ",
            Node("backer ",
               Leaf,
               Node("crack ",
                  Leaf,
                  Leaf)),
            whack);;
(* Type error; like lists, tree data must have uniform type: *)
Node("fiddly",Node(0,Leaf,Leaf),Leaf);;
</code></pre>

<p>Functions on binary trees are similar to functions on lists: use recursion</p>

<pre><code class="language-ocaml">let rec add_gobble binstringtree =
   match binstringtree with
     Leaf -&gt; Leaf
   | Node(y, left, right) -&gt;
       Node(y^"gobble",add_gobble left,add_gobble right)
;;
</code></pre>
<p>(Remember, as with lists this is <em>not</em> mutating the tree, its building a new one)</p>

<pre><code class="language-ocaml">let rec lookup x bintree =
  match bintree with
  | Leaf -&gt; false
  | Node(y, left, right) -&gt;
    if x = y then
      true
    else if x &lt; y then
      lookup x left
    else
      lookup x right
;;

lookup "whack!" bt;;
lookup "flack" bt;;
</code></pre>

<p>Let us now define how to insert an element in sorted order.</p>
<pre><code class="language-ocaml">let rec insert x bintree =
   match bintree with
     Leaf -&gt; Node(x, Leaf, Leaf)
   | Node(y, left, right) -&gt;
       if x &lt;= y then
         Node(y, insert x left, right)
       else
         Node(y, left, insert x right)
;;
</code></pre>

<ul>
  <li>This is also <strong>not mutating</strong> – it returns a whole new tree - !</li>
  <li>If you then want to insert another element you need to pass the result from the previous call.</li>
</ul>

<pre><code class="language-ocaml">let goobt = insert "goober " bt;;
bt;; (* observe bt did not change after the insert *)
let gooobt = insert "slacker " goobt;; (* pass in goobt to accumulate both additions *)
let manyt = List.fold_left (Fun.flip insert) Leaf ["one";"two";"three";"four"] (* folding helps *)
</code></pre>

<ul>
  <li>You have already seen a bit of programming with functional data structures with lists</li>
  <li>For trees you are probably used to mutating to insert, delete, etc so takes some getting used to</li>
  <li>It looks really inefficient since an insertion is making a “totally new tree”
    <ul>
      <li>but, the compiler can in fact share all subtrees along the spine to the new node - log n cost</li>
      <li>referential transparency at work</li>
    </ul>
  </li>
</ul>

<h3 id="end-core-ocaml-used-in-the-course">End Core OCaml used in the course</h3>

<ul>
  <li>The bulk of the assignments only use what we covered above</li>
  <li>We now will quickly cover a few more features which we will not use nearly as much
    <ul>
      <li>(they will also not be covered in assignment 2)</li>
    </ul>
  </li>
</ul>

<h3 id="records">Records</h3>
<ul>
  <li>Like tuples but with labels on fields.</li>
  <li>Similar to the structs of C/C++.</li>
  <li>The types must be declared just like OCaml variants.</li>
  <li>Can be used in pattern matches as well.</li>
  <li>Again the fields are <strong>immutable</strong> by default, so not like Python/Javascript dictionaries</li>
</ul>

<p>Example: a record type to represent rational numbers</p>

<pre><code class="language-ocaml">type ratio = {num: int; denom: int};;
let q = {num = 53; denom = 6};;
</code></pre>

<p>Destructing records via pattern matching:</p>
<pre><code class="language-ocaml">let rattoint r =
 match r with
   {num = n; denom = d} -&gt; n / d;;
</code></pre>

<p>Only one pattern matched so can again inline pattern in function’s/let’s</p>
<pre><code class="language-ocaml">let rat_to_int {num = n; denom = d} =  n / d;;
</code></pre>

<p>Equivalently could use dot projections, but happy path in OCaml is usually patterns</p>
<pre><code class="language-ocaml">let unhappy_rat_to_int r  =
   r.num / r.denom;;
</code></pre>

<p>One more example function with records</p>
<pre><code class="language-ocaml">let unhappy_add_ratio r1 r2 = 
  {num = r1.num * r2.denom + r2.num * r1.denom; 
   denom = r1.denom * r2.denom};;

unhappy_add_ratio {num = 1; denom = 3} {num = 2; denom = 5};;

let happy_add_ratio {num = n1; denom = d1} {num = n2; denom = d2} = 
  {num = n1 * d2 + n2 * d1; denom = d1 * d2};;
</code></pre>

<h4 id="end-of-pure-functional-programming-in-ocaml">End of Pure Functional programming in OCaml</h4>
<ul>
  <li>On to side effects</li>
  <li>But before heading there, remember to stay OUT of side effects unless <em>really</em> needed - that is the happy path in OCaml coding</li>
  <li>The autograder may let you get away with side effects on assignment 1/2 but you will get a manual ding by the CAs.</li>
</ul>

<h3 id="state">State</h3>
<ul>
  <li>Variables in OCaml are NEVER directly mutable themselves; only (indirectly) mutable if they hold a
    <ul>
      <li>reference</li>
      <li>mutable record</li>
      <li>array</li>
    </ul>
  </li>
</ul>

<p>Indirect mutability - variable itself can’t change, but what it points to can.</p>
<ul>
  <li>items are immutable unless their mutability is explicitly declared</li>
</ul>

<h3 id="mutable-references">Mutable References</h3>

<pre><code class="language-ocaml">let x = ref 4;;    (* always have to declare initial value when creating a reference *)
</code></pre>

<p>Meaning of the above: x forevermore (i.e. forever unless shadowed) refers to a fixed cell.  The <strong>contents</strong> of that fixed call can change, but not x.</p>

<pre><code class="language-ocaml">x + 1;; (* a type error ! *)
!x + 1;; (* need `!x` to get out the value; parallels `*x` in C *)
x := 6;; (* assignment - x must be a ref cell.  Returns () - goal is side effect *)
!x;; (* Mutation happened to contents of cell x *)
let x = ref "hi";; (* does NOT mutate x above, instead another shadowing definition *)
</code></pre>

<ul>
  <li><code>'a ref</code> is really implemented by a mutable record with one field, contents:</li>
  <li><code>'a ref</code> abbreviates the type <code>{ mutable contents: 'a }</code></li>
  <li>The keyword mutable on a record field means it can mutate</li>
</ul>

<pre><code class="language-ocaml">let x = { contents = 4};; (* identical to x's definition above *)
x := 6;;
x.contents &lt;- 7;;  (* same effect as previous line: backarrow updates a field *)

!x + 1;;
x.contents + 1;; (* same effect as previous line *)
</code></pre>

<p>Declaring your own mutable record: put <code>mutable</code> qualifier on field</p>

<pre><code class="language-ocaml">type mutable_point = { mutable x: float; mutable y: float };;
let translate p dx dy =
                p.x &lt;- (p.x +. dx); (* observe use of ";" here to sequence effects *)
                p.y &lt;- (p.y +. dy)  (* ";" is useless without side effects (think about it) *)
                                ;;
let mypoint = { x = 0.0; y = 0.0 };;
translate mypoint 1.0 2.0;;
mypoint;;
</code></pre>

<p>Observe: mypoint is immutable at the top level but it has two spots in it where we can mutate</p>

<h3 id="arrays">Arrays</h3>
<ul>
  <li>Fairly self-explanatory, we will just flash over this in lecture</li>
  <li>Have to be initialized before using
    <ul>
      <li>in general there is no such thing as “uninitialized”/”null” in OCaml</li>
    </ul>
  </li>
</ul>

<pre><code class="language-ocaml">let arr = [| 4; 3; 2 |];; (* one way to make an array *)
arr.(0);; (* access (unfortunately already used [] for lists in the syntax) *)
arr.(0) &lt;- 5;; (* update *)
arr;;
</code></pre>

<h3 id="exceptions">Exceptions</h3>
<ul>
  <li>OCaml has a standard (e.g. Java-like) notion of exception</li>
  <li>Unfortunately types do not include what exceptions a function will raise - an outdated aspect of OCaml.</li>
  <li>Modern OCaml coding style is to <em>minimize</em> the use of exceptions
    <ul>
      <li>Causes action-at-a-distance, hard to debug</li>
      <li>Instead follow the old C approach of bubbling up error codes:
        <ul>
          <li>return <code>Some/None</code> and make the caller explicitly handle the <code>None</code> (error) case.</li>
          <li>Better yet use <code>Ok/Error</code>, similar to <code>Some/None</code> but designed for error handling.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Here is a tiny example of how to declare and use exceptions</p>

<pre><code class="language-ocaml">exception Goo of string;;

let f _ = raise (Goo "keyboard on fire");;
f ();;
(f ()) + 1;; (* recall that exceptions blow away the context *)

let g () =
  try
    f ()
  with (* "catch" in Java *)
      Goo s -&gt;
      (print_string("exception raised: ");
       print_string(s);print_string("\n"))
;;
g ();;
</code></pre>

<p>There are a few built-in exceptions we mentioned previously:</p>

<pre><code class="language-ocaml">failwith "Oops";; (* Generic code failure - exception is named Failure *)
invalid_arg "This function works on non-empty lists only";; (* Invalid_argument exception *)
</code></pre>

<h3 id="modules">Modules</h3>

<p>Modules in programming languages</p>
<ul>
  <li>a module is a larger level of program abstraction: functional units or library.</li>
  <li>e.g. Java package, Python module, C directory, etc</li>
  <li>needed for all but very small programs: imagine a file system without directories/folders as analogy to a PL without modules - YUCK!</li>
</ul>

<p>Some general principles of modules across language designs:</p>
<ul>
  <li>Modules have names they can be referenced by.</li>
  <li>A module is a container of code: functions, classes,  types, etc.</li>
  <li>Modules can be file-based: one module per file, module name is file name</li>
  <li>The module needs a way to
    <ul>
      <li>import things (e.g. other modules) from the outside;</li>
      <li>export some (or all) things it has declared for outsiders to use;</li>
      <li>it may <strong>hide</strong> some things for internal use only
        <ul>
          <li>allows module users to operate at a higher level of abstraction</li>
          <li>avoids users mucking with internals and messing things up</li>
        </ul>
      </li>
      <li>Separate name spaces, so e.g. the Window’s reset() won’t clash<br />
with a File’s reset(): use <code>Window.reset()</code> and <code>File.reset()</code></li>
      <li>Nested name spaces for ever larger software: <code>Window.Init.reset()</code></li>
      <li>Often modules can be compiled separately (for compiled languages)</li>
    </ul>
  </li>
</ul>

<h3 id="modules-in-ocaml">Modules in OCaml</h3>

<ul>
  <li>We already saw OCaml modules in action
    <ul>
      <li>Example: <code>List.map</code> is an invocation of the map function in the built-in <code>List</code> module.</li>
    </ul>
  </li>
  <li>Now, lets study how we can build and use our own OCaml modules</li>
  <li>(We focus here on building modules via files, but there are other methods in OCaml which we skip)</li>
</ul>

<h4 id="making-a-module">Making a module</h4>

<ul>
  <li>Assignment 1/2 require you to fill out a file <code>assignment.ml</code></li>
  <li>This is in fact creating a <em>module</em> <code>Assignment</code> (notice the first letter (only) is capped)</li>
  <li><code>dune utop</code> will load your module in the top loop</li>
  <li>You then need to write <code>Assignment.factorial 5;;</code> etc to access the functions in the module’s namespace</li>
  <li>Or, use <code>open Assignment;;</code> to make all the functions in the module available at the top level.</li>
</ul>

<h3 id="separate-compilation-with-ocaml">Separate Compilation with OCaml</h3>

<ul>
  <li>File-based modules such as <code>assignment.ml</code> are compiled separately.</li>
  <li>This is the traditional <code>javac</code>/<code>cc</code>/etc style of coding</li>
  <li>Also in the C/Java spirit it is how you write a standalone app in OCaml</li>
  <li>The underlying compiler for OCaml is <code>ocamlc</code> (or <code>ocamlopt</code>), but in this course we will give you <code>dune</code> build files
    <ul>
      <li>just use <code>dune build</code> to invoke the OCaml compiler on all the files</li>
      <li>if you are curious what actual compiler calls are happening, add <code>--verbose</code> to the build command</li>
    </ul>
  </li>
</ul>

<h3 id="an-example-of-a-separately-compiled-ocaml-program">An example of a separately-compiled OCaml program</h3>

<ul>
  <li>See <a href="http://pl.cs.jhu.edu/pl/ocaml/code/set-example.zip">set-example.zip</a> for the example we cover in lecture.</li>
</ul>

<h3 id="playing-with-the-simple_set-module">Playing with the Simple_set module</h3>
<ul>
  <li>For this example we can use terminal command <code>dune utop</code> to load the module into a fresh <code>utop</code></li>
</ul>

<pre><code class="language-sh">dune utop
</code></pre>
<pre><code class="language-ocaml">Simple_set.emptyset;; (* simple_set.ml's binary is loaded as module Simple_set *)
open Simple_set;;     (* open makes `emptyset` etc in module available without typing `Simple_set.` *)
let aset = List.fold_left (Fun.flip add) emptyset [1;2;3;4] ;;
contains 3 aset ;;
</code></pre>

<h3 id="end-of-ocaml">End of OCaml!</h3>

<ul>
  <li>If you want to learn more about software engineering in OCaml, consider taking <a href="https://pl.cs.jhu.edu/fpse">Functional Progamming in Software Engineering</a> in the fall</li>
  <li>Or, just click on the above course link for good resources to teach it to yourself.</li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: <a href="http://templated.co">TEMPLATED</a> Images: <a href="http://unsplash.com">Unsplash</a> (<a href="http://unsplash.com/cc0">CC0</a>)
				</div>			


   </body>
</html>
