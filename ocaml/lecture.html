<!DOCTYPE HTML>
<!--
 Solarize by TEMPLATED
 templated.co @templatedco
 Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
 <head>
  <title>Principles of Programming Languages</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="description" content="" />
  <meta name="keywords" content="" />
  <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
  <script src="/pl/js/jquery.min.js"></script>
  <script src="/pl/js/jquery.dropotron.min.js"></script>
  <script src="/pl/js/skel.min.js"></script>
  <script src="/pl/js/skel-layers.min.js"></script>
  <script src="/pl/js/init.js"></script>
  <noscript>
   <link rel="stylesheet" href="/pl/css/skel.css" />
   <link rel="stylesheet" href="/pl/css/style.css" />
  </noscript>
  <!--[if lte IE 8]><link rel="stylesheet" href="/pl/css/ie/v8.css" /><![endif]-->
 </head>
 <body>

  <!-- Header Wrapper -->
   <div class="wrapper style1">
   
   <!-- Header -->
    <div id="header">
     <div class="container">
       
      <!-- Logo -->
       <h1><a href="/pl/index.html" id="logo">Principles of PL</a></h1>
      
      <!-- Nav -->
       <nav id="nav">
        <ul>
         <li class="active"><a href="/pl/index.html">Home</a></li>
         <li>
          <a href="/pl/logistics.html">Logistics</a>
          <ul class="menu">
          <li><a href="/pl/logistics.html">Overview</a></li>
           <li><a href="/pl/dateline.html">Dateline</a></li>
           <li><a href="https://gradescope.com">Gradescope</a></li>
           <li><a href="https://courselore.org/courses/8683833116">Q&amp;A</a></li>
           <li><a href="/pl/contact.html">Contact Us</a></li>
          </ul>
         </li>
         <li><a href="/pl/book">The Book</a>
         <ul class="menu">
         <li><a href="/pl/book/book.pdf">The book PDF</a></li>
         <li><a href="/pl/book/dist/">The FbDK dist</a></li>
       </ul></li>

         <li><a href="/pl/ocaml/index.html">OCaml</a>
         </li>
         <li><a href="">Assignments</a>
         <ul class="menu">
         <li><a href="/pl/assignments/assignment1.html">Assignment 1</a></li>
         <li><a href="/pl/assignments/assignment2.html">Assignment 2</a></li>
         <li><a href="/pl/assignments/assignment3.html">Assignment 3</a></li>
         <li><a href="/pl/assignments/assignment4.html">Assignment 4</a></li>
         <li><a href="/pl/assignments/assignment5.html">Assignment 5</a></li>
         <li><a href="/pl/assignments/assignment6.html">Assignment 6</a></li>
         <li><a href="/pl/assignments/assignment7.html">Assignment 7</a></li>
         <li><a href="/pl/assignments/assignment8.html">Assignment 8</a></li>
         <li><a href="/pl/assignments/assignment9.html">Assignment 9</a></li>
       </ul></li>
        </ul>
       </nav>
 
     </div>
    </div>
<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/pl/css/friendly.css" />
<meta charset="utf-8" />
    
<h2 id="introduction-to-ocaml-programming">Introduction to OCaml Programming</h2>

<ul>
  <li>We will be using the OCaml language for implementing interpreters, typecheckers and the like</li>
  <li>You are not going to learn how to be an OCaml software engineer in this class however, we are just going to cover the minimal OCaml needed for these tasks</li>
  <li>Take <a href="https://pl.cs.jhu.edu/fpse">Functional Programming in Software Engineering</a> for a focus on broader uses of OCaml</li>
  <li>OCaml itself has a very minimal set of features which can build up other features, we will also follow that in our toy langauges <strong>Fb</strong>, <strong>FbV</strong>, <strong>FbR</strong>, etc.</li>
</ul>

<h3 id="what-is-ocaml">What is OCaml?</h3>
<ul>
  <li>OCaml is a <em>strongly typed functional programming language</em>
    <ul>
      <li>Strongly typed means the compiler will detect type errors; you won’t get them at runtime like in JavaScript/Python</li>
      <li>Functional means an emphasis on <em>functions</em> as a key building block and use of functions as data (functions that themselves can take functions as arguments and return functions as results)</li>
    </ul>
  </li>
</ul>

<h3 id="the-top-loop">The top loop</h3>

<ul>
  <li>We will begin exploration of OCaml in the interactive <em>top loop</em></li>
  <li>A top loop is also called a read-eval-print loop or the console window for other languages; it also works like a terminal shell</li>
  <li>To install the top loop we are using, <code>utop</code>, follow the course <a href="../index.html">OCaml install instructions</a>.</li>
  <li>To run it, just type <code>utop</code> into a terminal window.</li>
</ul>

<h4 id="simple-integer-operations-in-the-top-loop">Simple integer operations in the top loop</h4>
<p>(Note if you want to get all the code (only) of this webpage in a <code>.ml</code> file to load into your editor, download the file <a href="lecture.ml">lecture.ml</a>.)</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;;</span> <span class="c">(* ";;" denotes end of input, somewhat archaic. *)</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;;</span> <span class="c">(* give the value a name via let keyword. *)</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;;</span> <span class="c">(* can use x now *)</span>
<span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span> <span class="k">in</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;;</span> <span class="c">(* let .. in defines a local variable z *)</span>
</code></pre></div></div>

<h4 id="boolean-operations">Boolean operations</h4>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">true</span><span class="p">;;</span>
<span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="bp">false</span><span class="p">;;</span>
<span class="bp">true</span> <span class="o">||</span> <span class="bp">false</span><span class="p">;;</span>
<span class="mi">1</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;;</span> <span class="c">(* = not == for equality comparison - ! *)</span>
<span class="mi">1</span> <span class="o">&lt;&gt;</span> <span class="mi">2</span><span class="p">;;</span>  <span class="c">(* &lt;&gt; not != for not equal *)</span>
</code></pre></div></div>

<h4 id="other-basic-data--see-documentation-for-details">Other basic data – see documentation for details</h4>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">4</span><span class="o">.</span><span class="mi">5</span><span class="p">;;</span> <span class="c">(* floats *)</span>
<span class="mi">4</span><span class="o">.</span><span class="mi">5</span> <span class="o">+.</span> <span class="mi">4</span><span class="o">.</span><span class="mi">3</span><span class="p">;;</span> <span class="c">(* operations are +. etc not just + which is for ints only *)</span>
<span class="mi">30980314323422</span><span class="nc">L</span><span class="p">;;</span> <span class="c">(* 64-bit integers *)</span>
<span class="k">'</span><span class="n">c'</span><span class="p">;;</span> <span class="c">(* characters *)</span>
<span class="s2">"and of course strings"</span><span class="p">;;</span>
</code></pre></div></div>

<h4 id="simple-functions-on-integers">Simple functions on integers</h4>

<p>To declare a function <code>squared</code> with <code>x</code> its one parameter.  <code>return</code> is  implicit.</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">squared</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;;</span> 
<span class="n">squared</span> <span class="mi">4</span><span class="p">;;</span> <span class="c">(* to call a function -- separate arguments with S P A C E S *)</span>
</code></pre></div></div>
<ul>
  <li>OCaml has no <code>return</code> statement; value of the whole body-expression is what gets returned</li>
  <li>Type is automatically <strong>inferred</strong> and printed as domain <code>-&gt;</code> range</li>
  <li>OCaml functions in fact always take only one argument - !  multiple arguments can be encoded (later)</li>
</ul>

<p>Everything in OCaml returns values (i.e. is an ‘expression’) - no commands</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">then</span> <span class="p">(</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">35</span><span class="p">)</span> <span class="k">else</span> <span class="mi">6</span><span class="p">;;</span> <span class="c">(* ((x==3)?5:6)+1 in C *)</span>
<span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">then</span> <span class="mi">5</span> <span class="k">else</span> <span class="mi">6</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;;</span>
<span class="c">(* (if (x = 3) then 5.4 else 6) * 2;; *)</span> <span class="c">(* type errors:  two branches of if must have same type *)</span>
</code></pre></div></div>

<h4 id="fibonacci-series-example---0-1-1-2-3-5-8-13-">Fibonacci series example - <code>0 1 1 2 3 5 8 13 ...</code></h4>

<p>Let’s write a well-known function with recursion and if-then-else syntax</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">fib</span> <span class="n">n</span> <span class="o">=</span>     <span class="c">(* the "rec" keyword needs to be added to allow recursion *)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">1</span>
  <span class="k">else</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);;</span> <span class="c">(* notice again everything is an expression, no "return" *)</span>

<span class="n">fib</span> <span class="mi">10</span><span class="p">;;</span> <span class="c">(* get the 10th Fibonacci number *)</span>
</code></pre></div></div>

<h4 id="anonymous-functions-aka-functions-are-just-other-values">Anonymous functions aka “functions are just other values”</h4>

<ul>
  <li>Key advantage of FP: functions are just expressions; put them in variables, pass and return from other functions, etc.</li>
  <li>There is major power to this, which is why Java, Python, C++, etc have had higher-order functions added to them.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">add1</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span> <span class="c">(* a normal add1 definition *)</span>
<span class="k">let</span> <span class="n">anon_add1</span> <span class="o">=</span> <span class="p">(</span><span class="k">function</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);;</span> <span class="c">(* equivalent anonymous version; "x" is argument here *)</span>
<span class="k">let</span> <span class="n">anon_add1_fun</span> <span class="o">=</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);;</span> <span class="c">(* `function` can usually be shortened to `fun` *)</span>
<span class="n">add1</span> <span class="mi">3</span><span class="p">;;</span>
<span class="p">(</span><span class="n">add1</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">7</span><span class="p">;;</span> 
<span class="p">((</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">7</span><span class="p">;;</span> <span class="c">(* can inline anonymous function definition; makes no sense here but will later *)</span>
</code></pre></div></div>

<p><a name="ii"></a></p>

<h2 id="ocaml-lecture-ii">OCaml Lecture II</h2>

<ul>
  <li>Multiple argument functions - just leave s p a c e s between multiple arguments in both definitions and uses</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;;</span>
<span class="n">add</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">;;</span>
<span class="p">(</span><span class="n">add</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">4</span><span class="p">;;</span> <span class="c">(* same meaning as previous application -- two applications, " " associates LEFT *)</span>
<span class="k">let</span> <span class="n">add3</span> <span class="o">=</span> <span class="n">add</span> <span class="mi">3</span><span class="p">;;</span> <span class="c">(* No need to give all arguments at once!  Type of add is int -&gt; (int -&gt; int) - "CURRIED" *)</span>
<span class="n">add3</span> <span class="mi">4</span><span class="p">;;</span>
<span class="n">add3</span> <span class="mi">20</span><span class="p">;;</span>
<span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">;;</span> <span class="c">(* Putting () around any infix operator turns it into a 2-argument function: `(+)` is same as our `add` above *)</span>
</code></pre></div></div>

<p>Conclusion: <code>add</code> is a function taking an integer, and returning a <strong>function</strong> which takes ints to ints.<br />
So, <code>add</code> is in fact a <strong>higher-order function</strong>: it returns a function as result.</p>

<p>Observe <code>int -&gt; int -&gt; int</code> is parenthesized as <code>int -&gt; (int -&gt; int)</code> – unusual <strong>right</strong> associativity</p>

<p>Be careful on operator precedence with this goofy way that function application doesn’t need parens!</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add3</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);;</span>
<span class="n">add3</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;;</span> <span class="c">(* NOT the previous - this is the same as (add3 3) * 2 - application binds tighter than `*` *)</span>
<span class="n">add3</span> <span class="o">@@</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;;</span> <span class="c">(* LIKE the original - @@ is like the " " for application but binds LOOSER than other ops *)</span>
</code></pre></div></div>

<h4 id="declaring-types-in-ocaml">Declaring types in OCaml</h4>
<p>While OCaml infers types for you it is often good practice to add those types to your code, e.g.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">add</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span> <span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;;</span>
</code></pre></div></div>
<p>Note that the parentheses here are required, and the return type is at the end.</p>

<h3 id="simple-structured-data-types-option-and-result">Simple Structured Data Types: Option and Result</h3>

<ul>
  <li>Before getting into “bigger” data types and how to declare our own, let’s use one of the simplest structured data types, the built-in <code>option</code> type.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Some</span> <span class="mi">5</span><span class="p">;;</span>
<span class="c">(*  - : int option = Some 5 *)</span>
</code></pre></div></div>

<ul>
  <li>all this does is “wrap” the 5 in the <code>Some</code> tag</li>
  <li>Along with <code>Some</code>-thing 5, there can also be <code>None</code>-thing, nothing:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">None</span><span class="p">;;</span>
<span class="c">(* - : 'a option = None *)</span>
</code></pre></div></div>

<ul>
  <li>Notice these are both in the <code>option</code> type .. either you have <code>Some</code> data or you have <code>None</code>.</li>
  <li>These kinds of types with the capital-letter-named tags are called <strong>variants</strong> in OCaml; each tag wraps a different variant.</li>
  <li>The <code>option</code> type is very useful; here is a super simple example.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">nice_div</span> <span class="n">m</span> <span class="n">n</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="nc">None</span> <span class="k">else</span> <span class="nc">Some</span> <span class="p">(</span><span class="n">m</span> <span class="o">/</span> <span class="n">n</span><span class="p">);;</span>
<span class="k">val</span> <span class="n">nice_div</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">nice_div</span> <span class="mi">10</span> <span class="mi">0</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span>
<span class="o">#</span> <span class="n">nice_div</span> <span class="mi">10</span> <span class="mi">2</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">Some</span> <span class="mi">5</span>
</code></pre></div></div>

<p>There is a downside with this though, you can’t just use <code>nice_div</code> like <code>/</code>:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># (nice_div 5 2) + 7;;</span>
Line 1, characters 0-14:
Error: This expression has <span class="nb">type </span>int option
       but an expression was expected of <span class="nb">type </span>int
</code></pre></div></div>

<p>This type error means the <code>+</code> lhs should be type <code>int</code> but is a <code>Some</code> value which is not an <code>int</code>.</p>

<p>Here is a non-solution to the above showing <code>None</code> is not like <code>nil</code>/<code>null</code>/<code>NULL</code> of some other languages:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">not_nice_div</span> <span class="n">m</span> <span class="n">n</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="nc">None</span> <span class="k">else</span> <span class="n">m</span> <span class="o">/</span> <span class="n">n</span><span class="p">;;</span>
<span class="nc">Line</span> <span class="mi">1</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">47</span><span class="o">-</span><span class="mi">52</span><span class="o">:</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">int</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="k">'</span><span class="n">a</span> <span class="n">option</span>
</code></pre></div></div>
<ul>
  <li>The <code>then</code> and <code>else</code> branches must return the same type, here they do not.</li>
  <li>The <code>int</code> and <code>int option</code> types have no overlap of members!  Generally true across OCaml.</li>
</ul>

<h4 id="pattern-matching-first-example">Pattern matching first example</h4>

<p>Here is a real solution to the above issue:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">match</span> <span class="p">(</span><span class="n">nice_div</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">)</span> <span class="k">with</span> 
   <span class="o">|</span> <span class="nc">Some</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">7</span> <span class="c">(* i is bound to the result, 2 here *)</span>
   <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"This should never happen, we divided by 2"</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div></div>
<ul>
  <li>This shows how OCaml lets us <em>destruct</em> option values, via the <code>match</code> syntax.</li>
  <li><code>match</code> is similar to <code>switch</code> in C/Java/.. but is much more flexible in OCaml</li>
  <li>The LHS in OCaml can be a general pattern which binds variables (the <code>i</code> here), etc</li>
  <li>Note that we turned <code>None</code> into a runtime exception via <code>failwith</code>.</li>
</ul>

<p>Lastly, the function could itself raise an exception</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">div_exn</span> <span class="n">m</span> <span class="n">n</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">failwith</span> <span class="s2">"divide by zero is bad!"</span> <span class="k">else</span> <span class="n">m</span> <span class="o">/</span> <span class="n">n</span><span class="p">;;</span>
<span class="n">div_exn</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>This has the property of not needing a match on the result.</li>
  <li>Note that the built-in <code>/</code> also raises an exception.</li>
  <li>Exceptions are side effects though, we want to minimize their usage to avoid error-at-a-distance.</li>
  <li>The above examples show how exceptional conditions can either be handled via
    <ul>
      <li>exceptions (the most common way, e.g. how Java deals with division by 0)</li>
      <li>with Some/None in the return value; the latter is the C philosophy, C functions return <code>NULL</code> or <code>-1</code> if fail and the caller has to deal.</li>
    </ul>
  </li>
</ul>

<h3 id="everything-is-an-expression">Everything is an expression</h3>

<h3 id="lists">Lists</h3>

<ul>
  <li>Lists are pervasive in OCaml</li>
  <li>They are <strong>immutable</strong> (cannot update elements in an existing list) so while they look something like arrays or vectors they are not</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">l1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">];;</span>
<span class="k">let</span> <span class="n">l2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">];;</span>
<span class="k">let</span> <span class="n">l3</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"a"</span><span class="p">;</span> <span class="s2">"b"</span><span class="p">;</span> <span class="s2">"c"</span><span class="p">];;</span>
<span class="c">(* let l4 = [1; "a"];; *)</span> <span class="c">(* error - All elements must have same type *)</span>
<span class="k">let</span> <span class="n">l5</span> <span class="o">=</span> <span class="bp">[]</span><span class="p">;;</span> <span class="c">(* empty list *)</span>
</code></pre></div></div>

<h4 id="operations-on-lists">Operations on lists.</h4>

<ul>
  <li>Lists are represented internally as <strong>binary trees</strong> with left children all leaves.</li>
  <li>The tree nodes are <code>::</code> and are called <em>conses</em> (an historical term from Lisp)</li>
  <li>The list is then the list of these left children going down the tree.</li>
  <li><code>::</code> is also an operation to build a new list</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">3</span> <span class="o">::</span> <span class="bp">[]</span> <span class="c">(* also written [3], a singleton list -- tree with root ::, left sub tree 3, right sub tree empty list *)</span> 
<span class="k">let</span> <span class="n">l1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="p">(</span><span class="mi">2</span> <span class="o">::</span> <span class="p">(</span><span class="mi">3</span> <span class="o">::</span> <span class="bp">[]</span><span class="p">));;</span> <span class="c">(* equivalent to [1;2;3] *)</span>
<span class="k">let</span> <span class="n">l0</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">::</span> <span class="n">l1</span><span class="p">;;</span> <span class="c">(* fast, just makes one new node, left is 0 right is l1 - SHARE it *)</span>
<span class="n">l1</span><span class="p">;;</span> <span class="c">(* Notice that l1 did not change even though we put a 0 on - immutable always! *)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">@</span> <span class="p">[</span><span class="mi">4</span><span class="p">;</span> <span class="mi">5</span><span class="p">];;</span> <span class="c">(* appending lists - slower, needs to cons 3 then 2 then 1 on front of [4;5] *)</span>
</code></pre></div></div>

<p>Picture of <code>l1</code> and <code>l0</code>:</p>

<p><img src="List.png" width="300" /></p>

<h4 id="destructing-lists-with-pattern-matching">Destructing Lists with pattern matching</h4>

<ul>
  <li>You are used to using <code>.</code> (dot) to project out fields of data structures; in OCaml we instead pattern match nearly all the time</li>
  <li>Here is a simple example of pattern matching on a list to get the <em>head</em>, the first element.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">hd</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span>  <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="nc">None</span>
  <span class="o">|</span>  <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="n">x</span> <span class="c">(* the pattern x :: xs  binds x to the first elt, xs to ALL the others *)</span>
<span class="p">;;</span>
<span class="n">hd</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span> <span class="c">(* [1;2;3] is 1 :: [2;3] So the head is 1. *)</span>
<span class="n">hd</span> <span class="p">[</span><span class="mi">1</span><span class="p">];;</span> <span class="c">(* [1] is 1 :: []  So the head is 1. *)</span>
<span class="n">hd</span> <span class="bp">[]</span><span class="p">;;</span>
</code></pre></div></div>

<h4 id="append">Append</h4>

<ul>
  <li>Here is how list append is implemented with recursion on the first list
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">append</span> <span class="n">l1</span> <span class="n">l2</span> <span class="o">=</span>
<span class="k">match</span> <span class="n">l1</span> <span class="k">with</span>
<span class="o">|</span>  <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">l2</span>
<span class="o">|</span>  <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">::</span> <span class="p">(</span><span class="n">append</span> <span class="n">xs</span> <span class="n">l2</span><span class="p">)</span> <span class="c">(* assume function works for shorter lists like xs *)</span>
<span class="p">;;</span>
<span class="n">append</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">];;</span> <span class="c">(* Recall `[1;2;3]` is `1 :: [2;3]` so in first call x is 1, xs is [2;3] *)</span>
<span class="mi">1</span> <span class="o">::</span> <span class="p">(</span><span class="n">append</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">]);;</span> <span class="c">(* This is what the first recursive call is performing *)</span>
</code></pre></div>    </div>
  </li>
  <li>Pattern priority: pick the first matched clause</li>
  <li>The above two patterns are mutually exclusive so order is in fact irrelevant here</li>
</ul>

<h4 id="nth">nth</h4>

<ul>
  <li>Lists are not random access like arrays; if you want to get the nth element, you need walk the list.</li>
  <li>Notice also that pretty much any non-trivial function on lists is going to use recursion and pattern matching</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">nth</span> <span class="n">l</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span>  <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="p">(</span><span class="s2">"no "</span><span class="o">^</span><span class="p">(</span><span class="nn">Int</span><span class="p">.</span><span class="n">to_string</span> <span class="n">n</span><span class="p">)</span><span class="o">^</span><span class="s2">"th element in this list"</span><span class="p">)</span>
  <span class="o">|</span>  <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">nth</span> <span class="n">xs</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c">(* to get nth elt in list, get n-1-th elt from tail *)</span>
<span class="p">;;</span>
<span class="n">nth</span> <span class="p">[</span><span class="mi">33</span><span class="p">;</span><span class="mi">22</span><span class="p">;</span><span class="mi">11</span><span class="p">]</span> <span class="mi">0</span><span class="p">;;</span> <span class="c">(* Recall [`33;22;11]` is `33 :: [22;11]` so in first call x is 33 *)</span>
<span class="c">(* nth [33;22;11] 3;; *)</span> <span class="c">(* Hits failure case; could have instead returned Some/None *)</span>
</code></pre></div></div>

<p>Don’t use non-exhaustive pattern matches! You will get a warning (and an error in compiler):</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">dumb</span> <span class="n">l</span> <span class="o">=</span> <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
      <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="p">;;</span>
<span class="n">dumb</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span> <span class="c">(* this works to return head of list but.. *)</span>
<span class="c">(* dumb [];; *)</span> <span class="c">(* runtime error here *)</span>
</code></pre></div></div>

<p>Built-in <code>List.hd</code> is the same as <code>dumb</code> and it is often a <strong>dumb</strong> function, don’t use it unless it is 100% obvious that the list is not empty.</p>

<h3 id="list-library-functions">List library functions</h3>
<p>Fortunately many common list operations are in the <code>List</code> module in the standard library:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">nth</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">]</span> <span class="mi">2</span><span class="p">;;</span>
<span class="c">(* - : int = 3 *)</span>
</code></pre></div></div>
<ul>
  <li>We will discuss modules later, but for now just think of them as containers of a collection of functions types etc.  Something like a <code>package</code> in Java, or a Java <code>class</code> with only <code>static</code> methods.</li>
</ul>

<p>Some more handy <code>List</code> library functions</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="p">[</span><span class="s2">"d"</span><span class="p">;</span><span class="s2">"ss"</span><span class="p">;</span><span class="s2">"qwqw"</span><span class="p">];;</span>
<span class="nn">List</span><span class="p">.</span><span class="n">concat</span> <span class="p">[[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">];[</span><span class="mi">22</span><span class="p">;</span><span class="mi">33</span><span class="p">];[</span><span class="mi">444</span><span class="p">;</span><span class="mi">5555</span><span class="p">]];;</span>
<span class="nn">List</span><span class="p">.</span><span class="n">append</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">];;</span> 
<span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">]</span> <span class="o">@</span> <span class="p">[</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">];;</span> <span class="c">(* Use this equivalent infix syntax for append *)</span>
</code></pre></div></div>

<ul>
  <li>Type <code>#show List;;</code> into utop to get a dump of all the functions in <code>List</code>.</li>
  <li>NOTE: for assignment 1 you cannot use these <code>List.</code> functions, we want you to first practice using recursion.</li>
  <li>The <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html">Standard Library Reference page for lists</a> contains descriptions as well.</li>
  <li>There are similar modes for <code>Int</code>, <code>String</code>, <code>Float</code>, etc modules which similarly contain handy functions.</li>
</ul>

<h4 id="types-of-these-library-functions">Types of these library functions</h4>

<ul>
  <li>The types of the functions are additional hints to their purpose, get used to reading them</li>
  <li>Much of the time when you mis-use a function you will get a type error</li>
  <li><code>'a list</code> etc is a polymorphic aka generic type, <code>'a</code> can be <em>any</em> type. more later on that
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">length</span><span class="p">;;</span>
<span class="c">(* - : 'a list -&gt; int = &lt;fun&gt; *)</span>
<span class="nn">List</span><span class="p">.</span><span class="n">concat</span><span class="p">;;</span>
<span class="c">(* - : 'a list list -&gt; 'a list = &lt;fun&gt; *)</span>
<span class="nn">List</span><span class="p">.</span><span class="n">append</span><span class="p">;;</span>
<span class="c">(* - : 'a list -&gt; 'a list -&gt; 'a list = &lt;fun&gt; *)</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="correctness-of-recursive-functions">Correctness of recursive Functions</h3>

<p>Consider list reverse (no need to code as it is <code>List.rev</code>; this is just an example):</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">rev</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span>  <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">rev</span> <span class="n">xs</span> <span class="o">@</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="p">;;</span>
<span class="n">rev</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span> <span class="c">(* recall [1;2;3] is equivalent to 1 :: ( 2 :: ( 3 :: [])) *)</span>
</code></pre></div></div>

<p>Let us argue why this works.</p>

<p>We assume we have a notion of “program fragments behaving the same”, <code>~=</code>.</p>
<ul>
  <li>e.g. <code>1 + 2 ~= 3</code>, <code>1 :: [] ~= [1]</code>, etc.</li>
  <li>(<code>~=</code> is called “operational equivalence”, we will define it later in the course)</li>
</ul>

<p>Before doing the general case, here are some equivalences we can see from the above program run <br />
(by running it in our heads):</p>
<pre><code>rev [1;2;3] 
~= rev (1 :: [2;3]) (by the meaning of the [...] list syntax)
~= (rev [2;3]) @ [1]  (the second pattern is matched: x is 1, xs is [2;3] and run the match body)
~= (rev [3] @ [2]) @ [1]  (same thing for the rev [2;3] expression - plug in its elaboration)
~= ((rev [] @ [3]) @ [2]) @ [1]
~= (([] @ [3]) @ [2]) @ [1]
~= [3;2;1] (by the meaning of append)
</code></pre>

<p>But, what we really want to show is it reverses ANY list.. use induction!</p>

<p>Let P(n) mean “for any list l of length n, <code>rev l ~=</code> its reverse”.</p>

<p>Recall an induction principle:<br />
To show P(n) for all in, it suffices to show <br />
  1) P(0), and <br />
  2) P(k-1) holds implies P(k) holds for any natural number k&gt;0.</p>

<ul>
  <li>Induction is often not explained well by mathematicians which causes confusion</li>
  <li>It is easier for us CS-ers, the induction step 2) is really just a <strong>proof macro</strong> with k a parameter
    <ul>
      <li>imagine copy/pasting your proof of 2) for any particular number k =&gt; macro expansion</li>
    </ul>
  </li>
  <li>Induction is justified by repeatedly instantiating the macro for 1,2,3,..</li>
</ul>

<p>So, if we showed 1) and 2) above,</p>
<ul>
  <li>P(0) is true by 1)</li>
  <li>P(1) is true because letting k=1 in 2) we have P(0) implies P(1),<br />
  and we just showed we have P(0), so we also have P(1).</li>
  <li>P(2) is true because letting k=2 in 2) we have P(1) implies P(2),<br />
  and we just showed we have P(1), so we also have P(2).</li>
  <li>P(3) is true because letting k=3 in 2) we have P(2) implies P(3),<br />
  and we just showed we have P(2), so we also have P(3).</li>
  <li>… etc for all k</li>
</ul>

<p>Let us now prove by induction.</p>

<p>Theorem: For any list <code>l</code> of length n, <code>rev l ~=</code> the reverse of <code>l</code> .<br />
Proof.  Proceed by induction to show this property for any n.<br />
  1) for n = 0, <code>l ~= []</code> since that is the only 0-length list.<br />
     <code>rev [] ~= []</code> which is <code>[]</code> reversed, check!<br />
  2) Assume for any k-length list <code>l</code> that <code>rev l ~= l</code> reversed.<br />
     Show for any k+1 length list, i.e. for any list <code>x :: l</code><br />
     that <code>rev (x :: l) ~= (x :: l)</code> reversed:</p>

<p>OK, by computing, <code>rev (x :: l) ~= rev l @ [x]</code>.<br />
Now by the induction hypothesis, <code>rev l</code> is <code>l</code> reversed.<br />
So, since <code>(l</code> reversed<code>) @ [x]</code> reverses the whole list <code>x :: l</code>,<br />
<code>rev (x :: l) ~= (x :: l)</code> reversed.<br />
This completes the induction step.</p>

<p>QED.</p>

<p><a name="iii"></a></p>

<h2 id="ocaml-lecture-iii">OCaml Lecture III</h2>

<h3 id="tuples">Tuples</h3>

<ul>
  <li>Think of tuples as fixed length lists, where the types of each element can differ, unlike lists</li>
  <li>A 2-tuple is a pair, a 3-tuple is a triple.</li>
  <li>Tuples are “and” data structures: this <em>and</em> this *and this.  <code>struct</code> and objects are also “and” structures (variants like <code>Some/None</code> are OCaml’s “or” structures, more later on them)</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="s2">"hi"</span><span class="p">);;</span>             <span class="c">(* type is int * string -- '*' is like "x" of set theory, a product *)</span>
<span class="k">let</span> <span class="n">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="s2">"hi"</span><span class="p">);;</span> <span class="c">(* tuple elements separated by commas, list elements by semicolon *)</span>
<span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span><span class="o">,</span><span class="k">'</span><span class="n">c'</span><span class="o">,</span><span class="s2">"cc"</span><span class="p">);;</span>
</code></pre></div></div>
<p>Tuple pattern matching</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="s2">"hi"</span><span class="o">,</span> <span class="mi">1</span><span class="o">.</span><span class="mi">2</span><span class="p">);;</span>

<span class="k">match</span> <span class="n">tuple</span> <span class="k">with</span>
  <span class="p">(</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">th</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="p">;;</span>

<span class="c">(* shorthand for the above - only one pattern, can use let syntax *)</span>
<span class="k">let</span> <span class="p">(</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">th</span><span class="p">)</span> <span class="o">=</span> <span class="n">tuple</span> <span class="k">in</span> <span class="n">s</span><span class="p">;;</span>

<span class="c">(* Parens around tuple not always needed *)</span>
<span class="k">let</span> <span class="n">i</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">f</span> <span class="o">=</span> <span class="mi">4</span><span class="o">,</span> <span class="bp">true</span><span class="o">,</span> <span class="mi">4</span><span class="o">.</span><span class="mi">4</span><span class="p">;;</span>

<span class="c">(* Pattern matching on a pair allows parallel pattern matching *)</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">eq_lists</span> <span class="n">l1</span> <span class="n">l2</span> <span class="o">=</span> 
  <span class="k">match</span> <span class="n">l1</span><span class="o">,</span><span class="n">l2</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span><span class="o">,</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">true</span>
  <span class="o">|</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">,</span> <span class="n">x'</span><span class="o">::</span><span class="n">xs'</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;&gt;</span> <span class="n">x'</span> <span class="k">then</span> <span class="bp">false</span> <span class="k">else</span> <span class="n">eq_lists</span> <span class="n">xs</span> <span class="n">xs'</span>
  <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="bp">false</span> <span class="c">(* lengths must differ if this case is hit *)</span>
</code></pre></div></div>

<h4 id="consequences-of-immutable-variable-declarations-on-the-top-loop">Consequences of immutable variable declarations on the top loop</h4>

<ul>
  <li>All variable declarations in OCaml are <strong>immutable</strong> – value will never change</li>
  <li>Helps in reasoning about programs, we know the variable’s value is fixed</li>
  <li>But can be confusing when shadowing (re-definition) happens</li>
</ul>

<p>Consider the following sequence of inputs into the top loop:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">f</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;;</span> <span class="c">(* this is a shadowing re-definition, not an assignment! *)</span>
<span class="n">f</span> <span class="n">y</span><span class="p">;;</span> <span class="c">(* 3 + 3 or 5 + 3 - ??   Answer: the latter. *)</span>
</code></pre></div></div>

<ul>
  <li>To understand the above, realize that the top loop is conceptually an open-ended series of let-ins which never close:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">in</span>
 <span class="p">(</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span> <span class="k">in</span>
   <span class="p">(</span> <span class="k">let</span> <span class="n">f</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span> <span class="k">in</span>
     <span class="p">(</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="k">in</span>  <span class="c">(* this is a shadowing re-definition of x, NOT an assignment *)</span>
       <span class="p">(</span><span class="n">f</span> <span class="n">y</span><span class="p">)</span>
     <span class="p">)</span>
   <span class="p">)</span>
 <span class="p">)</span>
<span class="p">)</span>
<span class="p">;;</span>
</code></pre></div></div>

<p>The above might make more sense if you consider similar-in-spirit C pseudo-code:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="p">{</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
     <span class="p">{</span> <span class="kt">int</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">f</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-&gt;</span> <span class="k">return</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">);</span> <span class="p">(</span><span class="o">*</span> <span class="n">imagining</span> <span class="n">higher</span><span class="o">-</span><span class="n">order</span> <span class="n">functions</span> <span class="n">in</span> <span class="n">C</span> <span class="o">*</span><span class="p">)</span>
       <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="p">(</span><span class="o">*</span> <span class="n">shadows</span> <span class="n">previous</span> <span class="n">x</span> <span class="n">in</span> <span class="n">C</span> <span class="o">*</span><span class="p">)</span>
         <span class="k">return</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">));</span> 
  <span class="p">}}}})</span>
</code></pre></div></div>

<p>Function definitions are similar, you can’t mutate an existing definition.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">g</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">);;</span>
<span class="k">let</span> <span class="n">f_alias</span> <span class="o">=</span> <span class="n">f</span><span class="p">;;</span> <span class="c">(* make a new name for f above *)</span>
<span class="c">(* lets "change" f, say we made an error in its definition above *)</span>
<span class="k">let</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span>
<span class="n">f_alias</span><span class="p">;;</span> <span class="c">(* it is the original f, similar to how let works on integer variables above *)</span>
<span class="n">g</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">);;</span> <span class="c">(* g still refers to the initial f - !! *)</span>
<span class="k">let</span> <span class="n">g</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">);;</span> <span class="c">(* FIX to get new f: resubmit (identical) g code *)</span>
<span class="n">g</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">);;</span> <span class="c">(* works now *)</span>
</code></pre></div></div>

<ul>
  <li>Moral: re-load all your functions if you change any one function</li>
  <li>For Assignment 1, you will be able to say <code>dune test</code> in the terminal to compile and run tests on your code, and <code>dune utop</code> will load it all into <code>utop</code> so you can then play with your functions.</li>
  <li>Also you can type into <code>utop</code> the command <code>#use "src/assignment.ml"</code> and it is as if you copy/pasted the whole file into <code>utop</code>.</li>
</ul>

<h4 id="mutually-recursive-functions">Mutually recursive functions</h4>

<ul>
  <li>Mutually recursive functions are not common but they require special syntax</li>
  <li>Warm up: write a copy function on lists
    <ul>
      <li>List copy is in fact <strong>useless</strong> in OCaml because lists are immutable - compiler can <em>share</em> two versions without any issues</li>
      <li>This property is <em>referential transparency</em></li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">copy</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>  <span class="n">hd</span><span class="o">::</span><span class="p">(</span><span class="n">copy</span> <span class="n">tl</span><span class="p">);;</span>

<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">copy</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span><span class="p">;</span><span class="mi">7</span><span class="p">;</span><span class="mi">8</span><span class="p">;</span><span class="mi">9</span><span class="p">;</span><span class="mi">10</span><span class="p">]</span>
</code></pre></div></div>
<ul>
  <li>Argue by induction that this will copy: <code>(copy tl)</code> is a call on a shorter list so can assume is correct</li>
</ul>

<p>Copy every other element, defined by mutual recursion via <code>and</code> syntax</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">copy_odd</span> <span class="n">l</span> <span class="o">=</span> <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>  <span class="n">hd</span><span class="o">::</span><span class="p">(</span><span class="n">copy_even</span> <span class="n">tl</span><span class="p">)</span>
<span class="ow">and</span>  <span class="c">(* new keyword for declaring mutually recursive functions *)</span>
  <span class="n">copy_even</span> <span class="n">l</span> <span class="o">=</span> <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span>  <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">copy_odd</span> <span class="n">xs</span><span class="p">;;</span>

<span class="n">copy_odd</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span><span class="p">;</span><span class="mi">7</span><span class="p">;</span><span class="mi">8</span><span class="p">;</span><span class="mi">9</span><span class="p">;</span><span class="mi">10</span><span class="p">];;</span>
<span class="n">copy_even</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span><span class="p">;</span><span class="mi">7</span><span class="p">;</span><span class="mi">8</span><span class="p">;</span><span class="mi">9</span><span class="p">;</span><span class="mi">10</span><span class="p">];;</span>
</code></pre></div></div>

<h3 id="using-let--in-to-define-local-functions">Using <code>let .. in</code> to define local functions</h3>

<ul>
  <li>If functions are <em>only</em> used locally within one function, it can be defined inside that function - more modular</li>
  <li>Suppose we only wanted to use <code>copy_odd</code>: here is a version that hides <code>copy_even</code>:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">copy_odd</span> <span class="n">ll</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">copy_odd_local</span> <span class="n">l</span> <span class="o">=</span> <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span>  <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>  <span class="n">hd</span><span class="o">::</span><span class="p">(</span><span class="n">copy_even_local</span> <span class="n">tl</span><span class="p">)</span>
  <span class="ow">and</span>
    <span class="n">copy_even_local</span> <span class="n">l</span> <span class="o">=</span> <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span>        <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">copy_odd_local</span> <span class="n">xs</span>
  <span class="k">in</span>
  <span class="n">copy_odd_local</span> <span class="n">ll</span><span class="p">;;</span>

<span class="k">assert</span><span class="p">(</span><span class="n">copy_odd</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span><span class="p">;</span><span class="mi">7</span><span class="p">;</span><span class="mi">8</span><span class="p">;</span><span class="mi">9</span><span class="p">;</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">7</span><span class="p">;</span><span class="mi">9</span><span class="p">]);;</span>
</code></pre></div></div>

<ul>
  <li><code>copy_even_local</code> is not available in the top loop, it is local to <code>copy_odd</code> function only, just like local variables but its a function.</li>
  <li>Note how the last line “exports” the internal <code>copy_odd_local</code> by forwarding the <code>ll</code> parameter to it</li>
</ul>

<h3 id="higher-order-functions">Higher Order Functions</h3>

<p>Higher order functions are functions that either</p>
<ul>
  <li>take other functions as arguments</li>
  <li>or return functions as results</li>
</ul>

<p>Why?</p>
<ul>
  <li>“pluggable” programming by passing in and out chunks of code</li>
  <li>greatly increases reusability of code since any varying code can be pulled out as a function to pass in</li>
  <li>Lets show the power by extracting out some pluggable code</li>
</ul>

<p>Illustration of there usefulness by example: append <code>"gobble"</code> to each word in a list of strings</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">append_gobble</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">hd</span> <span class="o">^</span><span class="s2">"-gobble"</span><span class="p">)</span> <span class="o">::</span> <span class="n">append_gobble</span> <span class="n">tl</span><span class="p">;;</span>

<span class="n">append_gobble</span> <span class="p">[</span><span class="s2">"have"</span><span class="p">;</span><span class="s2">"a"</span><span class="p">;</span><span class="s2">"good"</span><span class="p">;</span><span class="s2">"day"</span><span class="p">];;</span>
<span class="p">(</span><span class="s2">"have"</span> <span class="o">^</span><span class="s2">"gobble"</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="s2">"a"</span><span class="o">^</span><span class="s2">"gobble"</span><span class="p">)</span> <span class="o">::</span> <span class="n">append_gobble</span> <span class="p">[</span><span class="s2">"good"</span><span class="p">;</span><span class="s2">"day"</span><span class="p">];;</span>
</code></pre></div></div>

<ul>
  <li>At a high level, the common pattern is “apply a function to every list element and make a list of the results”</li>
  <li>So, lets pull out the “append gobble” action as a function parameter so it will be it code we can plug in</li>
  <li>The resulting function is called <code>map</code> (note it is built-in as <code>List.map</code>):
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">map</span> <span class="p">(</span><span class="n">f</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="p">(</span><span class="n">l</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span><span class="p">)</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span> <span class="kt">list</span> <span class="o">=</span>  <span class="c">(* function f is an argument here *)</span>
<span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
<span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
<span class="o">|</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">hd</span><span class="p">)</span> <span class="o">::</span> <span class="n">map</span> <span class="n">f</span> <span class="n">tl</span><span class="p">;;</span>
</code></pre></div>    </div>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">another_append_gobble</span> <span class="o">=</span> <span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">^</span><span class="s2">"-gobble"</span><span class="p">);;</span> <span class="c">(* give only the first argument -- Currying *)</span>
<span class="n">another_append_gobble</span> <span class="p">[</span><span class="s2">"have"</span><span class="p">;</span><span class="s2">"a"</span><span class="p">;</span><span class="s2">"good"</span><span class="p">;</span><span class="s2">"day"</span><span class="p">];;</span>
<span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">^</span><span class="s2">"-gobble"</span><span class="p">)</span> <span class="p">[</span><span class="s2">"have"</span><span class="p">;</span><span class="s2">"a"</span><span class="p">;</span><span class="s2">"good"</span><span class="p">;</span><span class="s2">"day"</span><span class="p">];;</span> <span class="c">(* Or, don't give the intermediate application a name *)</span>
</code></pre></div></div>

<p>Mapping on lists of pairs - in and out lists can be different types.</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="p">[(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="p">);(</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="p">)];;</span>
<span class="k">let</span> <span class="n">flist</span> <span class="o">=</span> <span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">fun</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">4</span><span class="p">]</span> <span class="p">;;</span> <span class="c">(* make a list of functions - why not? *)</span>
</code></pre></div></div>
<ul>
  <li>This aligns with the type of <code>map</code>, <code>('a -&gt; 'b) -&gt; 'a list -&gt; 'b list </code> - <code>'a</code> and <code>'b</code> can differ.</li>
</ul>

<h3 id="solving-some-simple-problems">Solving some simple problems</h3>

<p>Some practice problems and their solutions for your own self-study (skipped in lecture)</p>

<ol>
  <li>Write a function <code>to_upper_case</code> which takes a list (l) of characters and returns a list which has the same characters as l, but capitalized (if not already).</li>
</ol>

<p>Notes: <br />
a. Assume that the capital of characters other than alphabets<br />
            (A - Z or a - z), are the characters themselves e.g.</p>

<pre><code>                character               corresponding capital character

                    a                             A
                    z                             Z
                    A                             A
                    1                             1
                    %                             %
</code></pre>

<p>b. You can only use <code>Char.code</code> and <code>Char.chr</code> library functions. You <strong>cannot</strong> use <code>Char.uppercase</code>.</p>

<p><strong>Answer:</strong></p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">to_upper_char</span> <span class="n">c</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">c_code</span> <span class="o">=</span> <span class="nn">Char</span><span class="p">.</span><span class="n">code</span> <span class="n">c</span> <span class="k">in</span>
  <span class="k">if</span> <span class="n">c_code</span> <span class="o">&gt;=</span> <span class="mi">97</span> <span class="o">&amp;&amp;</span> <span class="n">c_code</span> <span class="o">&lt;=</span> <span class="mi">122</span> <span class="k">then</span> <span class="nn">Char</span><span class="p">.</span><span class="n">chr</span> <span class="p">(</span><span class="n">c_code</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span>
  <span class="k">else</span> <span class="n">c</span><span class="p">;;</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">to_upper_case</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
   <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
   <span class="o">|</span> <span class="n">c</span> <span class="o">::</span> <span class="n">cs</span> <span class="o">-&gt;</span> <span class="n">to_upper_char</span> <span class="n">c</span> <span class="o">::</span> <span class="n">to_upper_case</span> <span class="n">cs</span>
<span class="p">;;</span>
</code></pre></div></div>

<p>Test</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">assert</span><span class="p">(</span><span class="n">to_upper_case</span> <span class="p">[</span><span class="k">'</span><span class="n">a'</span><span class="p">;</span> <span class="k">'</span><span class="n">q'</span><span class="p">;</span> <span class="k">'</span><span class="nc">B'</span><span class="p">;</span> <span class="k">'</span><span class="nc">Z'</span><span class="p">;</span> <span class="k">'</span><span class="p">;</span><span class="k">'</span><span class="p">;</span> <span class="k">'</span><span class="o">!</span><span class="k">'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="k">'</span><span class="nc">A'</span><span class="p">;</span> <span class="k">'</span><span class="nc">Q'</span><span class="p">;</span> <span class="k">'</span><span class="nc">B'</span><span class="p">;</span> <span class="k">'</span><span class="nc">Z'</span><span class="p">;</span> <span class="k">'</span><span class="p">;</span><span class="k">'</span><span class="p">;</span> <span class="k">'</span><span class="o">!</span><span class="k">'</span><span class="p">]);;</span>
</code></pre></div></div>

<p>Could have used map instead (note map is built in as <code>List.map</code>):</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">to_upper_case</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">to_upper_char</span> <span class="n">l</span> <span class="p">;;</span>
</code></pre></div></div>

<p>Could have also defined it even more simply - partly apply the Curried map:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">to_upper_case</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">to_upper_char</span> <span class="p">;;</span>
</code></pre></div></div>

<ol>
  <li>Write a function <code>partition</code> which takes a predicate (<code>p</code>) and a list (<code>l</code>) as arguments  and returns a tuple <code>(l1, l2)</code> such that <code>l1</code> is the list of all the elements of <code>l</code> that satisfy the predicate p and l2 is the list of all the elements of <code>l</code> that do NOT satisfy <code>p</code>. The order of the elements in the input list (<code>l</code>) should be preserved.</li>
</ol>

<p>Note: A predicate is any function which returns a boolean. e.g. <code>let is_positive n = (n &gt; 0);;</code></p>

<p><strong>Answer:</strong></p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">partition</span> <span class="n">p</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span><span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">([]</span><span class="o">,</span><span class="bp">[]</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">posl</span><span class="o">,</span><span class="n">negl</span><span class="p">)</span> <span class="o">=</span> <span class="n">partition</span> <span class="n">p</span> <span class="n">tl</span> <span class="k">in</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="n">hd</span><span class="p">)</span> <span class="k">then</span> <span class="p">(</span><span class="n">hd</span> <span class="o">::</span> <span class="n">posl</span><span class="o">,</span><span class="n">negl</span><span class="p">)</span>
    <span class="k">else</span> <span class="p">(</span><span class="n">posl</span><span class="o">,</span><span class="n">hd</span><span class="o">::</span><span class="n">negl</span><span class="p">);;</span>
</code></pre></div></div>
<p>Test</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">is_positive</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">in</span>
<span class="k">assert</span><span class="p">(</span><span class="n">partition</span> <span class="n">is_positive</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">([</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span><span class="o">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="o">-</span><span class="mi">3</span><span class="p">]))</span>
</code></pre></div></div>

<ol>
  <li>Write a function <code>diff</code> which takes in two lists l1 and l2 and returns a list containing all elements in l1 not in l2.</li>
</ol>

<p>Note: You will need to write another function <code>contains x l</code> which checks  whether an element <code>x</code> is contained in a list <code>l</code> or not.</p>

<p><strong>Answer:</strong></p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">contains</span> <span class="n">x</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">false</span>
  <span class="o">|</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">||</span> <span class="n">contains</span> <span class="n">x</span> <span class="n">ys</span>
<span class="p">;;</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">diff</span> <span class="n">l1</span> <span class="n">l2</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l1</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="n">contains</span> <span class="n">x</span> <span class="n">l2</span> <span class="k">then</span> <span class="n">diff</span> <span class="n">xs</span> <span class="n">l2</span>
      <span class="k">else</span> <span class="n">x</span> <span class="o">::</span> <span class="n">diff</span> <span class="n">xs</span> <span class="n">l2</span>
<span class="p">;;</span>
</code></pre></div></div>

<p>Tests</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">assert</span><span class="p">(</span><span class="n">contains</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">]);;</span>
<span class="k">assert</span><span class="p">(</span><span class="n">not</span><span class="p">(</span><span class="n">contains</span> <span class="mi">5</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">]));;</span>
<span class="k">assert</span><span class="p">(</span><span class="n">diff</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">]);;</span>
<span class="k">assert</span><span class="p">(</span><span class="n">diff</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">[]</span><span class="p">);;</span>
</code></pre></div></div>

<p><a name="iv"></a></p>

<h2 id="ocaml-lecture-iv">OCaml Lecture IV</h2>

<ul>
  <li>There is a better way to program over lists than to use <code>let rec</code>, it is called <em>combinator programming</em> - use the library functions</li>
  <li>We already saw this with <code>map</code> - we didn’t need to write <code>append_gobble</code> directly, instead we could use <code>map</code>.
    <h3 id="folds">Folds</h3>
  </li>
  <li>fold_left/right use a binary function to combine list elements</li>
  <li>As with <code>map</code> let us first write a concrete combiner and then pull out the particular combination code as a parameter</li>
</ul>

<h4 id="folding-right">Folding right</h4>

<p>First here is how we would hand-code it with <code>let rec</code>:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">summate_right</span> <span class="n">l</span> <span class="o">=</span> <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span>   <span class="o">-&gt;</span> <span class="mi">0</span> <span class="c">(* this is the initial number to start with; a special case *)</span>
    <span class="o">|</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span>  <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">hd</span> <span class="p">(</span><span class="n">summate_right</span> <span class="n">tl</span><span class="p">)</span> <span class="c">(* assume by induction this will summate tl, add hd *)</span>
    <span class="p">;;</span>
<span class="n">summate_right</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span>
</code></pre></div></div>

<p>Now lets generalize the initial value:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">summate_right</span> <span class="n">l</span> <span class="n">init</span> <span class="o">=</span> <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span>   <span class="o">-&gt;</span> <span class="n">init</span> <span class="c">(* init is the initial number to start with *)</span>
    <span class="o">|</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span>  <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">hd</span> <span class="p">(</span><span class="n">summate_right</span> <span class="n">tl</span> <span class="n">init</span><span class="p">)</span>
    <span class="p">;;</span>
<span class="n">summate_right</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">]</span> <span class="mi">0</span><span class="p">;;</span>
</code></pre></div></div>

<p>Finally, pull out the <code>+</code> as a function <em>parameter</em>:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">fold_right</span> <span class="n">f</span> <span class="n">l</span> <span class="n">init</span> <span class="o">=</span> <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">init</span>
  <span class="o">|</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">hd</span> <span class="p">(</span><span class="n">fold_right</span> <span class="n">f</span> <span class="n">tl</span> <span class="n">init</span><span class="p">)</span> <span class="c">(* same code as above just extracting (+) as a parameter *)</span>
<span class="p">;;</span>
<span class="k">let</span> <span class="n">summate_right'</span> <span class="o">=</span> <span class="n">fold_right</span> <span class="p">(</span><span class="o">+</span><span class="p">);;</span> <span class="c">(* re-constitute the version above by feeding in (+) *)</span>
<span class="n">fold_right</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">]</span> <span class="mi">0</span><span class="p">;;</span> <span class="c">(* = (1+(2+(3+0))) - observe the 0 is on the right *)</span>
</code></pre></div></div>

<ul>
  <li>Many functions on lists have this common skeleton and can be written succinctly with <code>fold_right</code></li>
  <li>(It is so important that it is in the standard library as well, as <code>List.fold_right</code>)</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">rev</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="p">(</span><span class="k">fun</span> <span class="n">elt</span> <span class="n">accum</span> <span class="o">-&gt;</span> <span class="n">accum</span> <span class="o">@</span> <span class="p">[</span><span class="n">elt</span><span class="p">])</span> <span class="n">l</span> <span class="bp">[]</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">map</span> <span class="n">f</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="p">(</span><span class="k">fun</span> <span class="n">elt</span> <span class="n">accum</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">elt</span><span class="p">)</span><span class="o">::</span><span class="n">accum</span><span class="p">)</span> <span class="n">l</span> <span class="bp">[]</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">filter</span> <span class="n">f</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="p">(</span><span class="k">fun</span> <span class="n">elt</span> <span class="n">accum</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">f</span> <span class="n">elt</span> <span class="k">then</span> <span class="n">elt</span><span class="o">::</span><span class="n">accum</span> <span class="k">else</span> <span class="n">accum</span><span class="p">)</span> <span class="n">l</span> <span class="bp">[]</span><span class="p">;;</span> 
</code></pre></div></div>

<ul>
  <li>We leave as an exercise understanding how the last two work but let us dig into <code>rev</code>.</li>
  <li>Note that unlike <code>summate</code> above the types of the two arguments to <code>f</code> are different here.
    <ul>
      <li>parameter <code>elt</code> is the head of the list, and <code>accum</code> is the <em>accumulated</em> result thus far.</li>
    </ul>
  </li>
  <li>Here is <code>rev</code> written without fold to show how like with <code>summate_right</code> above it is a fold:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">rev</span><span class="err">’</span> <span class="n">l</span> <span class="n">init</span> <span class="o">=</span> <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span>   <span class="o">-&gt;</span> <span class="n">init</span> 
    <span class="o">|</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span>  <span class="p">(</span><span class="o">@</span><span class="p">)</span> <span class="p">(</span><span class="n">rev</span><span class="err">’</span> <span class="n">tl</span> <span class="n">init</span><span class="p">)</span> <span class="p">[</span><span class="n">hd</span><span class="p">]</span> <span class="c">(* recall our previous rev was identical but @ infix *)</span>
        <span class="p">;;</span>
<span class="n">rev</span><span class="err">’</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">]</span> <span class="bp">[]</span><span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>Note that the append in <code>rev'</code> has the <code>accum</code> as the first parameter and the <code>elt</code> as the second parameter whereas the fold expects the parameters opposite</li>
  <li>So, the <code>f</code> we feed in to the <code>rev</code> via <code>fold_right</code> swaps them (also it makes the <code>elt</code> into a singleton list)</li>
  <li>i.e., we pass <code>f</code> = <code>fun elt accum -&gt; accum @ [elt]</code></li>
  <li>Why does this work?  By induction, can assume <code>accum</code> (the result so far) is the reverse of tail
    <ul>
      <li>then, adding the head, elt, at the end will reverse, done - !</li>
    </ul>
  </li>
</ul>

<p>Here is another view, a trace:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rev <span class="o">[</span>1<span class="p">;</span>2] 
~<span class="o">=</span> fold_right f <span class="o">[</span>1<span class="p">;</span>2] <span class="o">[]</span> 
~<span class="o">=</span> f 1 <span class="o">(</span>fold_right f <span class="o">[</span>2] <span class="o">[]])</span> 
~<span class="o">=</span> <span class="o">(</span>fold_right f <span class="o">[</span>2] <span class="o">[]])</span> @ <span class="o">[</span>1]
~<span class="o">=</span> <span class="o">(</span>f 2 <span class="o">(</span>fold_right f <span class="o">[]</span> <span class="o">[])</span> @ <span class="o">[</span>1]
~<span class="o">=</span> <span class="o">(</span>fold_right f <span class="o">[]</span> <span class="o">[])</span> @ <span class="o">[</span>2] @ <span class="o">[</span>1]
~<span class="o">=</span> <span class="o">[]</span> @ <span class="o">[</span>2] @ <span class="o">[</span>1]
~<span class="o">=</span> <span class="o">[</span>2<span class="p">;</span>1]
</code></pre></div></div>

<h4 id="folding-left">Folding left</h4>

<ul>
  <li><code>fold_left</code> accumulates “on the way down” (we pass down the f computed value), whereas <code>fold_right</code> accumulates “on the way up” (the f computes <em>after</em> the recursive call)</li>
  <li>This is somewhat related to pre-order vs post-order tree traversal you already know about:
    <ul>
      <li>“left” is “pre”, compute on the way down</li>
      <li>“right” is “post”, compute on the way back up</li>
    </ul>
  </li>
  <li>In general it is a fundamental aspect of recursive functions: can compute pre- post- or both.</li>
  <li>So, in the left approach we will pass <em>down</em> the currently accumulated <em>result</em>, <code>accum</code>.</li>
  <li>When we get to the bottom of the recursion (empty list) we have the fully final value in accum and just need to return … return … return it all the way to the top without touching it.</li>
  <li>List and value arguments (and <code>accum</code> and <code>elt</code> on <code>f</code>) are swapped compared to <code>fold_right</code>, be careful !</li>
  <li>Let us again do summation, this time “on the way down”, and extract the general folder.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">summate_left</span> <span class="n">accum</span> <span class="n">l</span> <span class="o">=</span> <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span>   <span class="o">-&gt;</span> <span class="n">accum</span>
    <span class="o">|</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">summate_left</span> <span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="n">accum</span> <span class="n">hd</span><span class="p">)</span> <span class="n">tl</span> <span class="c">(* pass down accum + hd as new "accum" -- accumulating *)</span>
    <span class="p">;;</span>
<span class="n">summate_left</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span> <span class="c">(* ~= summate_left (0+1) [2;3] ~= summate_left (1+2) [3] = summate_left (3+3) [] ~= 6 *)</span>
</code></pre></div></div>
<ul>
  <li>Note that the “initial <code>accum</code>”  is <code>0</code>, grows on way <em>down</em> (only)</li>
  <li>Again let us extract the <code>(+)</code> as a new parameter <code>f</code> to allow any operation to be applied in this manner</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">fold_left</span> <span class="n">f</span> <span class="n">accum</span> <span class="n">l</span> <span class="o">=</span> <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span>   <span class="o">-&gt;</span> <span class="n">accum</span>
    <span class="o">|</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">fold_left</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">accum</span> <span class="n">hd</span><span class="p">)</span> <span class="n">tl</span>
    <span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>Type is <code>('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'a</code> which parenthesizes as <code>('a -&gt; 'b -&gt; 'a) -&gt; ('a -&gt; ('b list -&gt; 'a))</code></li>
</ul>

<p>Summing elements of a list can now be more succinctly coded:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fold_left</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span>
</code></pre></div></div>

<ul>
  <li>Tracing this, <code>accum</code> is <code>0</code>, <code>1</code>, <code>3</code>, <code>6</code> on succive recursive calls, <code>6</code> for the base case which bubbles all the way out to the top.</li>
  <li>As with <code>fold_right</code> this skeleton lets us plug in different <code>f</code> to make many natural functions on lists.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">length</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">accum</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="n">accum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">0</span> <span class="n">l</span><span class="p">;;</span> <span class="c">(* adds accum, ignores elt *)</span>
<span class="k">let</span> <span class="n">rev</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">accum</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="n">elt</span><span class="o">::</span><span class="n">accum</span><span class="p">)</span> <span class="bp">[]</span> <span class="n">l</span><span class="p">;;</span> <span class="c">(* e.g. rev [1;2;3] = (3::(2::(1::[]))) - much faster! *)</span>
</code></pre></div></div>
<p>Lets unfold to clarify how this version of <code>rev</code> runs (<code>f</code> is <code>(fun accum elt -&gt; elt::accum)</code>):</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rev <span class="o">[</span>1<span class="p">;</span>2] 
~<span class="o">=</span> fold_left f <span class="o">[]</span> <span class="o">[</span>1<span class="p">;</span>2] 
~<span class="o">=</span> fold_left f <span class="o">(</span>f <span class="o">[]</span> 1<span class="o">)</span> <span class="o">[</span>2]
~<span class="o">=</span> fold_left f <span class="o">(</span>1::[]<span class="o">)</span> <span class="o">[</span>2]
~<span class="o">=</span> fold_left f <span class="o">(</span>f <span class="o">(</span>1::[]<span class="o">)</span> 2<span class="o">)</span> <span class="o">[]</span>
~<span class="o">=</span> fold_left f <span class="o">(</span>2::1::[]<span class="o">)</span> <span class="o">[]</span>
~<span class="o">=</span> 2::1::[]
~<span class="o">=</span> <span class="o">[</span>2<span class="p">;</span>1]
</code></pre></div></div>

<p>Another way to see how left and right folds produce different results:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="k">fun</span> <span class="n">accum</span> <span class="o">-&gt;</span> <span class="s2">"("</span><span class="o">^</span><span class="n">elt</span><span class="o">^</span><span class="s2">" op "</span><span class="o">^</span><span class="n">accum</span><span class="o">^</span><span class="s2">")"</span><span class="p">)</span> <span class="s2">"z"</span> <span class="p">[</span><span class="s2">"a"</span><span class="p">;</span><span class="s2">"b"</span><span class="p">;</span><span class="s2">"c"</span><span class="p">]</span> <span class="p">;;</span>  <span class="c">(* "(((z op a) op b) op c)" *)</span>
<span class="n">fold_right</span> <span class="p">(</span><span class="k">fun</span> <span class="n">accum</span> <span class="o">-&gt;</span> <span class="k">fun</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="s2">"("</span><span class="o">^</span><span class="n">accum</span><span class="o">^</span><span class="s2">" op "</span><span class="o">^</span><span class="n">elt</span><span class="o">^</span><span class="s2">")"</span><span class="p">)</span> <span class="p">[</span><span class="s2">"a"</span><span class="p">;</span><span class="s2">"b"</span><span class="p">;</span><span class="s2">"c"</span><span class="p">]</span> <span class="s2">"z"</span> <span class="p">;;</span> <span class="c">(* "(a op (b op (c op z)))" *)</span>
</code></pre></div></div>

<h3 id="pipeling-and-composition">Pipeling and composition</h3>

<p>Pipelining Example: get the element nth from the end from a list, by first reversing and then getting nth element.</p>

<p>Obvious version:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">nth_end</span> <span class="n">l</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">nth</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">l</span><span class="p">)</span> <span class="n">n</span><span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>But, from the analogy of shell pipes <code>|</code>, we are “piping” the output of <code>rev</code> into <code>nth</code> for some fixed n.</li>
  <li>Here is an equivalent way to code that using OCaml pipe notation, <code>|&gt;</code></li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">nth_end</span> <span class="n">l</span> <span class="n">n</span> <span class="o">=</span> <span class="n">l</span> <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="o">|&gt;</span> <span class="p">(</span><span class="nn">Fun</span><span class="p">.</span><span class="n">flip</span><span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">nth</span><span class="p">)</span> <span class="n">n</span><span class="p">);;</span>
</code></pre></div></div>
<ul>
  <li>All <code>[1;2] |&gt; List.rev</code> in fact does is apply the second argument to the first - very simple!</li>
  <li>The type gives it away: <code>(|&gt;)</code> has type <code>'a -&gt; ('a -&gt; 'b) -&gt; 'b</code></li>
  <li>The <code>Fun.flip</code> is needed to put the list argument second, not first
    <ul>
      <li>it is another interesting higher-order function, with type <code>('a -&gt; 'b -&gt; 'c) -&gt; 'b -&gt; 'a -&gt; 'c</code>.</li>
    </ul>
  </li>
  <li>So, e.g. <code>(Fun.flip(List.nth) 2)</code> is a function taking a list and returning the 2nd element.
    <h4 id="function-composition-functions-both-in-and-out">Function Composition: functions both in and out</h4>
  </li>
</ul>

<p>Composition operation <code>g o f</code> from math: take two functions, return their composition</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">compose</span> <span class="n">g</span> <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">g</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">));;</span>
<span class="n">compose</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="mi">10</span><span class="p">;;</span>
</code></pre></div></div>

<h3 id="currying">Currying</h3>

<ul>
  <li>Names the way multi-argument functions work in OCaml</li>
  <li>Logician Haskell Curry originally came up with the idea in the 1930’s</li>
  <li>First lets recall how multi-argument functions in OCaml are Curried</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">add_c</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;;</span> <span class="c">(* recall type is int -&gt; int -&gt; int which is int -&gt; (int -&gt; int) *)</span>
<span class="n">add_c</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">;;</span> <span class="c">(* recall this is the same as '(add_c 1) 2' *)</span>
<span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">add_c</span> <span class="mi">1</span> <span class="k">in</span> <span class="n">tmp</span> <span class="mi">2</span><span class="p">;;</span> <span class="c">(* the partial application of arguments - tmp is a function *)</span>
<span class="c">(* An equivalent way to define `add_c`, clarifying what the above means *)</span>
<span class="k">let</span> <span class="n">add_c</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">fun</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">);;</span>
<span class="c">(* and, yet another identical way .. lots of equivalent notation in OCaml *)</span>
<span class="k">let</span> <span class="n">add_c</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;;</span>
<span class="c">(* yet one more, the built-in (+) *)</span>
<span class="k">let</span> <span class="n">add_c</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="p">);;</span>
</code></pre></div></div>

<p>Here is the <em>non-Curried</em> version: use a <em>pair of arguments</em> instead</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">add_nc</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">;;</span> <span class="c">(* type is int * int -&gt; int - no way to partially apply *)</span>
</code></pre></div></div>

<ul>
  <li>Notice how the type of <code>add_nc</code> differs from <code>add_c</code>: <code>int * int -&gt; int</code> vs <code>int -&gt; int -&gt; int</code>.</li>
  <li>Fact: these two approaches to defining a 2-argument function are isomorphic:<br />
<code>'a * 'b -&gt; 'c</code> ~= <code>'a -&gt; 'b -&gt; 'c</code></li>
  <li>(This isomorphism also holds in set theory, you may have already seen it)</li>
</ul>

<p>To “prove” this we make functions (on functions) to convert from one form to the other</p>
<ul>
  <li><code>curry</code>   - takes in non-curry’ing 2-arg function and returns a curry’ing version</li>
  <li><code>uncurry</code> - takes in curry’ing 2-arg function and returns an non-curry’ing version</li>
</ul>

<p>Since we can then go back and forth between the two representations, they are <strong>isomorphic</strong>.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">curry</span> <span class="n">fnc</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="k">fun</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">fnc</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">);;</span>
<span class="k">let</span> <span class="n">uncurry</span> <span class="n">fc</span> <span class="o">=</span> <span class="k">fun</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">fc</span> <span class="n">x</span> <span class="n">y</span><span class="p">;;</span>

<span class="k">let</span> <span class="n">new_add_nc</span> <span class="o">=</span> <span class="n">uncurry</span> <span class="n">add_c</span><span class="p">;;</span>
<span class="n">new_add_nc</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="p">);;</span>
<span class="k">let</span> <span class="n">new_add_c</span>  <span class="o">=</span> <span class="n">curry</span>   <span class="n">add_nc</span><span class="p">;;</span>
<span class="n">new_add_c</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">;;</span>
</code></pre></div></div>

<p>Observe the types themselves pretty much specify their behavior</p>
<pre><code>curry : ('a * 'b -&gt; 'c) -&gt; 'a -&gt; 'b -&gt; 'c
uncurry : ('a -&gt; 'b -&gt; 'c) -&gt; 'a * 'b -&gt; 'c
</code></pre>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">noop1</span> <span class="o">=</span> <span class="n">curry</span> <span class="p">(</span><span class="n">uncurry</span> <span class="n">add_c</span><span class="p">);;</span> <span class="c">(* a no-op *)</span>
<span class="k">let</span> <span class="n">noop2</span> <span class="o">=</span> <span class="n">uncurry</span> <span class="p">(</span><span class="n">curry</span> <span class="n">add_nc</span><span class="p">);;</span> <span class="c">(* another no-op; noop1 &amp; noop2 together show isomorphism *)</span>
</code></pre></div></div>
<h3 id="misc-ocaml">Misc OCaml</h3>

<p>See <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Stdlib.html">module Stdlib</a> for various functions available in the OCaml top-level like <code>+</code>, <code>^</code> (string append), <code>print_int</code> (print an integer), etc.</p>

<p>See <a href="http://caml.inria.fr/pub/docs/manual-ocaml/stdlib.html">the Standard Library</a> for modules of functions for <code>List</code>s, <code>String</code>s, <code>Int</code>egers, as well as <code>Set</code>s, <code>Map</code>s, etc, etc.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">print_string</span> <span class="p">(</span><span class="s2">"hi</span><span class="se">\n</span><span class="s2">"</span><span class="p">);;</span>
</code></pre></div></div>

<p>Some <code>Stdlib</code> built-in exception generating functions (more on exceptions later)</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>failwith <span class="s2">"BOOM!"</span><span class="o">)</span> + 3 <span class="p">;;</span>
</code></pre></div></div>

<p>Invalid argument exception <code>invalid_arg</code>:</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">let </span>f x <span class="o">=</span> <span class="k">if </span>x &lt;<span class="o">=</span> 0 <span class="k">then </span>invalid_arg <span class="s2">"Let's be positive, please!"</span> <span class="k">else </span>x + 1<span class="p">;;</span>
f <span class="o">(</span><span class="nt">-5</span><span class="o">)</span><span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>Recall that OCaml infers types but they can be optionally declared</li>
  <li>It is good practice to paste the inferred types in your code to have types as documentation</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">add</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">float</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="o">:</span> <span class="kt">float</span><span class="p">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="nn">Float</span><span class="p">.</span><span class="n">to_int</span> <span class="p">(</span><span class="n">x</span> <span class="o">+.</span> <span class="n">y</span><span class="p">);;</span>
</code></pre></div></div>

<p>Type abbreviations are also possible via keyword <code>type</code></p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">intpair</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">f</span> <span class="p">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">intpair</span><span class="p">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="k">match</span> <span class="n">p</span> <span class="k">with</span>
                      <span class="p">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">l</span> <span class="o">+</span> <span class="n">r</span>
<span class="p">;;</span>
<span class="p">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="p">);;</span> <span class="c">(* ocaml doesn't call this an intpair by default *)</span>
<span class="n">f</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">);;</span> <span class="c">(* still, can pass it to the function expecting an intpair *)</span>
<span class="p">((</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="p">)</span><span class="o">:</span><span class="n">intpair</span><span class="p">);;</span> <span class="c">(* can also explicitly tag data with its type *)</span>
</code></pre></div></div>

<h3 id="variants">Variants</h3>

<p>We saw a simple examples of variants earlier in the <code>option</code> type; now we go into the full possibilities</p>
<ul>
  <li>Related to <code>union</code> types in C or <code>enum</code>s in Java: “this OR that OR theother”</li>
  <li>Like lists/tuples they are <strong>immutable</strong> data structures</li>
  <li>Each case of the union is identified by a name called a <em>constructor</em> which serves for both
    <ul>
      <li>constructing values of the variant type</li>
      <li>destructing them by pattern matching</li>
    </ul>
  </li>
</ul>

<p>Example of how to declare a new variant type for doing mixed arithmetic (integers and floats)</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">mynumber</span> <span class="o">=</span> <span class="nc">Fixed</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Floating</span> <span class="k">of</span> <span class="kt">float</span><span class="p">;;</span>  <span class="c">(* read "|" as "or" *)</span>
</code></pre></div></div>
<ul>
  <li>Constructors must start with Capital Letter to distinguish from variables (<code>Fixed</code> and <code>Floating</code> here)</li>
  <li>The <code>of</code> indicates what type is under the wrapper, optionally no of meaning nothing under wrapper</li>
  <li>Type declarations are required but once they are in place type inference on them works</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Fixed</span><span class="p">(</span><span class="mi">5</span><span class="p">);;</span> <span class="c">(* tag 5 as a Fixed *)</span>
<span class="nc">Fixed</span> <span class="mi">5</span><span class="p">;;</span> <span class="c">(* parens optional as is often the case in OCaml *)</span>
<span class="nc">Floating</span> <span class="mi">4</span><span class="o">.</span><span class="mi">0</span><span class="p">;;</span> <span class="c">(* tag 4.0 as a Floating *)</span>
</code></pre></div></div>

<p>Note constructors look like functions but they are <strong>not</strong> – you always need to give the argument</p>

<p>Destruct variants by pattern matching like we did for <code>Some/None</code> option type values:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">ff_as_int</span> <span class="n">x</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Fixed</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span>    <span class="c">(* variants fit well into pattern matching syntax *)</span>
    <span class="o">|</span> <span class="nc">Floating</span> <span class="n">z</span> <span class="o">-&gt;</span> <span class="n">int_of_float</span> <span class="n">z</span><span class="p">;;</span>

<span class="n">ff_as_int</span> <span class="p">(</span><span class="nc">Fixed</span> <span class="mi">5</span><span class="p">);;</span> <span class="c">(* beware that ff_as_int Fixed(5) won't parse properly!!  Super commmon error!!! 
                         ff_as_int @@ Fixed 5 will though *)</span>
</code></pre></div></div>

<p>A non-trivial function using the above variant</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">add_num</span> <span class="n">n1</span> <span class="n">n2</span> <span class="o">=</span>
   <span class="k">match</span> <span class="n">n1</span><span class="o">,</span> <span class="n">n2</span> <span class="k">with</span>    <span class="c">(* note use of pair here to parallel-match on two variables  *)</span>
     <span class="o">|</span> <span class="nc">Fixed</span> <span class="n">i1</span><span class="o">,</span> <span class="nc">Fixed</span> <span class="n">i2</span> <span class="o">-&gt;</span> <span class="nc">Fixed</span>   <span class="p">(</span><span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span><span class="p">)</span>
     <span class="o">|</span> <span class="nc">Fixed</span> <span class="n">i1</span><span class="o">,</span> <span class="nc">Floating</span> <span class="n">f2</span> <span class="o">-&gt;</span> <span class="nc">Floating</span><span class="p">(</span><span class="kt">float</span> <span class="n">i1</span> <span class="o">+.</span> <span class="n">f2</span><span class="p">)</span> <span class="c">(* need to coerce with `float` function *)</span>
     <span class="o">|</span> <span class="nc">Floating</span> <span class="n">f1</span><span class="o">,</span> <span class="nc">Fixed</span> <span class="n">i2</span> <span class="o">-&gt;</span> <span class="nc">Floating</span><span class="p">(</span><span class="n">f1</span> <span class="o">+.</span> <span class="kt">float</span> <span class="n">i2</span><span class="p">)</span> <span class="c">(* ditto *)</span>
     <span class="o">|</span> <span class="nc">Floating</span> <span class="n">f1</span><span class="o">,</span> <span class="nc">Floating</span> <span class="n">f2</span> <span class="o">-&gt;</span> <span class="nc">Floating</span><span class="p">(</span><span class="n">f1</span> <span class="o">+.</span> <span class="n">f2</span><span class="p">)</span>
<span class="p">;;</span>

<span class="n">add_num</span> <span class="p">(</span><span class="nc">Fixed</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nc">Floating</span> <span class="mi">3</span><span class="o">.</span><span class="mi">14159</span><span class="p">);;</span>
</code></pre></div></div>

<p>Multiple data items in a single variant case?  Use tuple types</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">complex</span> <span class="o">=</span> <span class="nc">CZero</span> <span class="o">|</span> <span class="nc">Nonzero</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span><span class="p">;;</span>

<span class="k">let</span> <span class="n">com</span> <span class="o">=</span> <span class="nc">Nonzero</span><span class="p">(</span><span class="mi">3</span><span class="o">.</span><span class="mi">2</span><span class="o">,</span><span class="mi">11</span><span class="o">.</span><span class="mi">2</span><span class="p">);;</span>
<span class="k">let</span> <span class="n">zer</span> <span class="o">=</span> <span class="nc">CZero</span><span class="p">;;</span>
</code></pre></div></div>

<h4 id="recursive-data-structures">Recursive data structures</h4>
<ul>
  <li>An important use of variant types</li>
  <li>Functional programming is highly suited for computing over tree-structured data</li>
  <li>Recursive types can refer to themselves in their own definition</li>
  <li>Similar in spirit to how C structs can be recursive (but, no pointer needed here)</li>
</ul>

<p>Warm-up: homebrew lists - built-in list type is not in fact needed<br />
First just int lists.. <code>Mt</code> represents <code>[]</code>, <code>Cons(x,xs)</code> represents <code>x::xs</code></p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">myintlist</span> <span class="o">=</span> <span class="nc">Mt</span> <span class="o">|</span> <span class="nc">Cons</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">myintlist</span><span class="p">;;</span> <span class="c">(* Observe: self-referential type *)</span>
<span class="k">let</span> <span class="n">mylisteg</span> <span class="o">=</span> <span class="nc">Cons</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span><span class="nc">Cons</span><span class="p">(</span><span class="mi">5</span><span class="o">,</span><span class="nc">Cons</span><span class="p">(</span><span class="mi">7</span><span class="o">,</span><span class="nc">Mt</span><span class="p">)));;</span> <span class="c">(* equivalent in spirit to [3;5;7] *)</span>
</code></pre></div></div>
<p>Let us extend the above to be polymorphic using a <em>type parameter</em>, <code>'a</code>.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">mylist</span> <span class="o">=</span> <span class="nc">Mt</span> <span class="o">|</span> <span class="nc">Cons</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="n">mylist</span><span class="p">);;</span>
</code></pre></div></div>
<ul>
  <li>Observe how above type takes a (prefix) argument, <code>'a</code> – <code>mylist</code> is a type function</li>
  <li>Perhaps better syntax would have been <code>type mylist(t) = Mt | Cons of t * (mylist(t))</code></li>
  <li>This <code>'a</code> is not the same as the generic type <code>'a</code> - can be confusing</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">mylisteg</span> <span class="o">=</span> <span class="nc">Cons</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span><span class="nc">Cons</span><span class="p">(</span><span class="mi">5</span><span class="o">,</span><span class="nc">Cons</span><span class="p">(</span><span class="mi">7</span><span class="o">,</span><span class="nc">Mt</span><span class="p">)));;</span>
</code></pre></div></div>
<p>Coding is very similar to built-in lists</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">map</span> <span class="n">ml</span> <span class="n">f</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">ml</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Mt</span> <span class="o">-&gt;</span> <span class="nc">Mt</span>
    <span class="o">|</span> <span class="nc">Cons</span><span class="p">(</span><span class="n">hd</span><span class="o">,</span><span class="n">tl</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nc">Cons</span><span class="p">(</span><span class="n">f</span> <span class="n">hd</span><span class="o">,</span><span class="n">map</span> <span class="n">tl</span> <span class="n">f</span><span class="p">);;</span>

<span class="k">let</span> <span class="n">map_eg</span> <span class="o">=</span> <span class="n">map</span> <span class="n">mylisteg</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);;</span>
</code></pre></div></div>

<p><a name="v"></a></p>

<h2 id="ocaml-lecture-v">OCaml Lecture V</h2>

<h4 id="trees">Trees</h4>

<ul>
  <li>Binary trees are like lists but with two self-referential sub-structures not one</li>
  <li>Here is one tree definition; note the data is (only) in the nodes here</li>
  <li>… n-ary trees are a direct generalization of this pattern</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">btree</span> <span class="o">=</span> <span class="nc">Leaf</span> <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">btree</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">btree</span><span class="p">;;</span>
</code></pre></div></div>

<p>Example trees</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">whack</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="s2">"whack!"</span><span class="o">,</span><span class="nc">Leaf</span><span class="o">,</span> <span class="nc">Leaf</span><span class="p">);;</span>
<span class="k">let</span> <span class="n">bt</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="s2">"fiddly "</span><span class="o">,</span>
            <span class="nc">Node</span><span class="p">(</span><span class="s2">"backer "</span><span class="o">,</span>
               <span class="nc">Leaf</span><span class="o">,</span>
               <span class="nc">Node</span><span class="p">(</span><span class="s2">"crack "</span><span class="o">,</span>
                  <span class="nc">Leaf</span><span class="o">,</span>
                  <span class="nc">Leaf</span><span class="p">))</span><span class="o">,</span>
            <span class="n">whack</span><span class="p">);;</span>

<span class="c">(* Type error; like lists, tree data must have uniform type: *)</span>
<span class="c">(* Node("fiddly",Node(0,Leaf,Leaf),Leaf);; *)</span>
</code></pre></div></div>

<p>Functions on binary trees are similar to functions on lists: use recursion</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">add_gobble</span> <span class="n">binstringtree</span> <span class="o">=</span>
   <span class="k">match</span> <span class="n">binstringtree</span> <span class="k">with</span>
   <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="nc">Leaf</span>
   <span class="o">|</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">-&gt;</span>
       <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="s2">"gobble"</span><span class="o">,</span><span class="n">add_gobble</span> <span class="n">left</span><span class="o">,</span><span class="n">add_gobble</span> <span class="n">right</span><span class="p">)</span>
<span class="p">;;</span>
</code></pre></div></div>
<p>(Remember, as with lists this is <em>not</em> mutating the tree, its building a “new” one)</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">lookup</span> <span class="n">x</span> <span class="n">bintree</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">bintree</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="bp">false</span>
  <span class="o">|</span> <span class="nc">Node</span> <span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="k">then</span> <span class="bp">true</span> <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">then</span> <span class="n">lookup</span> <span class="n">x</span> <span class="n">left</span> <span class="k">else</span> <span class="n">lookup</span> <span class="n">x</span> <span class="n">right</span>
<span class="p">;;</span>

<span class="n">lookup</span> <span class="s2">"whack!"</span> <span class="n">bt</span><span class="p">;;</span>
<span class="n">lookup</span> <span class="s2">"flack"</span> <span class="n">bt</span><span class="p">;;</span>
</code></pre></div></div>

<p>Let us now define how to insert an element in sorted order.</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">bintree</span> <span class="o">=</span>
   <span class="k">match</span> <span class="n">bintree</span> <span class="k">with</span>
   <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="nc">Node</span><span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Leaf</span><span class="o">,</span> <span class="nc">Leaf</span><span class="p">)</span>
   <span class="o">|</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">-&gt;</span>
       <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="k">then</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span>
       <span class="k">else</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">right</span><span class="p">)</span>
<span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>This is also <strong>not mutating</strong> – it returns a whole new tree - !</li>
  <li>If you then want to insert another element you need to pass the result from the previous call.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">goobt</span> <span class="o">=</span> <span class="n">insert</span> <span class="s2">"goober "</span> <span class="n">bt</span><span class="p">;;</span>
<span class="n">bt</span><span class="p">;;</span> <span class="c">(* observe bt did not change after the insert *)</span>
<span class="k">let</span> <span class="n">gooobt</span> <span class="o">=</span> <span class="n">insert</span> <span class="s2">"slacker "</span> <span class="n">goobt</span><span class="p">;;</span> <span class="c">(* pass in goobt to accumulate both additions *)</span>
<span class="k">let</span> <span class="n">manyt</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="nn">Fun</span><span class="p">.</span><span class="n">flip</span> <span class="n">insert</span><span class="p">)</span> <span class="nc">Leaf</span> <span class="p">[</span><span class="s2">"one"</span><span class="p">;</span><span class="s2">"two"</span><span class="p">;</span><span class="s2">"three"</span><span class="p">;</span><span class="s2">"four"</span><span class="p">]</span> <span class="c">(* folding helps *)</span>
</code></pre></div></div>

<ul>
  <li>You have already been programming with immutable data structures – lists</li>
  <li>For trees you are used to mutating to insert, delete, etc so takes some getting used to</li>
  <li>It looks really inefficient since an insertion is making a “totally new tree”
    <ul>
      <li>but, the compiler can in fact share all subtrees along the spine to the new node - “only” log n cost</li>
      <li>referential transparency at work</li>
    </ul>
  </li>
</ul>

<h3 id="end-core-ocaml-used-in-the-course">End Core OCaml used in the course</h3>

<ul>
  <li>The bulk of the assignments only use what we covered above</li>
  <li>We now will quickly cover a few more features which we will not use nearly as much
    <ul>
      <li>(Only state below will be needed in assignment 2)</li>
      <li>Note that the toy languages we study will copy OCaml to some degree so we at least want a basic understanding of OCaml’s records, state, exceptions</li>
      <li><strong>FbR</strong> will be our <strong>Fb</strong> records extension, <strong>FbS</strong> for state, and <strong>FbX</strong> for eXceptions.</li>
    </ul>
  </li>
</ul>

<h3 id="records">Records</h3>
<ul>
  <li>Like tuples but with labels on fields.</li>
  <li>Similar to the structs of C/C++.</li>
  <li>The types <em>must</em> be declared with <code>type</code>, just like OCaml variants.</li>
  <li>Also like variants and tuples they can be used in pattern matches.</li>
  <li>Also also record fields are <strong>immutable</strong> by default, so not like Python/Javascript dictionaries</li>
</ul>

<p>Example: a declaring record type to represent rational numbers</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">ratio</span> <span class="o">=</span> <span class="p">{</span><span class="n">num</span><span class="o">:</span> <span class="kt">int</span><span class="p">;</span> <span class="n">denom</span><span class="o">:</span> <span class="kt">int</span><span class="p">};;</span>
<span class="k">let</span> <span class="n">q</span> <span class="o">=</span> <span class="p">{</span><span class="n">num</span> <span class="o">=</span> <span class="mi">53</span><span class="p">;</span> <span class="n">denom</span> <span class="o">=</span> <span class="mi">6</span><span class="p">};;</span>
</code></pre></div></div>

<p>Destructing records via pattern matching:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">rattoint</span> <span class="n">r</span> <span class="o">=</span>
 <span class="k">match</span> <span class="n">r</span> <span class="k">with</span>
   <span class="p">{</span><span class="n">num</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">d</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">/</span> <span class="n">d</span><span class="p">;;</span>
</code></pre></div></div>

<p>Only one pattern matched so can again inline pattern in function’s/let’s</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">rat_to_int</span> <span class="p">{</span><span class="n">num</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">d</span><span class="p">}</span> <span class="o">=</span>  <span class="n">n</span> <span class="o">/</span> <span class="n">d</span><span class="p">;;</span>
</code></pre></div></div>

<p>Equivalently could use standard method of dot projections, but happy path in OCaml is patterns</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">unhappy_rat_to_int</span> <span class="n">r</span>  <span class="o">=</span>
   <span class="n">r</span><span class="o">.</span><span class="n">num</span> <span class="o">/</span> <span class="n">r</span><span class="o">.</span><span class="n">denom</span><span class="p">;;</span>
</code></pre></div></div>

<p>One more example function with records</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">unhappy_add_ratio</span> <span class="n">r1</span> <span class="n">r2</span> <span class="o">=</span> 
  <span class="p">{</span><span class="n">num</span> <span class="o">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">num</span> <span class="o">*</span> <span class="n">r2</span><span class="o">.</span><span class="n">denom</span> <span class="o">+</span> <span class="n">r2</span><span class="o">.</span><span class="n">num</span> <span class="o">*</span> <span class="n">r1</span><span class="o">.</span><span class="n">denom</span><span class="p">;</span> 
   <span class="n">denom</span> <span class="o">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">denom</span> <span class="o">*</span> <span class="n">r2</span><span class="o">.</span><span class="n">denom</span><span class="p">};;</span>

<span class="n">unhappy_add_ratio</span> <span class="p">{</span><span class="n">num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">denom</span> <span class="o">=</span> <span class="mi">3</span><span class="p">}</span> <span class="p">{</span><span class="n">num</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">denom</span> <span class="o">=</span> <span class="mi">5</span><span class="p">};;</span>

<span class="k">let</span> <span class="n">happy_add_ratio</span> <span class="p">{</span><span class="n">num</span> <span class="o">=</span> <span class="n">n1</span><span class="p">;</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">d1</span><span class="p">}</span> <span class="p">{</span><span class="n">num</span> <span class="o">=</span> <span class="n">n2</span><span class="p">;</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">d2</span><span class="p">}</span> <span class="o">=</span> 
  <span class="p">{</span><span class="n">num</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">*</span> <span class="n">d2</span> <span class="o">+</span> <span class="n">n2</span> <span class="o">*</span> <span class="n">d1</span><span class="p">;</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">d1</span> <span class="o">*</span> <span class="n">d2</span><span class="p">};;</span>
</code></pre></div></div>

<h4 id="end-of-pure-functional-programming-in-ocaml">End of Pure Functional programming in OCaml</h4>
<ul>
  <li>On to side effects</li>
  <li>But before heading there, remember to stay OUT of side effects unless <em>really</em> needed - that is the happy path in OCaml coding</li>
  <li>The autograder may let you get away with side effects on assignment 1/2 but you will get a manual ding by the CAs.</li>
</ul>

<h3 id="state">State</h3>
<ul>
  <li>Variables in OCaml are <strong>never</strong> directly mutable themselves; only (indirectly) mutable if they hold a
    <ul>
      <li>reference</li>
      <li>mutable record</li>
      <li>array</li>
    </ul>
  </li>
</ul>

<p>Indirect mutability - variable itself can’t change, but what it points to can.</p>
<ul>
  <li>items are immutable unless their mutability is explicitly declared</li>
</ul>

<h3 id="mutable-references">Mutable References</h3>

<ul>
  <li>References are more like standard PL variables which can change but there are some subtle differences
    <ul>
      <li>You can’t make a reference without any value in it, there is no <code>null</code> pointer possible.</li>
      <li>References are more an <em>immutable</em> pointer to a <em>mutable</em> block, they are not directly mutable</li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">4</span><span class="p">;;</span>    <span class="c">(* declare initial value when creating; type is `int ref` here *)</span>
</code></pre></div></div>

<p>Meaning of the above: x forevermore (i.e. forever unless shadowed) refers to a fixed cell.  The <strong>contents</strong> of that fixed call <strong>can</strong> change, but not x.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* x + 1;; *)</span> <span class="c">(* a type error ! *)</span>
<span class="o">!</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span> <span class="c">(* need `!x` to get out the value; parallels `*x` in C *)</span>
<span class="n">x</span> <span class="o">:=</span> <span class="mi">6</span><span class="p">;;</span> <span class="c">(* assignment - x must be a ref cell.  Returns () - goal is side effect *)</span>
<span class="o">!</span><span class="n">x</span><span class="p">;;</span> <span class="c">(* Mutation happened to contents of cell x *)</span>
<span class="k">let</span> <span class="n">x_alias</span> <span class="o">=</span> <span class="n">x</span><span class="p">;;</span> <span class="c">(* make another name for x since we are about to shadow it *)</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="s2">"hi"</span><span class="p">;;</span> <span class="c">(* does NOT mutate x above, instead another shadowing definition *)</span>
<span class="o">!</span><span class="n">x_alias</span><span class="p">;;</span> <span class="c">(* confirms the previous line was not a mutation, just a shadowing *)</span>
</code></pre></div></div>

<h4 id="refs-are-really-mutable-records">Refs are “really” mutable records</h4>
<ul>
  <li><code>'a ref</code> is in fact implemented by a mutable record with one field, contents:</li>
  <li><code>'a ref</code> abbreviates the type <code>{ mutable contents: 'a }</code></li>
  <li>The keyword <code>mutable</code> on a record field means it can change</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{</span> <span class="n">contents</span> <span class="o">=</span> <span class="mi">4</span><span class="p">};;</span> <span class="c">(* identical to `let x = ref 4` *)</span>
<span class="n">x</span> <span class="o">:=</span> <span class="mi">6</span><span class="p">;;</span>
<span class="n">x</span><span class="o">.</span><span class="n">contents</span> <span class="o">&lt;-</span> <span class="mi">7</span><span class="p">;;</span>  <span class="c">(* same effect as previous line: backarrow updates a field *)</span>
<span class="o">!</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span>
<span class="n">x</span><span class="o">.</span><span class="n">contents</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span> <span class="c">(* same effect as previous line *)</span>
</code></pre></div></div>

<p>Declaring your own mutable record: put <code>mutable</code> qualifier on field</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">mutable_point</span> <span class="o">=</span> <span class="p">{</span> <span class="k">mutable</span> <span class="n">x</span><span class="o">:</span> <span class="kt">float</span><span class="p">;</span> <span class="k">mutable</span> <span class="n">y</span><span class="o">:</span> <span class="kt">float</span> <span class="p">};;</span>
<span class="k">let</span> <span class="n">translate</span> <span class="n">p</span> <span class="n">dx</span> <span class="n">dy</span> <span class="o">=</span>
                <span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">+.</span> <span class="n">dx</span><span class="p">);</span> <span class="c">(* observe use of ";" here to sequence effects *)</span>
                <span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="o">+.</span> <span class="n">dy</span><span class="p">)</span>  <span class="c">(* ";" is useless without side effects (think about it) *)</span>
                                <span class="p">;;</span>
<span class="k">let</span> <span class="n">mypoint</span> <span class="o">=</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="p">};;</span>
<span class="n">translate</span> <span class="n">mypoint</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="p">;;</span>
<span class="n">mypoint</span><span class="p">;;</span>
</code></pre></div></div>

<p>Observe: mypoint is immutable at the top level but it has two spots <code>x</code>/<code>y</code> in it where we can mutate</p>

<h3 id="arrays">Arrays</h3>
<ul>
  <li>Fairly self-explanatory, we will just flash over this</li>
  <li>Arrays are lists but we
    <ul>
      <li><em>can</em> mutate elements</li>
      <li><em>can</em> quickly (constant time) access the n-th element</li>
      <li>but are <em>hard</em> to extend or shorten</li>
    </ul>
  </li>
  <li>The main annoyance is the syntax is non-standard since <code>[..]</code> is already used for lists</li>
  <li>Have to be initialized before using
    <ul>
      <li>in general there is no such thing as “uninitialized”/”null” in OCaml</li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="o">|</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">2</span> <span class="o">|</span><span class="p">];;</span> <span class="c">(* one way to make a new array, or `Array.make 3 0` *)</span>
<span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">);;</span> <span class="c">(* access notation *)</span>
<span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="mi">5</span><span class="p">;;</span> <span class="c">(* update notation *)</span>
<span class="n">arr</span><span class="p">;;</span>
</code></pre></div></div>

<h3 id="exceptions">Exceptions</h3>
<ul>
  <li>OCaml has a standard (e.g. Java-like) notion of exceptions</li>
  <li>Unfortunately types do not include what exceptions a function will raise - an outdated aspect of OCaml.
    <ul>
      <li>If a side effect is notated in the type that is called an <em>effect type</em> - e.g. Rust uses this for mutation effects</li>
    </ul>
  </li>
  <li>Modern OCaml coding style is to <em>minimize</em> the use of exceptions
    <ul>
      <li>Causes action-at-a-distance, hard to debug</li>
      <li>Instead follow the old C approach of bubbling up error codes:
        <ul>
          <li>return <code>Some/None</code> and make the caller explicitly handle the <code>None</code> (error) case.</li>
          <li>we covered this a bit with the <code>nice_div</code> example above.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Here is a trivial example of how to declare and use exceptions in OCaml</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">exception</span> <span class="nc">Bad</span> <span class="k">of</span> <span class="kt">string</span><span class="p">;;</span> <span class="c">(* Exception named `Goo` has a string payload *)</span>

<span class="k">let</span> <span class="n">f</span> <span class="n">_</span> <span class="o">=</span> <span class="k">raise</span> <span class="p">(</span><span class="nc">Bad</span> <span class="s2">"keyboard on fire"</span><span class="p">);;</span>
<span class="c">(* f ();; *)</span> <span class="c">(* raises the exception to the top level *)</span>
<span class="c">(* (f ()) + 1;; *)</span> <span class="c">(* recall that exceptions blow away the context *)</span>

<span class="k">let</span> <span class="n">g</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">try</span>
    <span class="n">f</span> <span class="bp">()</span>
  <span class="k">with</span> <span class="c">(* `catch` keyword in Java; use pattern matching in handlers *)</span>
      <span class="nc">Bad</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"exception Bad raised with payload </span><span class="se">\"</span><span class="s2">%s</span><span class="se">\"</span><span class="s2"> </span><span class="se">\n</span><span class="s2">"</span> <span class="n">s</span>
<span class="p">;;</span>
<span class="n">g</span> <span class="bp">()</span><span class="p">;;</span>
</code></pre></div></div>

<p>There are a few built-in exceptions mentioned previously:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>failwith <span class="s2">"Oops"</span><span class="p">;;</span> <span class="o">(</span><span class="k">*</span> Generic code failure - exception is named <span class="sb">`</span>Failure<span class="sb">`</span> <span class="k">*</span><span class="o">)</span>
invalid_arg <span class="s2">"This function works on non-empty lists only"</span><span class="p">;;</span> <span class="o">(</span><span class="k">*</span> Invalid_argument exception <span class="k">*</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="modules">Modules</h3>

<p>Background on modules in programming languages</p>
<ul>
  <li>a <strong>module</strong> is a larger level of program abstraction, think functional components or library.</li>
  <li>e.g. Java package, Python module, C directory, etc</li>
  <li><em>something</em> is needed for all but very small programs: imagine a file system without directories/folders as an analogy to a PL without modules</li>
  <li>We are not going to study the theory of modules later in the course so will cover a bit more about the principles now</li>
</ul>

<h4 id="general-principles-of-modules">General principles of modules</h4>
<ul>
  <li>Modules have names they can be referenced by</li>
  <li>A module is a container of code: functions, classes,  types, etc.</li>
  <li>Modules can be file-based: one module per file, module name is file name.  Or, directory-based.   Or, neither.</li>
  <li>The module needs a way to
    <ul>
      <li><strong>import</strong> things (e.g. other modules) from the outside;</li>
      <li><strong>export</strong> some (or all) things it has declared for outsiders to use;</li>
      <li>it may <strong>hide</strong> some things for internal use only
        <ul>
          <li>allows module users to avoid seeing grubby internals - a higher level of abstraction</li>
          <li>avoids users mucking with internals and messing things up</li>
        </ul>
      </li>
      <li>Separate name spaces, so e.g. the <code>Window</code>’s <code>reset()</code> won’t clash<br />
with a <code>File</code>’s <code>reset()</code>: use <code>Window.reset()</code> and <code>File.reset()</code></li>
      <li>Nested name spaces for ever larger software: <code>Window.Init.reset()</code></li>
      <li>In compiled languages, modules can generally be compiled separately (only recompile the changed module(s))
        <ul>
          <li>speeds up incremental recompilation, an important feature in practice.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="modules-in-ocaml">Modules in OCaml</h3>

<ul>
  <li>We already saw OCaml modules in action
    <ul>
      <li>Example: <code>List.map</code> is an invocation of the map function in the built-in <code>List</code> module.</li>
      <li>Modules always start with a Capital letter, just like variant labels.</li>
    </ul>
  </li>
  <li>We now study how we can build and use our own OCaml modules</li>
  <li>(We focus here on building modules via files; there are other methods in OCaml which we skip)</li>
</ul>

<h4 id="making-a-module">Making a module</h4>

<ul>
  <li>Assignment 1/2 require you to fill out a file <code>assignment.ml</code></li>
  <li>This is in fact creating a <em>module</em> <code>Assignment</code> (notice the first letter (only) is capped)</li>
  <li><code>dune utop</code> will load your module in the top loop</li>
  <li>You then need to write <code>Assignment.reverse_n 5;;</code> etc to access the functions in the module’s namespace</li>
  <li>Or, use <code>open Assignment;;</code> to make all the functions in the module available at the top level.</li>
</ul>

<h3 id="separate-compilation-with-ocaml">Separate Compilation with OCaml</h3>

<ul>
  <li>File-based modules such as <code>assignment.ml</code> are compiled separately.</li>
  <li>This is the traditional <code>javac</code>/<code>cc</code>/etc style of coding, done with <code>ocamlc</code> in ocaml</li>
  <li>Also in the Java/C spirit, it is how you write a standalone app in OCaml</li>
  <li>The underlying <code>ocamlc</code> compiler you don’t need to directly invoke, in this course we will give you <code>dune</code> build files which invoke the compioler for you
    <ul>
      <li><code>dune</code> is <code>make</code> for OCaml</li>
      <li><code>dune build</code> invokes the OCaml compiler on all the files in a project</li>
      <li>if you are curious what actual compiler calls are happening, add <code>--verbose</code> to the build command</li>
    </ul>
  </li>
</ul>

<h3 id="an-example-of-a-separately-compiled-ocaml-program">An example of a separately-compiled OCaml program</h3>

<ul>
  <li>See <a href="http://pl.cs.jhu.edu/pl/ocaml/set-example.zip">set-example.zip</a> for the example we cover in lecture.</li>
</ul>

<h3 id="playing-with-the-simple_set-library-module">Playing with the Simple_set library module</h3>
<ul>
  <li>For this example we can use terminal command <code>dune utop</code> to load the library module into a fresh <code>utop</code></li>
</ul>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dune utop
</code></pre></div></div>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Simple_set.emptyset<span class="p">;;</span> <span class="o">(</span><span class="k">*</span> simple_set.ml<span class="s1">'s binary is loaded as module Simple_set *)
open Simple_set;;     (* open makes `emptyset` etc in module available without typing `Simple_set.` *)
let aset = List.fold_left (Fun.flip add) emptyset [1;2;3;4] ;;
contains 3 aset ;;
</span></code></pre></div></div>

<h3 id="end-of-ocaml">End of OCaml!</h3>

<ul>
  <li>If you want to learn more about software engineering in OCaml, consider taking <a href="https://pl.cs.jhu.edu/fpse">Functional Progamming in Software Engineering</a> in the fall</li>
  <li>Or, just click on the above course link for resources to teach it to yourself.</li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: <a href="http://templated.co">TEMPLATED</a> Images: <a href="http://unsplash.com">Unsplash</a> (<a href="http://unsplash.com/cc0">CC0</a>)
				</div>			


   </body>
</html>
