<!DOCTYPE HTML>
<!--
 Solarize by TEMPLATED
 templated.co @templatedco
 Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
 <head>
  <title>Principles of Programming Languages</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="description" content="" />
  <meta name="keywords" content="" />
  <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
  <script src="/pl/js/jquery.min.js"></script>
  <script src="/pl/js/jquery.dropotron.min.js"></script>
  <script src="/pl/js/skel.min.js"></script>
  <script src="/pl/js/skel-layers.min.js"></script>
  <script src="/pl/js/init.js"></script>
  <noscript>
   <link rel="stylesheet" href="/pl/css/skel.css" />
   <link rel="stylesheet" href="/pl/css/style.css" />
  </noscript>
  <!--[if lte IE 8]><link rel="stylesheet" href="/pl/css/ie/v8.css" /><![endif]-->
 </head>
 <body>

  <!-- Header Wrapper -->
   <div class="wrapper style1">
   
   <!-- Header -->
    <div id="header">
     <div class="container">
       
      <!-- Logo -->
       <h1><a href="/pl/index.html" id="logo">Principles of PL</a></h1>
      
      <!-- Nav -->
       <nav id="nav">
        <ul>
         <li class="active"><a href="/pl/index.html">Home</a></li>
         <li>
          <a href="/pl/logistics.html">Logistics</a>
          <ul class="menu">
           <li><a href="/pl/dateline.html">Dateline</a></li>
           <li><a href="https://gradescope.com">Gradescope</a></li>
           <li><a href="https://campuswire.com/c/G9E051068">Q&amp;A</a></li>
           <li><a href="/pl/contact.html">Contact Us</a></li>
          </ul>
         </li>
         <li><a href="/pl/book">The Book</a>
         <ul class="menu">
         <li><a href="/pl/book/book.pdf">The book PDF</a></li>
         <li><a href="/pl/book/dist/">The FbDK dist</a></li>
       </ul></li>

         <li><a href="/pl/ocaml/index.html">OCaml</a>
         </li>
         <li><a href="">Assignments</a>
         <ul class="menu">
         <li><a href="/pl/assignments/assignment1.html">Assignment 1</a></li>
         <li><a href="/pl/assignments/assignment2.html">Assignment 2</a></li>
         <li><a href="/pl/assignments/assignment3.html">Assignment 3</a></li>
         <li><a href="/pl/assignments/assignment4.html">Assignment 4</a></li>
         <li><a href="/pl/assignments/assignment5.html">Assignment 5</a></li>
         <li><a href="/pl/assignments/assignment6.html">Assignment 6</a></li>
         <li><a href="/pl/assignments/assignment7.html">Assignment 7</a></li>
         <li><a href="/pl/assignments/assignment8.html">Assignment 8</a></li>
         <li><a href="/pl/assignments/assignment9.html">Assignment 9</a></li>
       </ul></li>
        </ul>
       </nav>
 
     </div>
    </div>
<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/pl/css/friendly.css" />
<meta charset="utf-8" />
    
<h2 id="introduction-to-ocaml-programming">Introduction to OCaml Programming</h2>

<ul>
  <li>OCaml is a <em>strongly typed functional programming language</em>
    <ul>
      <li>Strongly typed means the compiler will detect type errors; you won’t get them at runtime like in JavaScript/Python</li>
      <li>Functional means an emphasis on <em>functions</em> as a key building block and use of functions as data (functions that themselves can take functions as arguments and return functions as results)</li>
    </ul>
  </li>
</ul>

<p>(Note if you want to get all the code (only) in this webpage into a <code>.ml</code> file to load into your editor, download the file <a href="lecture.ml">lecture.ml</a>.)</p>

<h3 id="the-top-loop">The top loop</h3>

<ul>
  <li>We will begin exploration of OCaml in the interactive <em>top loop</em></li>
  <li>The top loop is the same as the read-eval-print loop or the console window for other languages</li>
  <li>To get the top loop we are using, <code>utop</code>, follow the course <a href="../index.html">OCaml install instructions</a>.</li>
</ul>

<h4 id="simple-integer-operations-in-the-top-loop">Simple integer operations in the top loop</h4>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;;</span> <span class="c">(* ";;" denotes end of input, somewhat archaic. *)</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;;</span> <span class="c">(* give the value a name via let keyword. *)</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;;</span> <span class="c">(* can use x now *)</span>
<span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span> <span class="k">in</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;;</span> <span class="c">(* let .. in defines a local variable z *)</span>
</code></pre></div></div>

<h4 id="boolean-operations">Boolean operations</h4>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">true</span><span class="p">;;</span>
<span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="bp">false</span><span class="p">;;</span>
<span class="bp">true</span> <span class="o">||</span> <span class="bp">false</span><span class="p">;;</span>
<span class="mi">1</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;;</span> <span class="c">(* = not == for equality comparison - ! *)</span>
<span class="mi">1</span> <span class="o">&lt;&gt;</span> <span class="mi">2</span><span class="p">;;</span>  <span class="c">(* &lt;&gt; not != for not equal *)</span>
</code></pre></div></div>

<h4 id="other-basic-data--see-documentation-for-details">Other basic data – see documentation for details</h4>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">4</span><span class="o">.</span><span class="mi">5</span><span class="p">;;</span> <span class="c">(* floats *)</span>
<span class="mi">4</span><span class="o">.</span><span class="mi">5</span> <span class="o">+.</span> <span class="mi">4</span><span class="o">.</span><span class="mi">3</span><span class="p">;;</span> <span class="c">(* operations are +. etc not just + which is for ints only *)</span>
<span class="mi">30980314323422</span><span class="nc">L</span><span class="p">;;</span> <span class="c">(* 64-bit integers *)</span>
<span class="k">'</span><span class="n">c'</span><span class="p">;;</span> <span class="c">(* characters *)</span>
<span class="s2">"and of course strings"</span><span class="p">;;</span>
</code></pre></div></div>

<h4 id="simple-functions-on-integers">Simple functions on integers</h4>

<p>To declare a function <code>squared</code> with <code>x</code> its one parameter.  <code>return</code> is  implicit.</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">squared</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;;</span> 
<span class="n">squared</span> <span class="mi">4</span><span class="p">;;</span> <span class="c">(* to call a function -- separate arguments with S P A C E S *)</span>
</code></pre></div></div>
<ul>
  <li>OCaml has no <code>return</code> statement; value of the whole body-expression is what gets returned</li>
  <li>Type is automatically <strong>inferred</strong> and printed as domain <code>-&gt;</code> range</li>
  <li>OCaml functions in fact always take only one argument - !  multiple arguments can be encoded (later)</li>
</ul>

<h4 id="fibonacci-series-example---0-1-1-2-3-5-8-13-">Fibonacci series example - <code>0 1 1 2 3 5 8 13 ...</code></h4>

<p>Let’s write a well-known function with recursion and if-then-else syntax</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">fib</span> <span class="n">n</span> <span class="o">=</span>     <span class="c">(* the "rec" keyword needs to be added to allow recursion *)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">1</span>
  <span class="k">else</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);;</span> <span class="c">(* notice again everything is an expression, no "return" *)</span>

<span class="n">fib</span> <span class="mi">10</span><span class="p">;;</span> <span class="c">(* get the 10th Fibonacci number *)</span>
</code></pre></div></div>

<h4 id="anonymous-functions-basics">Anonymous functions basics</h4>

<ul>
  <li>Key advantage of FP: functions are just expressions; put them in variables, pass and return from other functions, etc.</li>
  <li>Much of this course will be showing how this is useful, we are just getting started now</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">add1</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span> <span class="c">(* a normal add1 definition *)</span>
<span class="k">let</span> <span class="n">anon_add1</span> <span class="o">=</span> <span class="p">(</span><span class="k">function</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);;</span> <span class="c">(* equivalent anonymous version; "x" is argument here *)</span>
<span class="n">anon_add1</span> <span class="mi">3</span><span class="p">;;</span>
<span class="p">(</span><span class="n">anon_add1</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;;</span> 
<span class="p">((</span><span class="k">function</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;;</span> <span class="c">(* can inline anonymous function definition *)</span>
<span class="p">((</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;;</span> <span class="c">(*  shorthand notation -- cut off the "ction" *)</span>
</code></pre></div></div>

<p><a name="ii"></a></p>
<h2 id="basic-ocaml-ii">Basic OCaml II</h2>

<ul>
  <li>Multiple arguments - just leave s p a c e s between multiple arguments in both definitions and uses</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;;</span>
<span class="n">add</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">;;</span>
<span class="p">(</span><span class="n">add</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">4</span><span class="p">;;</span> <span class="c">(* same meaning as previous application -- two applications, " " associates LEFT *)</span>
<span class="k">let</span> <span class="n">add3</span> <span class="o">=</span> <span class="n">add</span> <span class="mi">3</span><span class="p">;;</span> <span class="c">(* No need to give all arguments at once!  Type of add is int -&gt; (int -&gt; int) - "CURRIED" *)</span>
<span class="n">add3</span> <span class="mi">4</span><span class="p">;;</span>
<span class="n">add3</span> <span class="mi">20</span><span class="p">;;</span>
<span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">;;</span> <span class="c">(* Putting () around any infix operator turns it into a 2-argument function *)</span>
</code></pre></div></div>

<p>Conclusion: add is a function taking an integer, and returning a <strong>function</strong> which takes ints to ints.<br />
So, add is a <strong>higher-order function</strong>: it returns a function as result.</p>

<p>Observe <code>int -&gt; int -&gt; int</code> is parenthesized as <code>int -&gt; (int -&gt; int)</code> – unusual <strong>right</strong> associativity</p>

<p>Be careful on operator precedence with this goofy way that function application doesn’t need parens!</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add3</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);;</span>
<span class="n">add3</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;;</span> <span class="c">(* NOT the previous - this is the same as (add3 3) * 2 - application binds tighter than * *)</span>
<span class="n">add3</span> <span class="o">@@</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;;</span> <span class="c">(* LIKE the original - @@ is like the " " for application but binds LOOSER than other ops *)</span>
</code></pre></div></div>

<h3 id="simple-structured-data-types-option-and-result">Simple Structured Data Types: Option and Result</h3>

<ul>
  <li>Before getting into “bigger” data types and how to declare our own, let’s use one of the simplest structured data types, the built-in <code>option</code> type.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Some</span> <span class="mi">5</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">Some</span> <span class="mi">5</span>
</code></pre></div></div>

<ul>
  <li>all this does is “wrap” the 5 in the <code>Some</code> tag</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">None</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span>
</code></pre></div></div>

<ul>
  <li>Notice these are both in the <code>option</code> type .. either you have <code>Some</code> data or you have <code>None</code>.</li>
  <li>These kinds of types with the capital-letter-named tags are called <strong>variants</strong> in OCaml; each tag wraps a different variant.</li>
  <li>The <code>option</code> type is very useful; here is a super simple example.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">nice_div</span> <span class="n">m</span> <span class="n">n</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="nc">None</span> <span class="k">else</span> <span class="nc">Some</span> <span class="p">(</span><span class="n">m</span> <span class="o">/</span> <span class="n">n</span><span class="p">);;</span>
<span class="k">val</span> <span class="n">nice_div</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">nice_div</span> <span class="mi">10</span> <span class="mi">0</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span>
<span class="o">#</span> <span class="n">nice_div</span> <span class="mi">10</span> <span class="mi">2</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">Some</span> <span class="mi">5</span>
</code></pre></div></div>

<p>There is a downside with this though, you can’t just use <code>nice_div</code> like <code>/</code>:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="p">(</span><span class="n">nice_div</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;;</span>
<span class="nc">Line</span> <span class="mi">1</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">0</span><span class="o">-</span><span class="mi">14</span><span class="o">:</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">int</span> <span class="n">option</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span> <span class="kt">int</span>
</code></pre></div></div>

<p>This type error means the <code>+</code> lhs should be type <code>int</code> but is a <code>Some</code> value which is not an <code>int</code>.</p>

<p>Here is a non-solution to that:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">not_nice_div</span> <span class="n">m</span> <span class="n">n</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="nc">None</span> <span class="k">else</span> <span class="n">m</span> <span class="o">/</span> <span class="n">n</span><span class="p">;;</span>
<span class="nc">Line</span> <span class="mi">1</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">47</span><span class="o">-</span><span class="mi">52</span><span class="o">:</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">int</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="k">'</span><span class="n">a</span> <span class="n">option</span>
</code></pre></div></div>
<ul>
  <li>The <code>then</code> and <code>else</code> branches must return the same type, here they do not.</li>
  <li>The <code>int</code> and <code>int option</code> types have no overlap of members!  Generally true across OCaml.</li>
</ul>

<h4 id="pattern-matching-first-example">Pattern matching first example</h4>

<p>Here is a real solution to the above issue:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">match</span> <span class="p">(</span><span class="n">nice_div</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">)</span> <span class="k">with</span> 
   <span class="o">|</span> <span class="nc">Some</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">7</span> <span class="c">(* i is bound to the result, 2 here *)</span>
   <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"This should never happen, we divided by 2"</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div></div>
<ul>
  <li>This shows how OCaml lets us <em>destruct</em> option values, via the <code>match</code> syntax.</li>
  <li><code>match</code> is similar to <code>switch</code> in C/Java/.. but is much more flexible in OCaml</li>
  <li>The LHS in OCaml can be a general pattern which binds variables (the <code>i</code> here), etc</li>
  <li>Note that we turned <code>None</code> into a runtime exception via <code>failwith</code>.</li>
</ul>

<p>Lastly, the function could itself raise an exception</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">div_exn</span> <span class="n">m</span> <span class="n">n</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">failwith</span> <span class="s2">"divide by zero is bad!"</span> <span class="k">else</span> <span class="n">m</span> <span class="o">/</span> <span class="n">n</span><span class="p">;;</span>
<span class="n">div_exn</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>This has the property of not needing a match on the result.</li>
  <li>Note that the built-in <code>/</code> also raises an exception.</li>
  <li>Exceptions are side effects though, we want to minimize their usage to avoid error-at-a-distance.</li>
  <li>The above examples show how exceptional conditions can either be handled via exceptions or in the return value;
    <ul>
      <li>the latter is the C approach</li>
    </ul>
  </li>
</ul>

<h3 id="everything-is-an-expression">Everything is an expression</h3>

<p>Everything in OCaml returns values (i.e. is an ‘expression’) - no commands</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">then</span> <span class="p">(</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">35</span><span class="p">)</span> <span class="k">else</span> <span class="mi">6</span><span class="p">;;</span> <span class="c">(* ((x==3)?5:6)+1 in C *)</span>
<span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">then</span> <span class="mi">5</span> <span class="k">else</span> <span class="mi">6</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;;</span>
<span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">then</span> <span class="mi">5</span><span class="o">.</span><span class="mi">4</span> <span class="k">else</span> <span class="mi">6</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;;</span> <span class="c">(* type errors:  two branches of if must have same type *)</span>
</code></pre></div></div>

<h3 id="lists">Lists</h3>

<ul>
  <li>Lists are pervasive in OCaml</li>
  <li>They are <strong>immutable</strong> (cannot update elements in an existing list) so while they look something like arrays or vectors they are not</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">l1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">];;</span>
<span class="k">let</span> <span class="n">l2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">];;</span>
<span class="k">let</span> <span class="n">l3</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"a"</span><span class="p">;</span> <span class="s2">"b"</span><span class="p">;</span> <span class="s2">"c"</span><span class="p">];;</span>
<span class="k">let</span> <span class="n">l4</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="s2">"a"</span><span class="p">];;</span> <span class="c">(* error - All elements must have same type *)</span>
<span class="k">let</span> <span class="n">l5</span> <span class="o">=</span> <span class="bp">[]</span><span class="p">;;</span> <span class="c">(* empty list *)</span>
</code></pre></div></div>

<h4 id="operations-on-lists">Operations on lists.</h4>

<p>Lists are represented internally as <strong>binary trees</strong> with left child a leaf.</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span> <span class="o">::</span> <span class="n">l1</span><span class="p">;;</span> <span class="c">(* "::" is 'consing' 0 to the top of the tree - fast *)</span>
<span class="mi">0</span> <span class="o">::</span> <span class="p">(</span><span class="mi">1</span> <span class="o">::</span> <span class="p">(</span><span class="mi">2</span> <span class="o">::</span> <span class="p">(</span><span class="mi">3</span> <span class="o">::</span> <span class="bp">[]</span><span class="p">)));;</span> <span class="c">(* equivalent to [0;1;2;3] *)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">@</span> <span class="p">[</span><span class="mi">4</span><span class="p">;</span> <span class="mi">5</span><span class="p">];;</span> <span class="c">(* appending lists - slower, needs to cons 3/2/1 on front of [4;5] *)</span>
<span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">6</span><span class="p">];;</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">::</span> <span class="n">z</span><span class="p">;;</span>
<span class="n">z</span><span class="p">;;</span> <span class="c">(* Observe z itself did not change -- recall lists are immutable in OCaml *)</span>
</code></pre></div></div>

<h4 id="destructing-lists-with-pattern-matching">Destructing Lists with pattern matching</h4>

<ul>
  <li>Before writing real programs here is a simple example of pattern matching on a list.</li>
  <li>This function gets the head, the first element.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">hd</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span>  <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="nc">None</span>
  <span class="o">|</span>  <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="n">x</span> <span class="c">(* the pattern x :: xs  binds x to the first elt, xs to ALL the others *)</span>
<span class="p">;;</span>
<span class="n">hd</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span>
<span class="n">hd</span> <span class="p">[</span><span class="mi">1</span><span class="p">];;</span> <span class="c">(* [1] is 1 :: [] - !  So the head is 1. *)</span>
<span class="n">hd</span> <span class="bp">[]</span><span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>Lists are not random access like arrays; if you want to get the nth element, you need to work for it.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">nth</span> <span class="n">l</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span>  <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"no nth element in this list"</span>
  <span class="o">|</span>  <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">nth</span> <span class="n">xs</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">;;</span>
<span class="n">nth</span> <span class="p">[</span><span class="mi">33</span><span class="p">;</span><span class="mi">22</span><span class="p">;</span><span class="mi">11</span><span class="p">]</span> <span class="mi">1</span><span class="p">;;</span>
<span class="n">nth</span> <span class="p">[</span><span class="mi">33</span><span class="p">;</span><span class="mi">22</span><span class="p">;</span><span class="mi">11</span><span class="p">]</span> <span class="mi">3</span><span class="p">;;</span>
</code></pre></div></div>
<ul>
  <li>Pattern priority: pick the first matched clause</li>
  <li>The above two patterns are mutually exclusive so order irrelevant, but not in all cases.</li>
</ul>

<p>Don’t use non-exhaustive pattern matches!</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">dumb</span> <span class="n">l</span> <span class="o">=</span> <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
      <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="p">;;</span>
<span class="n">dumb</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span> <span class="c">(* this works to return head of list but.. *)</span>
<span class="n">dumb</span> <span class="bp">[]</span><span class="p">;;</span> <span class="c">(* runtime error here *)</span>
</code></pre></div></div>

<p>Built-in <code>List.hd</code> is the same as <code>dumb</code> and it is nearly always a <strong>dumb</strong> function, don’t use it unless it is 100% obvious that the list is not empty.</p>

<h3 id="list-library-functions">List library functions</h3>
<p>Fortunately many common list operations are in the <code>List</code> module in the standard library:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">nth</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">]</span> <span class="mi">2</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div></div>
<ul>
  <li>We will discuss modules later, but for now just think of them as containers of a collection of functions types etc.  Something like a <code>package</code> in Java, or a Java <code>class</code> with only <code>static</code> methods.</li>
</ul>

<p>Some more handy <code>List</code> library functions</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="p">[</span><span class="s2">"d"</span><span class="p">;</span><span class="s2">"ss"</span><span class="p">;</span><span class="s2">"qwqw"</span><span class="p">];;</span>
<span class="nn">List</span><span class="p">.</span><span class="n">concat</span> <span class="p">[[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">];[</span><span class="mi">22</span><span class="p">;</span><span class="mi">33</span><span class="p">];[</span><span class="mi">444</span><span class="p">;</span><span class="mi">5555</span><span class="p">]];;</span>
<span class="nn">List</span><span class="p">.</span><span class="n">append</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">];;</span> 
<span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">]</span> <span class="o">@</span> <span class="p">[</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">]</span> <span class="c">(* Use this equivalent infix syntax for append *)</span>
</code></pre></div></div>

<ul>
  <li>Type <code>#show List;;</code> into utop to get a dump of all the functions in <code>List</code>.</li>
  <li>The <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html">Standard Library Reference page for lists</a> contains descriptions as well.</li>
  <li>There are similar modes for <code>Int</code>, <code>String</code>, <code>Float</code>, etc modules which similarly contain handy functions.</li>
</ul>

<h4 id="types-of-these-library-functions">Types of these library functions</h4>

<ul>
  <li>The types of the functions are additional hints to their purpose, get used to reading them</li>
  <li>Much of the time when you mis-use a function you will get a type error</li>
  <li><code>'a list</code> etc is a polymorphic aka generic type, <code>'a</code> can be <em>any</em> type<br />
```ocaml
    <h1 id="listlength">List.length;;</h1>
  </li>
  <li>: ‘a list -&gt; int = <fun>
</fun>    <h1 id="listconcat">List.concat;;</h1>
  </li>
  <li>: ‘a list list -&gt; ‘a list = <fun>
</fun>    <h1 id="listappend">List.append;;</h1>
  </li>
  <li>: ‘a list -&gt; ‘a list -&gt; ‘a list = <fun>
```</fun></li>
</ul>

<p>A cool feature of OCaml is how it automatically <em>infers</em> polymorphic types, unlike Java where generics usually need to be declared explicitly.</p>

<h3 id="correctness-of-recursive-functions">Correctness of recursive Functions</h3>

<p>Consider list reverse (no need to code as it is <code>List.rev</code>; this is just an example):</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">rev</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span>  <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">rev</span> <span class="n">xs</span> <span class="o">@</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="p">;;</span>
<span class="n">rev</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span> <span class="c">(* recall [1;2;3] is equivalent to 1 :: ( 2 :: ( 3 :: [])) *)</span>
</code></pre></div></div>

<p>Let us argue why this works.</p>

<p>We assume we have a notion of “program fragments behaving the same”, <code>~=</code>.</p>
<ul>
  <li>e.g. <code>1 + 2 ~= 3</code>, <code>1 :: [] ~= [1]</code>, etc.</li>
  <li>(<code>~=</code> is called “operational equivalence”, we will define it later in the course)</li>
</ul>

<p>Before doing the general case, here are some equivalences we can see from the above program run <br />
(by running it in our heads):</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rev</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">]</span> 
<span class="o">~=</span> <span class="n">rev</span> <span class="p">(</span><span class="mi">1</span> <span class="o">::</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">])</span> <span class="p">(</span><span class="n">by</span> <span class="n">the</span> <span class="n">meaning</span> <span class="k">of</span> <span class="n">the</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="kt">list</span> <span class="n">syntax</span><span class="p">)</span>
<span class="o">~=</span> <span class="p">(</span><span class="n">rev</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">])</span> <span class="o">@</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="p">(</span><span class="n">the</span> <span class="n">second</span> <span class="n">pattern</span> <span class="n">is</span> <span class="n">matched</span><span class="o">:</span> <span class="n">x</span> <span class="n">is</span> <span class="mi">1</span><span class="o">,</span> <span class="n">xs</span> <span class="n">is</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">]</span> <span class="ow">and</span> <span class="n">run</span> <span class="n">the</span> <span class="k">match</span> <span class="n">body</span><span class="p">)</span>
<span class="o">~=</span> <span class="p">(</span><span class="n">rev</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">@</span> <span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">@</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="p">(</span><span class="n">same</span> <span class="n">thing</span> <span class="k">for</span> <span class="n">the</span> <span class="n">rev</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">]</span> <span class="n">expression</span> <span class="o">-</span> <span class="n">plug</span> <span class="k">in</span> <span class="n">its</span> <span class="n">elaboration</span><span class="p">)</span>
<span class="o">~=</span> <span class="p">((</span><span class="n">rev</span> <span class="bp">[]</span> <span class="o">@</span> <span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">@</span> <span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">@</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="o">~=</span> <span class="p">(([]</span> <span class="o">@</span> <span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">@</span> <span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">@</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="o">~=</span> <span class="p">[</span><span class="mi">3</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">1</span><span class="p">]</span> <span class="p">(</span><span class="n">by</span> <span class="n">the</span> <span class="n">meaning</span> <span class="k">of</span> <span class="n">append</span><span class="p">)</span>
</code></pre></div></div>

<p>But, what we really want to show is it reverses ANY list.. use induction!</p>

<p>Let P(n) mean “for any list l of length n, <code>rev l ~=</code> its reverse”.</p>

<p>Recall an induction principle:<br />
To show P(n) for all in, it suffices to show <br />
  1) P(0), and <br />
  2) P(k) holds implies P(k+1) holds for any natural number k.</p>

<ul>
  <li>Induction is not explained well by mathematicians which causes confusion</li>
  <li>It is easier for us CS-ers, the induction step 2) is really just a <strong>proof macro</strong> with k a parameter</li>
  <li>Induction is justified by repeatedly instantiating the macro for 1,2,3,..</li>
</ul>

<p>So, if we showed 1) and 2) above,</p>
<ul>
  <li>P(0) is true by 1)</li>
  <li>P(1) is true because letting k=0 in 2) we have P(0) implies P(1),<br />
  and we just showed we have P(0), so we also have P(1).</li>
  <li>P(2) is true because letting k=1 in 2) we have P(1) implies P(2),<br />
  and we just showed we have P(1), so we also have P(2).</li>
  <li>P(3) is true because letting k=2 in 2) we have P(2) implies P(3),<br />
  and we just showed we have P(2), so we also have P(3).</li>
  <li>… etc for all k</li>
</ul>

<p>Let us now prove by induction.</p>

<p>Theorem: For any list <code>l</code> of length n, <code>rev l ~=</code> the reverse of <code>l</code> .<br />
Proof.  Proceed by induction to show this property for any n.<br />
  1) for n = 0, <code>l ~= []</code> since that is the only 0-length list.<br />
     <code>rev [] ~= []</code> which is <code>[]</code> reversed, check!<br />
  2) Assume for any k-length list <code>l</code> that <code>rev l ~= l</code> reversed.<br />
     Show for any k+1 length list, i.e. for any list <code>x :: l</code><br />
     that <code>rev (x :: l) ~= (x :: l)</code> reversed:</p>

<p>OK, by computing, <code>rev (x :: l) ~= rev l @ [x]</code>.<br />
Now by the induction hypothesis, <code>rev l</code> is <code>l</code> reversed.<br />
So, since <code>(l</code> reversed<code>) @ [x]</code> reverses the whole list <code>x :: l</code>,<br />
<code>rev (x :: l) ~= (x :: l)</code> reversed.<br />
This completes the induction step.</p>

<p>QED.</p>

<p><a name="iii"></a></p>
<h3 id="ocaml-lecture-iii">OCaml Lecture III</h3>

<h3 id="tuples">Tuples</h3>

<p>Think of tuples as fixed length lists, where the types of each element can differ, unlike lists</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="s2">"hi"</span><span class="p">);;</span>        <span class="c">(* type is int * string -- '*' is like "x" of set theory, a product *)</span>
<span class="k">let</span> <span class="n">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="s2">"hi"</span><span class="p">);;</span>
<span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span><span class="o">,</span><span class="k">'</span><span class="n">c'</span><span class="o">,</span><span class="s2">"cc"</span><span class="p">);;</span>
</code></pre></div></div>
<p>Tuple pattern matching</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="s2">"hi"</span><span class="o">,</span> <span class="mi">1</span><span class="o">.</span><span class="mi">2</span><span class="p">);;</span>

<span class="k">match</span> <span class="n">tuple</span> <span class="k">with</span>
  <span class="p">(</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">th</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="p">;;</span>

<span class="c">(* shorthand for the above - only one pattern, can use let syntax *)</span>
<span class="k">let</span> <span class="p">(</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">th</span><span class="p">)</span> <span class="o">=</span> <span class="n">tuple</span> <span class="k">in</span> <span class="n">s</span><span class="p">;;</span>
</code></pre></div></div>

<h4 id="consequences-of-immutable-variable-declarations-on-the-top-loop">Consequences of immutable variable declarations on the top loop</h4>

<ul>
  <li>All variable declarations in OCaml are <strong>immutable</strong> – value will never change</li>
  <li>Helps in reasoning about programs, we know the variable’s value is fixed</li>
  <li>But can be confusing when shadowing (re-definition) happens</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">in</span>
  <span class="p">(</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span> <span class="k">in</span>
    <span class="p">(</span> <span class="k">let</span> <span class="n">f</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span> <span class="k">in</span>
      <span class="p">(</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="k">in</span>  <span class="c">(* this is a re-definition of x, NOT an assignment *)</span>
        <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">x</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)(</span><span class="o">*</span> <span class="n">x</span> <span class="n">is</span> <span class="nc">STILL</span> <span class="mi">5</span> <span class="k">in</span> <span class="n">the</span> <span class="k">function</span> <span class="n">body</span> <span class="o">-</span> <span class="n">thats</span> <span class="n">what</span> <span class="n">x</span> <span class="n">was</span> <span class="k">when</span> <span class="n">f</span> <span class="n">defined</span> <span class="o">*</span><span class="p">)</span>
<span class="p">)</span>
<span class="p">;;</span>
</code></pre></div></div>

<p>This is in the spirit of this C pseudo-code:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="p">{</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
     <span class="p">{</span> <span class="kt">int</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">f</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-&gt;</span> <span class="k">return</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">);</span> <span class="p">(</span><span class="o">*</span> <span class="n">imagining</span> <span class="n">higher</span><span class="o">-</span><span class="n">order</span> <span class="n">functions</span> <span class="n">in</span> <span class="n">C</span> <span class="o">*</span><span class="p">)</span>
       <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="p">(</span><span class="o">*</span> <span class="n">shadows</span> <span class="n">previous</span> <span class="n">x</span> <span class="n">in</span> <span class="n">C</span> <span class="o">*</span><span class="p">)</span>
         <span class="k">return</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">);</span> 
  <span class="p">}}}})</span>
</code></pre></div></div>

<p>The top loop is conceptually an open-ended series of let-ins which never close:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">f</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;;</span> <span class="c">(* as in previous example, this is a nested definition, not assignment! *)</span>
<span class="n">f</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">;;</span>
</code></pre></div></div>
<p>Function definitions are similar, you can’t mutate an existing definition.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">g</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">);;</span>
<span class="k">let</span> <span class="n">shad</span> <span class="o">=</span> <span class="n">f</span><span class="p">;;</span> <span class="c">(* make a new name for f above *)</span>
<span class="c">(* lets "change" f, say we made an error in its definition above *)</span>
<span class="k">let</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span>
<span class="n">g</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">);;</span> <span class="c">(* g still refers to the initial f - !! *)</span>

<span class="k">assert</span><span class="p">(</span> <span class="n">g</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);;</span> <span class="c">(* example of built-in assert in action - returns () if holds, exception if not *)</span>

<span class="k">let</span> <span class="n">g</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">);;</span> <span class="c">(* FIX to get new f: resubmit (identical) g code *)</span>

<span class="k">assert</span><span class="p">(</span><span class="n">g</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);;</span> <span class="c">(* now it works as we initially expected *)</span>
</code></pre></div></div>

<ul>
  <li>Moral: don’t code (too much) directly in the top-loop since this behavior can cause anomalies</li>
  <li>For Assignment 1, you will be able to say <code>dune test</code> in the terminal to run tests on your code, and <code>dune utop</code> will load it all into <code>utop</code> so you can then play with your functions.</li>
</ul>

<h4 id="mutually-recursive-functions">Mutually recursive functions</h4>

<p>Warm up to the next function - write a (useless) copy function on lists</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">copy</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>  <span class="n">hd</span><span class="o">::</span><span class="p">(</span><span class="n">copy</span> <span class="n">tl</span><span class="p">);;</span>

<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">copy</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span><span class="p">;</span><span class="mi">7</span><span class="p">;</span><span class="mi">8</span><span class="p">;</span><span class="mi">9</span><span class="p">;</span><span class="mi">10</span><span class="p">]</span>
</code></pre></div></div>
<ul>
  <li>Argue by induction that this will copy the input list <code>l</code>.</li>
  <li>(List copy is in fact useless because lists are immutable - compiler can <em>share</em>)
    <ul>
      <li>This property is a form of <em>referential transparency</em></li>
    </ul>
  </li>
</ul>

<p>Refine copy to flip back and forth between copying and not</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">copyodd</span> <span class="n">l</span> <span class="o">=</span> <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>  <span class="n">hd</span><span class="o">::</span><span class="p">(</span><span class="n">copyeven</span> <span class="n">tl</span><span class="p">)</span>
<span class="ow">and</span>  <span class="c">(* new keyword for declaring mutually recursive functions *)</span>
  <span class="n">copyeven</span> <span class="n">l</span> <span class="o">=</span> <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span>  <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">copyodd</span> <span class="n">xs</span><span class="p">;;</span>

<span class="n">copyodd</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span><span class="p">;</span><span class="mi">7</span><span class="p">;</span><span class="mi">8</span><span class="p">;</span><span class="mi">9</span><span class="p">;</span><span class="mi">10</span><span class="p">];;</span>
<span class="n">copyeven</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span><span class="p">;</span><span class="mi">7</span><span class="p">;</span><span class="mi">8</span><span class="p">;</span><span class="mi">9</span><span class="p">;</span><span class="mi">10</span><span class="p">];;</span>
</code></pre></div></div>

<h3 id="using-let--in-to-define-local-functions">Using <code>let .. in</code> to define local functions</h3>

<p>Here is a version that hides the <code>copyeven</code> function – make both internal and export one</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">copyodd</span> <span class="n">ll</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">copyoddlocal</span> <span class="n">l</span> <span class="o">=</span> <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span>  <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>  <span class="n">hd</span><span class="o">::</span><span class="p">(</span><span class="n">copyevenlocal</span> <span class="n">tl</span><span class="p">)</span>
  <span class="ow">and</span>
    <span class="n">copyevenlocal</span> <span class="n">l</span> <span class="o">=</span> <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span>        <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">copyoddlocal</span> <span class="n">xs</span>
  <span class="k">in</span>
  <span class="n">copyoddlocal</span> <span class="n">ll</span><span class="p">;;</span>

<span class="k">assert</span><span class="p">(</span><span class="n">copyodd</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span><span class="p">;</span><span class="mi">7</span><span class="p">;</span><span class="mi">8</span><span class="p">;</span><span class="mi">9</span><span class="p">;</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">7</span><span class="p">;</span><span class="mi">9</span><span class="p">]);;</span>
</code></pre></div></div>

<h3 id="higher-order-functions">Higher Order Functions</h3>

<p>Higher order functions are functions that either</p>
<ul>
  <li>take other functions as arguments</li>
  <li>or return functions as results</li>
  <li>or both of the above</li>
</ul>

<p>Why?</p>
<ul>
  <li>“pluggable” programming by passing in and out chunks of code</li>
  <li>greatly increases reusability of code since any varying code can be pulled out as a function to pass in</li>
  <li>Lets show the power by extracting out some pluggable code</li>
</ul>

<p>Example: append <code>"gobble"</code> to each word in a list of strings</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">appendgobblelist</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">hd</span> <span class="o">^</span><span class="s2">"gobble"</span><span class="p">)</span> <span class="o">::</span> <span class="n">appendgobblelist</span> <span class="n">tl</span><span class="p">;;</span>

<span class="n">appendgobblelist</span> <span class="p">[</span><span class="s2">"have"</span><span class="p">;</span><span class="s2">"a"</span><span class="p">;</span><span class="s2">"good"</span><span class="p">;</span><span class="s2">"day"</span><span class="p">];;</span>
<span class="p">(</span><span class="s2">"have"</span> <span class="o">^</span><span class="s2">"gobble"</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="s2">"a"</span><span class="o">^</span><span class="s2">"gobble"</span><span class="p">)</span> <span class="o">::</span> <span class="n">appendgobblelist</span> <span class="p">[</span><span class="s2">"good"</span><span class="p">;</span><span class="s2">"day"</span><span class="p">];;</span>
</code></pre></div></div>

<ul>
  <li>Lets pull out the “append gobble” action as a function parameter, make it code we can plug in</li>
  <li>The resulting function is called <code>map</code> (note it is also available as <code>List.map</code>):
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">map</span> <span class="n">f</span> <span class="n">l</span> <span class="o">=</span>  <span class="c">(* function f is an argument here *)</span>
<span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
<span class="o">|</span>  <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
<span class="o">|</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">hd</span><span class="p">)</span> <span class="o">::</span> <span class="n">map</span> <span class="n">f</span> <span class="n">tl</span><span class="p">;;</span>
</code></pre></div>    </div>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">middle</span> <span class="o">=</span> <span class="n">map</span> <span class="p">(</span><span class="k">function</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">^</span><span class="s2">"gobble"</span><span class="p">);;</span>
<span class="n">middle</span> <span class="p">[</span><span class="s2">"have"</span><span class="p">;</span><span class="s2">"a"</span><span class="p">;</span><span class="s2">"good"</span><span class="p">;</span><span class="s2">"day"</span><span class="p">];;</span>
</code></pre></div></div>

<p>Mapping on lists of pairs - in and out lists can be different types.</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="p">[(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="p">);(</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="p">)];;</span>
<span class="k">let</span> <span class="n">flist</span> <span class="o">=</span> <span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">fun</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">4</span><span class="p">]</span> <span class="p">;;</span> <span class="c">(* make a list of functions - why not? *)</span>
</code></pre></div></div>
<ul>
  <li>This aligns with the type of <code>map</code>, <code>('a -&gt; 'b) -&gt; 'a list -&gt; 'b list </code> - <code>'a</code> and <code>'b</code> can differ.</li>
</ul>

<h3 id="folds">Folds</h3>

<ul>
  <li>fold_left/right are classic operators on lists</li>
  <li>combines a vector of data like the reduce of map/reduce</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">fold_left</span> <span class="n">f</span> <span class="n">v</span> <span class="n">l</span> <span class="o">=</span> <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span>   <span class="o">-&gt;</span> <span class="n">v</span>
    <span class="o">|</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">fold_left</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">v</span> <span class="n">hd</span><span class="p">)</span> <span class="n">tl</span> <span class="c">(* pass down f v hd as "the new v" -- accumulating *)</span>
    <span class="p">;;</span>
</code></pre></div></div>

<p>Summing elements of a list can now be succinctly coded:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="k">fun</span> <span class="n">accum</span> <span class="o">-&gt;</span> <span class="n">elt</span> <span class="o">+</span> <span class="n">accum</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span> <span class="c">(* = (((0+1)+2)+3) - 0 on LEFT *)</span>
<span class="n">fold_left</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span> <span class="c">(* equivalent to previous *)</span>
</code></pre></div></div>

<p>Compare to this manual summate - pulled out the combining operator <code>+</code> and zero <code>0</code></p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">summate</span> <span class="n">accum</span> <span class="n">l</span> <span class="o">=</span> <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span>   <span class="o">-&gt;</span> <span class="n">accum</span>
    <span class="o">|</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">summate</span> <span class="p">(</span><span class="n">accum</span> <span class="o">+</span> <span class="n">hd</span><span class="p">)</span> <span class="n">tl</span> <span class="c">(* pass down f v hd as new "v" -- accumulating *)</span>
    <span class="p">;;</span>
<span class="n">summate</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span>
</code></pre></div></div>

<p>More examples.  Note this is <code>List.fold_left</code> in OCaml library</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">length</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">accum</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="n">accum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">0</span> <span class="n">l</span><span class="p">;;</span> <span class="c">(* adds accum, ignores elt *)</span>
<span class="k">let</span> <span class="n">rev</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">accum</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="n">elt</span><span class="o">::</span><span class="n">accum</span><span class="p">)</span> <span class="bp">[]</span> <span class="n">l</span><span class="p">;;</span> <span class="c">(* e.g. rev [1;2;3] = (3::(2::(1::[]))) *)</span>
</code></pre></div></div>
<ul>
  <li>Right fold is similar but f is applied “on the way out” of recursion, not “on the way down” like in left fold above.</li>
  <li>also in List.fold_right.</li>
  <li>Args are swapped compared to fold_left, be careful !</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">fold_right</span> <span class="n">f</span> <span class="n">l</span> <span class="n">v</span> <span class="o">=</span> <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">v</span>
  <span class="o">|</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">hd</span> <span class="p">(</span><span class="n">fold_right</span> <span class="n">f</span> <span class="n">tl</span> <span class="n">v</span><span class="p">)</span> <span class="c">(* v not changing on recursion here *)</span>
<span class="p">;;</span>
<span class="n">fold_right</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">]</span> <span class="mi">0</span><span class="p">;;</span> <span class="c">(* = (1+(2+(3+0))) - observe the 0 is on the right *)</span>
</code></pre></div></div>

<p>Example where left and right folds produce a different result:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="k">fun</span> <span class="n">accum</span> <span class="o">-&gt;</span> <span class="s2">"("</span><span class="o">^</span><span class="n">elt</span><span class="o">^</span><span class="s2">"+"</span><span class="o">^</span><span class="n">accum</span><span class="o">^</span><span class="s2">")"</span><span class="p">)</span> <span class="s2">"0"</span> <span class="p">[</span><span class="s2">"1"</span><span class="p">;</span><span class="s2">"2"</span><span class="p">;</span><span class="s2">"3"</span><span class="p">]</span> <span class="p">;;</span> 
<span class="n">fold_right</span> <span class="p">(</span><span class="k">fun</span> <span class="n">accum</span> <span class="o">-&gt;</span> <span class="k">fun</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="s2">"("</span><span class="o">^</span><span class="n">accum</span><span class="o">^</span><span class="s2">"+"</span><span class="o">^</span><span class="n">elt</span><span class="o">^</span><span class="s2">")"</span><span class="p">)</span> <span class="p">[</span><span class="s2">"1"</span><span class="p">;</span><span class="s2">"2"</span><span class="p">;</span><span class="s2">"3"</span><span class="p">]</span> <span class="s2">"0"</span> <span class="p">;;</span> 
</code></pre></div></div>

<p><code>map</code> is a simple right fold - the fold does the recursion work.</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">map</span> <span class="n">f</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="p">(</span><span class="k">fun</span> <span class="n">elt</span> <span class="n">accum</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">elt</span><span class="p">)</span><span class="o">::</span><span class="n">accum</span><span class="p">)</span> <span class="n">l</span> <span class="bp">[]</span><span class="p">;;</span>
</code></pre></div></div>

<p>Another example of left vs right - left’s accumulating maps and reverses</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">map_and_rev</span> <span class="n">f</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">accum</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">elt</span><span class="p">)</span><span class="o">::</span><span class="n">accum</span><span class="p">)</span> <span class="bp">[]</span> <span class="n">l</span> <span class="p">;;</span> <span class="c">(* notice how this reverses *)</span>
</code></pre></div></div>

<p>More operations</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">filter</span> <span class="n">f</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="p">(</span><span class="k">fun</span> <span class="n">elt</span> <span class="n">accum</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">f</span> <span class="n">elt</span> <span class="k">then</span> <span class="n">elt</span><span class="o">::</span><span class="n">accum</span> <span class="k">else</span> <span class="n">accum</span><span class="p">)</span> <span class="n">l</span> <span class="bp">[]</span><span class="p">;;</span> 
<span class="k">let</span> <span class="n">rev</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="p">(</span><span class="o">@</span><span class="p">)</span> <span class="n">l</span> <span class="bp">[]</span><span class="p">;;</span>
</code></pre></div></div>

<h3 id="pipeling-and-composition">Pipeling and composition</h3>

<p>Pipelining Example: get the nth-from the end from a list, by first reversing and then getting nth element.</p>

<p>Obvious version:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">nth_end</span> <span class="n">l</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">nth</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">l</span><span class="p">)</span> <span class="n">n</span><span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>But, from the analogy of shell pipes <code>|</code>, we are “piping” the output of <code>rev</code> into <code>nth</code> for some fixed n.</li>
  <li>Here is an equivalent way to code that using OCaml pipe notation, <code>|&gt;</code></li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">nth_end</span> <span class="n">l</span> <span class="n">n</span> <span class="o">=</span> <span class="n">l</span> <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="o">|&gt;</span> <span class="p">(</span><span class="nn">Fun</span><span class="p">.</span><span class="n">flip</span><span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">nth</span><span class="p">)</span> <span class="n">n</span><span class="p">);;</span>
</code></pre></div></div>
<ul>
  <li>All <code>[1;2] |&gt; List.rev</code> in fact does is apply the second argument to the first - very simple!</li>
  <li>The type gives it away: <code>(|&gt;)</code> has type <code>'a -&gt; ('a -&gt; 'b) -&gt; 'b</code></li>
  <li>The <code>Fun.flip</code> is needed to put the list argument second, not first
    <ul>
      <li>it is another interesting higher-order function, with type <code>('a -&gt; 'b -&gt; 'c) -&gt; 'b -&gt; 'a -&gt; 'c</code>.</li>
    </ul>
  </li>
</ul>

<h4 id="function-composition-functions-in-functions-out">Function Composition: functions in, functions out</h4>

<p>Composition function g o f: take two functions, return their composition</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">compose</span> <span class="n">g</span> <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">g</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">));;</span>

<span class="k">let</span> <span class="n">plus3</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">times2</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">times2plus3</span> <span class="o">=</span> <span class="n">compose</span> <span class="n">plus3</span> <span class="n">times2</span><span class="p">;;</span>
<span class="n">times2plus3</span> <span class="mi">10</span><span class="p">;;</span>
<span class="c">(* equivalent but with anonymous functions: *)</span>
<span class="n">compose</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="mi">10</span><span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>Equivalent ways to write the <code>compose</code> funtion in OCaml syntax</li>
  <li>Work on interconverting between these equivalent forms in your head</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">compose</span> <span class="n">g</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span>  <span class="n">g</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">);;</span>
<span class="k">let</span> <span class="n">compose</span> <span class="o">=</span> <span class="p">(</span><span class="k">fun</span> <span class="n">g</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">fun</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">g</span><span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">))));;</span>
</code></pre></div></div>

<h3 id="currying">Currying</h3>

<ul>
  <li>An idea due to logician Haskell Curry</li>
  <li>First lets recall how multi-argument functions work in OCaml</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">addC</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;;</span>
<span class="n">addC</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">;;</span> <span class="c">(* recall this is the same as '(addC 1) 2' *)</span>
<span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">addC</span> <span class="mi">1</span> <span class="k">in</span> <span class="n">tmp</span> <span class="mi">2</span><span class="p">;;</span> <span class="c">(* the partial application of arguments - result is a function *)</span>
</code></pre></div></div>

<p>An equivalent way to define <code>addC</code>, clarifying what the above means:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">addC</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">fun</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">);;</span>
<span class="c">(* and, yet another identical way .. *)</span>
<span class="k">let</span> <span class="n">addC</span> <span class="n">x</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;;</span>
<span class="c">(* Yet one more, this is the built-in (+) *)</span>
<span class="p">(</span><span class="o">+</span><span class="p">);;</span>
</code></pre></div></div>

<p>Here is the so-called non-Curried version: use a <em>pair of arguments</em> instead</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">addNC</span> <span class="n">p</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">p</span> <span class="k">with</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">;;</span>
</code></pre></div></div>

<p>Here is an equivalent OCaml syntax which looks like a standard C function</p>
<ul>
  <li>This is a one-argument function, but you can pattern match in the argument position in OCaml!
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">addNC</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;;</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>Notice how the type of the above differs from addC’s type: <code>int * int -&gt; int</code> vs <code>int -&gt; int -&gt; int</code>.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">addNC</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">);;</span>
<span class="n">addNC</span> <span class="mi">3</span><span class="p">;;</span> <span class="c">(* errors, need all or no arguments supplied *)</span>
</code></pre></div></div>
<ul>
  <li>Fact: these two approaches to defining a 2-argument function are isomorphic:<br />
<code>'a * 'b -&gt; 'c</code> ~= <code>'a -&gt; 'b -&gt; 'c</code></li>
  <li>(This isomorphism also holds in set theory, you may have already seen it)</li>
</ul>

<p>We now define two cool higher-order functions:</p>
<ul>
  <li><code>curry</code>   - takes in non-curry’ing 2-arg function and returns a curry’ing version</li>
  <li><code>uncurry</code> - takes in curry’ing 2-arg function and returns an non-curry’ing version</li>
</ul>

<p>Since we can then go back and forth between the two reps, they are <strong>ISOMORPHIC</strong></p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">curry</span> <span class="n">fNC</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="k">fun</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">fNC</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">);;</span>
<span class="k">let</span> <span class="n">uncurry</span> <span class="n">fC</span> <span class="o">=</span> <span class="k">fun</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">fC</span> <span class="n">x</span> <span class="n">y</span><span class="p">;;</span>

<span class="k">let</span> <span class="n">newaddNC</span> <span class="o">=</span> <span class="n">uncurry</span> <span class="n">addC</span><span class="p">;;</span>
<span class="n">newaddNC</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="p">);;</span>
<span class="k">let</span> <span class="n">newaddC</span>  <span class="o">=</span> <span class="n">curry</span>   <span class="n">addNC</span><span class="p">;;</span>
<span class="n">newaddC</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">;;</span>
</code></pre></div></div>

<p>Observe the types themselves pretty much specify the behavior</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">curry</span> <span class="o">:</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">c</span>
<span class="n">uncurry</span> <span class="o">:</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">c</span>
</code></pre></div></div>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">noop1</span> <span class="o">=</span> <span class="n">curry</span> <span class="p">(</span><span class="n">uncurry</span> <span class="n">addC</span><span class="p">);;</span> <span class="c">(* a no-op *)</span>
<span class="k">let</span> <span class="n">noop2</span> <span class="o">=</span> <span class="n">uncurry</span> <span class="p">(</span><span class="n">curry</span> <span class="n">addNC</span><span class="p">);;</span> <span class="c">(* another no-op; noop1 &amp; noop2 together show isomorphism *)</span>
</code></pre></div></div>
<h3 id="misc-ocaml">Misc OCaml</h3>

<p>See <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Stdlib.html">module Stdlib</a> for various functions available in the OCaml top-level like <code>+</code>, <code>^</code> (string append), <code>print_int</code> (print an integer), etc.</p>

<p>See <a href="http://caml.inria.fr/pub/docs/manual-ocaml/stdlib.html">the Standard Library</a> for modules of functions for <code>List</code>s, <code>String</code>s, <code>Int</code>egers, as well as <code>Set</code>s, <code>Map</code>s, etc, etc.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">print_string</span> <span class="p">(</span><span class="s2">"hi</span><span class="se">\n</span><span class="s2">"</span><span class="p">);;</span>
</code></pre></div></div>

<p>Some <code>Stdlib</code> built-in exception generating functions (more on exceptions later)</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">failwith</span> <span class="s2">"BOOM!"</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span> <span class="p">;;</span>
</code></pre></div></div>

<p>Invalid argument exception <code>invalid_arg</code>:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">invalid_arg</span> <span class="s2">"Let's be positive, please!"</span> <span class="k">else</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span>
<span class="n">f</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">);;</span>
</code></pre></div></div>

<ul>
  <li>OCaml infers types most of the time</li>
  <li>But, you can optionally declare types on any expression</li>
  <li>Put parens around any such declaration or it won’t parse</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">add</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">float</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="o">:</span> <span class="kt">float</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+.</span> <span class="n">y</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">add</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="p">(((</span><span class="n">x</span><span class="o">:</span><span class="kt">int</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">:</span> <span class="kt">int</span><span class="p">);;</span>
</code></pre></div></div>

<p>Type abbreviations are also possible via <code>type </code></p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">intpair</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">f</span> <span class="p">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">intpair</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="n">p</span> <span class="k">with</span>
                      <span class="p">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">l</span> <span class="o">+</span> <span class="n">r</span>
<span class="p">;;</span>
<span class="p">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="p">);;</span> <span class="c">(* ocaml doesn't call this an intpair by default *)</span>
<span class="n">f</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">);;</span> <span class="c">(* still, can pass it to the function expecting an intpair *)</span>
<span class="p">((</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="p">)</span><span class="o">:</span><span class="n">intpair</span><span class="p">);;</span> <span class="c">(* can also explicitly tag data with its type *)</span>
</code></pre></div></div>

<h3 id="time-out-to-solve-some-simple-problems">Time-out to solve some simple problems</h3>
<p>Lets work through some simple programming problems to get experience with writing simple functional OCaml programs</p>
<ol>
  <li>Write a function ‘toUpperCase’ which takes a list (l) of characters and returns a list which has the same characters as l, but capitalized (if not already).</li>
</ol>

<p>Notes: <br />
a. Assume that the capital of characters other than alphabets<br />
            (A - Z or a - z), are the characters themselves e.g.</p>

<pre><code>                character               corresponding capital character

                    a                             A
                    z                             Z
                    A                             A
                    1                             1
                    %                             %
</code></pre>

<p>b. You can only use <code>Char.code</code> and <code>Char.chr</code> library functions. You <strong>cannot</strong> use <code>Char.uppercase</code>.</p>

<p><strong>Answer:</strong></p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">toUpperChar</span> <span class="n">c</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">c_code</span> <span class="o">=</span> <span class="nn">Char</span><span class="p">.</span><span class="n">code</span> <span class="n">c</span> <span class="k">in</span>
  <span class="k">if</span> <span class="n">c_code</span> <span class="o">&gt;=</span> <span class="mi">97</span> <span class="o">&amp;&amp;</span> <span class="n">c_code</span> <span class="o">&lt;=</span> <span class="mi">122</span> <span class="k">then</span>
    <span class="nn">Char</span><span class="p">.</span><span class="n">chr</span> <span class="p">(</span><span class="n">c_code</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span>
  <span class="k">else</span> <span class="n">c</span><span class="p">;;</span>


<span class="k">let</span> <span class="k">rec</span> <span class="n">toUpperCase</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">c</span> <span class="o">::</span> <span class="n">cs</span> <span class="o">-&gt;</span> <span class="n">toUpperChar</span> <span class="n">c</span> <span class="o">::</span> <span class="n">toUpperCase</span> <span class="n">cs</span>
<span class="p">;;</span>
</code></pre></div></div>

<p>Test</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">assert</span><span class="p">(</span><span class="n">toUpperCase</span> <span class="p">[</span><span class="k">'</span><span class="n">a'</span><span class="p">;</span> <span class="k">'</span><span class="n">q'</span><span class="p">;</span> <span class="k">'</span><span class="nc">B'</span><span class="p">;</span> <span class="k">'</span><span class="nc">Z'</span><span class="p">;</span> <span class="k">'</span><span class="p">;</span><span class="k">'</span><span class="p">;</span> <span class="k">'</span><span class="o">!</span><span class="k">'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="k">'</span><span class="nc">A'</span><span class="p">;</span> <span class="k">'</span><span class="nc">Q'</span><span class="p">;</span> <span class="k">'</span><span class="nc">B'</span><span class="p">;</span> <span class="k">'</span><span class="nc">Z'</span><span class="p">;</span> <span class="k">'</span><span class="p">;</span><span class="k">'</span><span class="p">;</span> <span class="k">'</span><span class="o">!</span><span class="k">'</span><span class="p">]);;</span>
</code></pre></div></div>

<p>Could have used map instead (note map is built in as <code>List.map</code>):</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">toUpperCase</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">toUpperChar</span> <span class="n">l</span> <span class="p">;;</span>
</code></pre></div></div>

<p>Could have also defined it even more simply - partly apply the Curried map:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">toUpperCase</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">toUpperChar</span> <span class="p">;;</span>
</code></pre></div></div>

<ol>
  <li>Write a function ‘partition’ which takes a predicate (p) and a list (l) as arguments  and returns a tuple (l1, l2) such that l1 is the list of all the elements of l that satisfy the predicate p and l2 is the list of all the elements of l that do NOT satisfy p. The order of the elements in the input list (l) should be preserved.</li>
</ol>

<p>Note: A predicate is any function which returns a boolean. e.g. let isPositive n = (n &gt; 0);;</p>

<p><strong>Answer:</strong></p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">partition</span> <span class="n">p</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span><span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">([]</span><span class="o">,</span><span class="bp">[]</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">posl</span><span class="o">,</span><span class="n">negl</span><span class="p">)</span> <span class="o">=</span> <span class="n">partition</span> <span class="n">p</span> <span class="n">tl</span> <span class="k">in</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="n">hd</span><span class="p">)</span>
    <span class="k">then</span>
      <span class="p">(</span><span class="n">hd</span> <span class="o">::</span> <span class="n">posl</span><span class="o">,</span><span class="n">negl</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="p">(</span><span class="n">posl</span><span class="o">,</span><span class="n">hd</span><span class="o">::</span><span class="n">negl</span><span class="p">);;</span>
</code></pre></div></div>
<p>Test</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">isPositive</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">in</span>
<span class="k">assert</span><span class="p">(</span><span class="n">partition</span> <span class="n">isPositive</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">([</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span><span class="o">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="o">-</span><span class="mi">3</span><span class="p">]))</span>
</code></pre></div></div>

<ol>
  <li>Write a function <code>diff</code> which takes in two lists l1 and l2 and returns a list containing all elements in l1 not in l2.</li>
</ol>

<p>Note: You will need to write another function <code>contains x l</code> which checks  whether an element <code>x</code> is contained in a list <code>l</code> or not.</p>

<p><strong>Answer:</strong></p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">contains</span> <span class="n">x</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">false</span>
  <span class="o">|</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">||</span> <span class="n">contains</span> <span class="n">x</span> <span class="n">ys</span>
<span class="p">;;</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">diff</span> <span class="n">l1</span> <span class="n">l2</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l1</span> <span class="k">with</span>
    <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="n">contains</span> <span class="n">x</span> <span class="n">l2</span> <span class="k">then</span>
    <span class="n">diff</span> <span class="n">xs</span> <span class="n">l2</span>
      <span class="k">else</span>
    <span class="n">x</span> <span class="o">::</span> <span class="n">diff</span> <span class="n">xs</span> <span class="n">l2</span>
<span class="p">;;</span>
</code></pre></div></div>

<p>Tests</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">assert</span><span class="p">(</span><span class="n">contains</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">])</span>
<span class="k">assert</span><span class="p">(</span><span class="n">not</span><span class="p">(</span><span class="n">contains</span> <span class="mi">5</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">]))</span>
<span class="k">assert</span><span class="p">(</span><span class="n">diff</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">])</span>
<span class="k">assert</span><span class="p">(</span><span class="n">diff</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">[]</span><span class="p">)</span>
</code></pre></div></div>

<p><a name="iv"></a></p>
<h3 id="ocaml-lecture-iv-variants-records-mutution-exceptions-modules">OCaml Lecture IV: Variants, records, mutution, exceptions, modules</h3>

<p>We saw a simple examples of variants above, the <code>option</code> type; now we go into the full possibilities</p>
<ul>
  <li>related to <code>union</code> types in C or <code>enum</code>s in Java: “this OR that OR theother”</li>
  <li>like OCamls lists/tuples they are IMMMUTABLE data structures</li>
  <li>each case of the union is identified by a name called ‘Constructor’ which serves for both
    <ul>
      <li>constructing values of the variant type</li>
      <li>inspecting them by pattern matching</li>
      <li>constructors must start with Capital Letter to distinguish from variables</li>
      <li>type declarations are needed but once they are in place type inference on them works</li>
    </ul>
  </li>
</ul>

<p>Example variant type for doing mixed arithmetic (integers and floats)</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">mynumber</span> <span class="o">=</span> <span class="nc">Fixed</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Floating</span> <span class="k">of</span> <span class="kt">float</span><span class="p">;;</span>  <span class="c">(* read "|" as "or" *)</span>

<span class="nc">Fixed</span><span class="p">(</span><span class="mi">5</span><span class="p">);;</span> <span class="c">(* tag 5 as a Fixed *)</span>
<span class="nc">Floating</span> <span class="mi">4</span><span class="o">.</span><span class="mi">0</span><span class="p">;;</span> <span class="c">(* tag 4.0 as a Floating *)</span>
</code></pre></div></div>

<p>Note constructors look like functions but they are <strong>not</strong> – you always need to give argument</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">pullout_int</span> <span class="n">x</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Fixed</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span>    <span class="c">(* variants fit well into pattern matching syntax *)</span>
    <span class="o">|</span> <span class="nc">Floating</span> <span class="n">z</span> <span class="o">-&gt;</span> <span class="n">int_of_float</span> <span class="n">z</span><span class="p">;;</span>

<span class="n">pullout_int</span> <span class="p">(</span><span class="nc">Fixed</span> <span class="mi">5</span><span class="p">);;</span>
</code></pre></div></div>

<p>A non-trivial function using the above variant type</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">add_num</span> <span class="n">n1</span> <span class="n">n2</span> <span class="o">=</span>
   <span class="k">match</span> <span class="p">(</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="p">)</span> <span class="k">with</span>    <span class="c">(* note use of pair here to parallel-match on two variables  *)</span>
     <span class="o">|</span> <span class="p">(</span><span class="nc">Fixed</span> <span class="n">i1</span><span class="o">,</span> <span class="nc">Fixed</span> <span class="n">i2</span><span class="p">)</span> <span class="o">-&gt;</span>       <span class="nc">Fixed</span>   <span class="p">(</span><span class="n">i1</span>       <span class="o">+</span>  <span class="n">i2</span><span class="p">)</span>
     <span class="o">|</span> <span class="p">(</span><span class="nc">Fixed</span> <span class="n">i1</span><span class="o">,</span>   <span class="nc">Floating</span> <span class="n">f2</span><span class="p">)</span> <span class="o">-&gt;</span>  <span class="nc">Floating</span><span class="p">(</span><span class="kt">float</span> <span class="n">i1</span> <span class="o">+.</span> <span class="n">f2</span><span class="p">)</span>       <span class="c">(* need to coerce *)</span>
     <span class="o">|</span> <span class="p">(</span><span class="nc">Floating</span> <span class="n">f1</span><span class="o">,</span> <span class="nc">Fixed</span> <span class="n">i2</span><span class="p">)</span>   <span class="o">-&gt;</span>  <span class="nc">Floating</span><span class="p">(</span><span class="n">f1</span>       <span class="o">+.</span> <span class="kt">float</span> <span class="n">i2</span><span class="p">)</span> <span class="c">(* ditto *)</span>
     <span class="o">|</span> <span class="p">(</span><span class="nc">Floating</span> <span class="n">f1</span><span class="o">,</span> <span class="nc">Floating</span> <span class="n">f2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nc">Floating</span><span class="p">(</span><span class="n">f1</span>       <span class="o">+.</span> <span class="n">f2</span><span class="p">)</span>
<span class="p">;;</span>

<span class="n">add_num</span> <span class="p">(</span><span class="nc">Fixed</span> <span class="mi">123</span><span class="p">)</span> <span class="p">(</span><span class="nc">Floating</span> <span class="mi">3</span><span class="o">.</span><span class="mi">14159</span><span class="p">);;</span>
</code></pre></div></div>

<p>Multiple data items in a single clause?  Use tuple types</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">complex</span> <span class="o">=</span> <span class="nc">CZero</span> <span class="o">|</span> <span class="nc">Nonzero</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span><span class="p">;;</span>

<span class="k">let</span> <span class="n">com</span> <span class="o">=</span> <span class="nc">Nonzero</span><span class="p">(</span><span class="mi">3</span><span class="o">.</span><span class="mi">2</span><span class="o">,</span><span class="mi">11</span><span class="o">.</span><span class="mi">2</span><span class="p">);;</span>
<span class="k">let</span> <span class="n">zer</span> <span class="o">=</span> <span class="nc">CZero</span><span class="p">;;</span>
</code></pre></div></div>

<h4 id="recursive-data-structures">Recursive data structures</h4>
<ul>
  <li>A key use of variant types</li>
  <li>Functional programming is fantastic for computing over tree-structured data</li>
  <li>Recursive types can refer to themselves in their own definition</li>
  <li>Similar in spirit to how C structs can be recursive (but, no pointer needed here)</li>
</ul>

<p>Warm-up: homebrew lists - built-in list type not needed<br />
First just int lists</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">myintlist</span> <span class="o">=</span> <span class="nc">Mt</span> <span class="o">|</span> <span class="nc">Cons</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">myintlist</span><span class="p">;;</span> <span class="c">(* Observe: self-referential type *)</span>
<span class="k">let</span> <span class="n">mylisteg</span> <span class="o">=</span> <span class="nc">Cons</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span><span class="nc">Cons</span><span class="p">(</span><span class="mi">5</span><span class="o">,</span><span class="nc">Cons</span><span class="p">(</span><span class="mi">7</span><span class="o">,</span><span class="nc">Mt</span><span class="p">)));;</span> <span class="c">(* equivalent to [3;5;7] *)</span>
</code></pre></div></div>
<p>Let us extend the above to be just like built-in polymorphic lists</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">mylist</span> <span class="o">=</span> <span class="nc">Mt</span> <span class="o">|</span> <span class="nc">Cons</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="n">mylist</span><span class="p">);;</span>
</code></pre></div></div>
<p>Observe how above type takes a (prefix) argument, ‘a – “mylist” is a type function</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">mylisteg</span> <span class="o">=</span> <span class="nc">Cons</span><span class="p">(</span><span class="mi">3</span><span class="o">.,</span><span class="nc">Cons</span><span class="p">(</span><span class="mi">5</span><span class="o">.,</span><span class="nc">Cons</span><span class="p">(</span><span class="mi">7</span><span class="o">.,</span><span class="nc">Mt</span><span class="p">)));;</span>
</code></pre></div></div>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">double_list_elts</span> <span class="n">ml</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">ml</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Mt</span> <span class="o">-&gt;</span> <span class="nc">Mt</span> <span class="c">(* vs [] -&gt; [] *)</span>
    <span class="o">|</span> <span class="nc">Cons</span><span class="p">(</span><span class="n">hd</span><span class="o">,</span><span class="n">tl</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nc">Cons</span><span class="p">(</span><span class="n">hd</span> <span class="o">*.</span> <span class="mi">2</span><span class="o">.,</span><span class="n">double_list_elts</span> <span class="n">tl</span><span class="p">);;</span> <span class="c">(* vs hd :: tl -&gt; .. *)</span>

<span class="n">double_list_elts</span> <span class="n">mylisteg</span><span class="p">;;</span>
</code></pre></div></div>

<p>Binary trees, like lists but two self-referential sub-structures not one</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">btree</span> <span class="o">=</span> <span class="nc">Leaf</span> <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">btree</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">btree</span><span class="p">;;</span>
</code></pre></div></div>

<p>Example trees</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">whack</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="s2">"whack!"</span><span class="o">,</span><span class="nc">Leaf</span><span class="o">,</span> <span class="nc">Leaf</span><span class="p">);;</span>
<span class="k">let</span> <span class="n">bt</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="s2">"fiddly "</span><span class="o">,</span>
            <span class="nc">Node</span><span class="p">(</span><span class="s2">"backer "</span><span class="o">,</span>
               <span class="nc">Leaf</span><span class="o">,</span>
               <span class="nc">Node</span><span class="p">(</span><span class="s2">"crack "</span><span class="o">,</span>
                  <span class="nc">Leaf</span><span class="o">,</span>
                  <span class="nc">Leaf</span><span class="p">))</span><span class="o">,</span>
            <span class="n">whack</span><span class="p">);;</span>

<span class="k">let</span> <span class="n">bt2</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="s2">"fiddly "</span><span class="o">,</span>
            <span class="nc">Node</span><span class="p">(</span><span class="s2">"backer "</span><span class="o">,</span>
               <span class="nc">Leaf</span><span class="o">,</span>
               <span class="nc">Node</span><span class="p">(</span><span class="s2">"crack "</span><span class="o">,</span>
                  <span class="nc">Leaf</span><span class="o">,</span>
                  <span class="nc">Leaf</span><span class="p">))</span><span class="o">,</span>
            <span class="n">whack</span><span class="p">);;</span>
<span class="c">(* Type error, like list, must have uniform type: *)</span>
<span class="nc">Node</span><span class="p">(</span><span class="s2">"fiddly"</span><span class="o">,</span><span class="nc">Node</span><span class="p">(</span><span class="mi">0</span><span class="o">,</span><span class="nc">Leaf</span><span class="o">,</span><span class="nc">Leaf</span><span class="p">)</span><span class="o">,</span><span class="nc">Leaf</span><span class="p">);;</span>
</code></pre></div></div>

<p>Functions on binary trees are similar to functions on lists: use recursion</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">add_gobble</span> <span class="n">binstringtree</span> <span class="o">=</span>
   <span class="k">match</span> <span class="n">binstringtree</span> <span class="k">with</span>
     <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="nc">Leaf</span>
   <span class="o">|</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">-&gt;</span>
       <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="s2">"gobble"</span><span class="o">,</span><span class="n">add_gobble</span> <span class="n">left</span><span class="o">,</span><span class="n">add_gobble</span> <span class="n">right</span><span class="p">)</span>
<span class="p">;;</span>
</code></pre></div></div>
<p>(Remember, this is not mutating the tree, its building a new one)</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">lookup</span> <span class="n">x</span> <span class="n">bintree</span> <span class="o">=</span>
   <span class="k">match</span> <span class="n">bintree</span> <span class="k">with</span>
     <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="bp">false</span>
     <span class="o">|</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">-&gt;</span>
       <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="k">then</span>
          <span class="bp">true</span>
       <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">then</span>
          <span class="n">lookup</span> <span class="n">x</span> <span class="n">left</span>
       <span class="k">else</span>
          <span class="n">lookup</span> <span class="n">x</span> <span class="n">right</span>
<span class="p">;;</span>

<span class="n">lookup</span> <span class="s2">"whack!"</span> <span class="n">bt</span><span class="p">;;</span>
<span class="n">lookup</span> <span class="s2">"flack"</span> <span class="n">bt</span><span class="p">;;</span>
</code></pre></div></div>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">bintree</span> <span class="o">=</span>
   <span class="k">match</span> <span class="n">bintree</span> <span class="k">with</span>
     <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="nc">Node</span><span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Leaf</span><span class="o">,</span> <span class="nc">Leaf</span><span class="p">)</span>
   <span class="o">|</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">-&gt;</span>
       <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="k">then</span>
         <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span>
       <span class="k">else</span>
         <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">right</span><span class="p">)</span>
<span class="p">;;</span>
</code></pre></div></div>

<p>This is also NOT MUTATING – returns a whole new tree instead.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">goobt</span> <span class="o">=</span> <span class="n">insert</span> <span class="s2">"goober "</span> <span class="n">bt</span><span class="p">;;</span>
<span class="n">bt</span><span class="p">;;</span> <span class="c">(* observe bt did not change after the insert *)</span>
<span class="k">let</span> <span class="n">gooobt</span> <span class="o">=</span> <span class="n">insert</span> <span class="s2">"slacker "</span> <span class="n">goobt</span><span class="p">;;</span> <span class="c">(* thread in the most recent tree *)</span>
</code></pre></div></div>

<h3 id="records">Records</h3>
<ul>
  <li>like tuples but with labels on fields.</li>
  <li>similar to the structs of C/C++.</li>
  <li>the types must be declared just like OCaml variants.</li>
  <li>can be used in pattern matches as well.</li>
  <li>again the fields are immutable by default</li>
</ul>

<p>Example: a record type to represent rational numbers</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">ratio</span> <span class="o">=</span> <span class="p">{</span><span class="n">num</span><span class="o">:</span> <span class="kt">int</span><span class="p">;</span> <span class="n">denom</span><span class="o">:</span> <span class="kt">int</span><span class="p">};;</span>
<span class="k">let</span> <span class="n">q</span> <span class="o">=</span> <span class="p">{</span><span class="n">num</span> <span class="o">=</span> <span class="mi">53</span><span class="p">;</span> <span class="n">denom</span> <span class="o">=</span> <span class="mi">6</span><span class="p">};;</span>
<span class="n">q</span><span class="o">.</span><span class="n">num</span><span class="p">;;</span>
<span class="n">q</span><span class="o">.</span><span class="n">denom</span><span class="p">;;</span>
</code></pre></div></div>

<p>Pattern matching works of course</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">rattoint</span> <span class="n">r</span> <span class="o">=</span>
 <span class="k">match</span> <span class="n">r</span> <span class="k">with</span>
   <span class="p">{</span><span class="n">num</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">d</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">/</span> <span class="n">d</span><span class="p">;;</span>
</code></pre></div></div>

<p>Only one pattern matched so can again inline pattern in functions and lets</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">rattoint</span> <span class="p">{</span><span class="n">num</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">d</span><span class="p">}</span>  <span class="o">=</span>
   <span class="n">n</span> <span class="o">/</span> <span class="n">d</span><span class="p">;;</span>
</code></pre></div></div>

<p>Equivalently can use dot projections, but happy path is usually patterns</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">rattoint</span> <span class="n">r</span>  <span class="o">=</span>
   <span class="n">r</span><span class="o">.</span><span class="n">num</span> <span class="o">/</span> <span class="n">r</span><span class="o">.</span><span class="n">denom</span><span class="p">;;</span>
<span class="n">rattoint</span> <span class="n">q</span><span class="p">;;</span>
</code></pre></div></div>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">add_ratio</span> <span class="n">r1</span> <span class="n">r2</span> <span class="o">=</span> <span class="p">{</span><span class="n">num</span> <span class="o">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">num</span> <span class="o">*</span> <span class="n">r2</span><span class="o">.</span><span class="n">denom</span> <span class="o">+</span> <span class="n">r2</span><span class="o">.</span><span class="n">num</span> <span class="o">*</span> <span class="n">r1</span><span class="o">.</span><span class="n">denom</span><span class="p">;</span> 
                      <span class="n">denom</span> <span class="o">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">denom</span> <span class="o">*</span> <span class="n">r2</span><span class="o">.</span><span class="n">denom</span><span class="p">};;</span>
<span class="n">add_ratio</span> <span class="p">{</span><span class="n">num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">denom</span> <span class="o">=</span> <span class="mi">3</span><span class="p">}</span> <span class="p">{</span><span class="n">num</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">denom</span> <span class="o">=</span> <span class="mi">5</span><span class="p">};;</span>
</code></pre></div></div>

<p>Annoying shadowing issue: there is one global namespace of record labels</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">newratio</span> <span class="o">=</span> <span class="p">{</span><span class="n">num</span><span class="o">:</span> <span class="kt">int</span><span class="p">;</span> <span class="n">coeff</span><span class="o">:</span> <span class="kt">float</span><span class="p">};;</span> <span class="c">(* shadows ratio's label num *)</span>

<span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">num</span><span class="p">;;</span> <span class="c">(* x is a newratio, the most recent num field defined *)</span>
</code></pre></div></div>
<p>Solution in event of shadowing: pattern match on full record</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="p">{</span><span class="n">num</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">_</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="p">;;</span>
</code></pre></div></div>

<h4 id="end-of-pure-functional-programming-in-ocaml">End of Pure Functional programming in OCaml</h4>
<ul>
  <li>On to side effects</li>
  <li>But before heading there, remember to stay OUT of side effects unless <em>really</em> needed - that is the happy path in OCaml coding</li>
  <li>The autograder may let you get away with side effects on assignment 1 but you will get a manual ding by the CAs.</li>
</ul>

<h3 id="state">State</h3>
<ul>
  <li>Variables in OCaml are NEVER directly mutable themselves; only (indirectly) mutable if they hold a
    <ul>
      <li>reference</li>
      <li>mutable record</li>
      <li>array</li>
    </ul>
  </li>
</ul>

<p>Indirect mutability - variable itself can’t change, but what it points to can.</p>
<ul>
  <li>items are immutable unless their mutability is explicitly declared</li>
</ul>

<h3 id="mutable-references">Mutable References</h3>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">4</span><span class="p">;;</span>    <span class="c">(* always have to declare initial value when creating a reference *)</span>
</code></pre></div></div>

<p>Meaning of the above: x forevermore (i.e. forever unless shadowed) refers to a fixed cell.  The <strong>contents</strong> of that fixed call can change, but not x.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span> <span class="c">(* a type error ! *)</span>
<span class="o">!</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span> <span class="c">(* need !x to get out the value; parallels *x in C *)</span>
<span class="n">x</span> <span class="o">:=</span> <span class="mi">6</span><span class="p">;;</span> <span class="c">(* assignment - x must be a ref cell.  Returns () - goal is side effect *)</span>
<span class="o">!</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span> <span class="c">(* Mutation happened to contents of cell x *)</span>
</code></pre></div></div>

<ul>
  <li><code>'a ref</code> is really implemented by a mutable record with one field, contents:</li>
  <li><code>'a ref</code> abbreviates the type <code>{ mutable contents: 'a }</code></li>
  <li>The keyword mutable on a record field means it can mutate</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{</span> <span class="n">contents</span> <span class="o">=</span> <span class="mi">4</span><span class="p">};;</span> <span class="c">(* identical to x's definition above *)</span>
<span class="n">x</span> <span class="o">:=</span> <span class="mi">6</span><span class="p">;;</span>
<span class="n">x</span><span class="o">.</span><span class="n">contents</span> <span class="o">&lt;-</span> <span class="mi">7</span><span class="p">;;</span>  <span class="c">(* same effect as previous line: backarrow updates a field *)</span>

<span class="o">!</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span>
<span class="n">x</span><span class="o">.</span><span class="n">contents</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span> <span class="c">(* same effect as previous line *)</span>
</code></pre></div></div>

<p>Declaring your own mutable record: put <code>mutable</code> qualifier on field</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">mutable_point</span> <span class="o">=</span> <span class="p">{</span> <span class="k">mutable</span> <span class="n">x</span><span class="o">:</span> <span class="kt">float</span><span class="p">;</span> <span class="k">mutable</span> <span class="n">y</span><span class="o">:</span> <span class="kt">float</span> <span class="p">};;</span>
<span class="k">let</span> <span class="n">translate</span> <span class="n">p</span> <span class="n">dx</span> <span class="n">dy</span> <span class="o">=</span>
                <span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">+.</span> <span class="n">dx</span><span class="p">);</span> <span class="c">(* observe use of ";" here to sequence effects *)</span>
                <span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="o">+.</span> <span class="n">dy</span><span class="p">)</span>  <span class="c">(* ";" is useless without side effects (think about it) *)</span>
                                <span class="p">;;</span>
<span class="k">let</span> <span class="n">mypoint</span> <span class="o">=</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="p">};;</span>
<span class="n">translate</span> <span class="n">mypoint</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="p">;;</span>
<span class="n">mypoint</span><span class="p">;;</span>
</code></pre></div></div>

<p>Observe: mypoint is immutable at the top level but it has two spots in it where we can mutate</p>

<p>Tree with mutable nodes</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">mtree</span> <span class="o">=</span> <span class="nc">MLeaf</span> <span class="o">|</span> <span class="nc">MNode</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">mtree</span> <span class="n">ref</span> <span class="o">*</span> <span class="n">mtree</span> <span class="n">ref</span><span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>ONLY ref typed variables or mutable records may be assigned to</li>
  <li>The notion of immutable variables is one of the great strengths of OCaml.</li>
  <li>Note: <code>let</code> doesn’t turn into a mutation operator with <code>ref</code>:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">4</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">f</span> <span class="bp">()</span> <span class="o">=</span> <span class="o">!</span><span class="n">x</span><span class="p">;;</span> <span class="c">(* This is syntax for a 0-argument function in OCaml - it only takes () as argument *)</span>

<span class="n">x</span> <span class="o">:=</span> <span class="mi">234</span><span class="p">;;</span>
<span class="n">f</span><span class="bp">()</span><span class="p">;;</span>

<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">6</span><span class="p">;;</span> <span class="c">(* shadowing previous x definition, NOT an assignment to x !! *)</span>
<span class="n">f</span> <span class="bp">()</span><span class="p">;;</span>
</code></pre></div></div>

<p>Yes, OCaml has our old friend <code>;</code> and with it we can write an imperative <code>while</code> loop</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">1</span> <span class="k">in</span>
    <span class="k">while</span> <span class="o">!</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="k">do</span>
      <span class="n">print_int</span> <span class="o">!</span><span class="n">x</span><span class="p">;</span>
      <span class="n">print_string</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
      <span class="n">x</span> <span class="o">:=</span> <span class="o">!</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">done</span><span class="p">;;</span>
</code></pre></div></div>

<p>Fact: while loops are useless without mutation: either never loop or infinitely loop</p>

<p>Why is immutability good?</p>
<ul>
  <li>programmer can depend on the fact that something will never be mutated when writing code: permanent like mathematical definitions</li>
  <li>OCaml lets you express mutation if it is critically needed</li>
</ul>

<h3 id="arrays">Arrays</h3>
<ul>
  <li>Fairly self-explanatory, we will just flash over this in lecture</li>
  <li>Have to be initialized before using
    <ul>
      <li>in general there is no such thing as “uninitialized”/”null” in OCaml</li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">arrhi</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="mi">100</span> <span class="s2">""</span><span class="p">;;</span> <span class="c">(* size and initial value are the params here *)</span>
<span class="k">let</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="o">|</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">2</span> <span class="o">|</span><span class="p">];;</span> <span class="c">(* another way to make an array *)</span>
<span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">);;</span> <span class="c">(* access (unfortunately already used [] for lists in the syntax) *)</span>
<span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="mi">55</span><span class="p">;;</span> <span class="c">(* update *)</span>
<span class="n">arr</span><span class="p">;;</span>
</code></pre></div></div>

<h3 id="exceptions">Exceptions</h3>
<ul>
  <li>OCaml has a standard (e.g. Java-like) notion of exception</li>
  <li>Unfortunately types do not include what exceptions a function will raise - an outdated aspect of OCaml.</li>
  <li>Modern OCaml coding style is to <em>minimize</em> the use of exceptions
    <ul>
      <li>Causes action-at-a-distance, hard to debug</li>
      <li>Instead follow the old C approach of bubbling up error codes</li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">exception</span> <span class="nc">Foo</span><span class="p">;;</span>  <span class="c">(* This is a new form of top-level declaration, along with let, type *)</span>

<span class="k">let</span> <span class="n">f</span> <span class="bp">()</span> <span class="o">=</span> <span class="k">raise</span> <span class="nc">Foo</span><span class="p">;;</span> <span class="c">(* note no need to "raises Foo" in the type as in Java *)</span>
<span class="n">f</span> <span class="bp">()</span><span class="p">;;</span>

<span class="k">exception</span> <span class="nc">Bar</span><span class="p">;;</span>

<span class="k">let</span> <span class="n">g</span> <span class="n">_</span> <span class="o">=</span> <span class="c">(* aside: "_" notates a variable that can never be accessed *)</span>
  <span class="p">(</span><span class="k">try</span> <span class="n">f</span> <span class="bp">()</span>
   <span class="k">with</span>  
     <span class="nc">Foo</span> <span class="o">-&gt;</span>  <span class="mi">5</span> <span class="o">|</span> <span class="nc">Bar</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;;</span> <span class="c">(* Use power of pattern matching in handlers *)</span>
<span class="n">g</span> <span class="bp">()</span><span class="p">;;</span>
</code></pre></div></div>

<p>Exceptions with a parameter - syntax is like a variant</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">exception</span> <span class="nc">Goo</span> <span class="k">of</span> <span class="kt">string</span><span class="p">;;</span>

<span class="k">let</span> <span class="n">f</span> <span class="n">_</span> <span class="o">=</span> <span class="k">raise</span> <span class="p">(</span><span class="nc">Goo</span> <span class="s2">"keyboard on fire"</span><span class="p">);;</span>
<span class="n">f</span> <span class="bp">()</span><span class="p">;;</span>

<span class="k">let</span> <span class="n">g</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">try</span>
    <span class="n">f</span> <span class="bp">()</span>
  <span class="k">with</span>
      <span class="nc">Foo</span> <span class="o">-&gt;</span> <span class="bp">()</span>
        <span class="o">|</span> <span class="nc">Goo</span> <span class="n">s</span> <span class="o">-&gt;</span>
      <span class="p">(</span><span class="n">print_string</span><span class="p">(</span><span class="s2">"exception raised: "</span><span class="p">);</span>
       <span class="n">print_string</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="n">print_string</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">))</span>
<span class="p">;;</span>
<span class="n">g</span> <span class="bp">()</span><span class="p">;;</span>
</code></pre></div></div>

<p>There are a few built-in exceptions we mentioned previously:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">failwith</span> <span class="s2">"Oops"</span><span class="p">;;</span> <span class="c">(* Generic code failure - exception is named Failure *)</span>
<span class="n">invalid_arg</span> <span class="s2">"This function works on non-empty lists only"</span><span class="p">;;</span> <span class="c">(* Invalid_argument exception *)</span>
</code></pre></div></div>
<h3 id="ocaml-lecture-v-modules">OCaml Lecture V: Modules</h3>

<p>Modules in programming languages</p>
<ul>
  <li>a module is a larger level of program abstraction: functional units or library.</li>
  <li>e.g. Java package, Python module, C directory, etc</li>
  <li>needed for all but very small programs: imagine a file system without directories/folders as analogy to a PL without modules - YUCK!</li>
</ul>

<p>Some principles of modules:</p>
<ul>
  <li>Modules have names they can be referenced by.</li>
  <li>A module contains code declarations: functions, classes,  types, etc.</li>
  <li>They often are file-based: one module per file, module name is file name</li>
  <li>The module has a way to
    <ul>
      <li>import things (e.g. other modules) from the outside and</li>
      <li>export some (or all) things it has declared for outsiders to use;</li>
      <li>it may <strong>hide</strong> some things for internal use only<br />
 – hiding is a key feature, don’t overwhelm users</li>
      <li>Separate name spaces, so e.g. the Window’s reset() won’t clash<br />
with a File’s reset(): use <code>Window.reset()</code> and <code>File.reset()</code></li>
      <li>Nested name spaces for ever larger software: <code>Window.Init.reset()</code></li>
      <li>Often modules can be compiled separately (for compiled languages)</li>
    </ul>
  </li>
</ul>

<p>Most modern languages have a module system solving most of these problems.</p>

<h3 id="modules-in-ocaml">Modules in OCaml</h3>

<ul>
  <li>We already saw OCaml modules in action earlier,</li>
  <li>Example: <code>List.map</code>, this is an invocation of the map function in the built-in <code>List</code> module.</li>
  <li>Now, lets study how we can build our own OCaml modules</li>
  <li>We focus here on building modules via files, but there are other methods we skip</li>
</ul>

<h4 id="making-a-module">Making a module</h4>

<ul>
  <li>Assignment 1 requires you to fill out a file <code>assignment.ml</code></li>
  <li>This is in fact creating a <em>module</em> <code>Assignment</code> (notice the first letter (only) is capped)</li>
  <li><code>dune utop</code> will load your module in the top loop</li>
  <li>You then need to write <code>Assignment.factorial 5;;</code> etc to access the functions in the module’s namespace</li>
  <li>Or, use <code>open Assignment;;</code> to make all the functions in the module available at the top level.</li>
</ul>

<h3 id="separate-compilation-with-ocaml">Separate Compilation with OCaml</h3>

<ul>
  <li>File-based modules are also compiled separately, there is no top loop needed.</li>
  <li>This is the traditional <code>javac</code>/<code>cc</code>/etc style of coding</li>
  <li>The underlying compiler for OCaml is <code>ocamlc</code>, but in this course we will give you build files
    <ul>
      <li>just use <code>dune build</code> to invoke the compiler on all the files</li>
    </ul>
  </li>
</ul>

<h3 id="an-example-of-a-separately-compiled-ocaml-program">An example of a separately-compiled OCaml program</h3>

<ul>
  <li>See <a href="http://pl.cs.jhu.edu/pl/ocaml/code/set-example.zip">set-example.zip</a> for the example we cover in lecture.</li>
  <li>We will follow <a href="http://pl.cs.jhu.edu/pl/ocaml/code/sep_compile/readme.txt">readme.txt</a> in particular.</li>
  <li>See the ocaml manual Chapter 8 for the full documentation</li>
  <li>For this example we can use <code>dune utop</code> to load it into the <code>utop</code></li>
</ul>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dune utop
</code></pre></div></div>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">FSet</span><span class="p">.</span><span class="n">emptyset</span><span class="p">;;</span>
</code></pre></div></div>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: <a href="http://templated.co">TEMPLATED</a> Images: <a href="http://unsplash.com">Unsplash</a> (<a href="http://unsplash.com/cc0">CC0</a>)
				</div>			


   </body>
</html>
