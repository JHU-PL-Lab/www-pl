<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>OCaml Tutorial</title>

  
    
    <link href="Fishbacher-OCaml-Tutorial_files/hans.css" rel="stylesheet" type="text/css"></head><body>


    <h1>OCaml Tutorial</h1>

<p>
</p><ul>
<li><a href="http://www.soton.ac.uk/%7Efangohr/nsim/tutorial/ocaml/lecture1.html">Lecture 1: Objective Caml</a></li>
<li><a href="http://www.soton.ac.uk/%7Efangohr/nsim/tutorial/ocaml/lecture2.html">Lecture 2: Functions</a></li>
<li><a href="http://www.soton.ac.uk/%7Efangohr/nsim/tutorial/ocaml/lecture3.html">Lecture 3: Parametric Polymorphism and Structural Induction</a></li>
<li><a href="http://www.soton.ac.uk/%7Efangohr/nsim/tutorial/ocaml/lecture4.html">Lecture 4: Imperative Features (and cleanup)</a></li>
<li><a href="http://www.soton.ac.uk/%7Efangohr/nsim/tutorial/ocaml/lecture5.html">Lecture 5: Modules and the C interface</a></li>
</ul>
<p></p>

<br><hr><br>
    <h1>Objective Caml</h1>

<h2>What is Objective Caml?</h2>

<p>There are many valid answers to this question. To most programmers,
the most important point is: what does it have to offer? So, if we
look at it in this way, it is:
</p>

<p>
</p><ul>
<li>A modern programming language that can be compiled to machine code
(which usually is about as fast as GCC-compiled C code).
</li>

<li>At the same time, it is possible to develop and run code
interactively, either in scripts or from a "command prompt" 
(conceptually very similar to Python).
</li>

<li>A "safe" language in the sense that program bugs can not cause
memory corruption (as with C and C++).
</li>

<li>A language that (presumably) is comparatively easy to master.  (At
least, a sufficiently large subset to obtain elegant solutions for
most real world problems. - If this were otherwise, there would be no
point in doing this crash course!)
</li>

</ul>
<p></p>

<h3>Is it "object oriented"?</h3>

<p>Some people like to stick labels onto programming languages, that
is, classify them as, for example, "imperative" or "object-oriented"
or "logic-based". Actually, this is somewhat misleading, as these
terms rather describe different strategies to approach a problem, and
the structure of real-world problems is often such that they can be
decomposed into sub-problems that may suggest very different
strategies. So, even though C is not considered to be an
object-oriented language, there are many places in a complex piece of
software such as the Linux kernel that are designed in an
object-oriented way, such as the virtual file system interface
specification. Likewise, C++ is not usually considered to be a
"functional" language, but there are libraries, such as the <a href="http://www-eleves-isia.cma.fr/documentation/BoostDoc/boost_1_29_0/libs/lambda/doc/index.html#introduction">Boost
Lambda Library</a> which greatly simplify using functional techniques
with C++. On the other hand, one of the most flexible object systems
around is part of the functional language (Common) LISP: <a href="http://www.aiai.ed.ac.uk/%7Ejeff/clos-guide.html">CLOS</a>.
</p>

<p>
So, this classification issue is mostly about what approaches and
techniques a given language emphasizes.  Seen that way, OCaml may be
regarded as belonging to one family of functional languages, the
so-called "statically typed strict functional languages", while also
featuring the usual basic object-oriented concepts: there are
syntactic structures that deal with objects, classes, inheritance,
methods, and so on.
</p>

<p>In what follows, we will not put too much emphasis on the
object-oriented side of OCaml. The major reason is that this is pretty
much standard, so everyone having learned OO before should find it
easy to adopt the particular OCaml syntax for method invocation and
such. Those who did not have any previous exposure to object-oriented
programming on the other hand cannot be expected to master it in a few
lessons, so there would be little point in trying to teach
that. Actually, if OCaml were just another object oriented language
which we fancy for the sole reason that it gives us funky blue objects
rather than the boring green objects from C++, we never would have
chosen it in the first place! There is more to this particular
language, and this is precisely the reason why we consider it a good
choice for our project. So, let us rather spend our time talking about
some powerful techniques that are not widely discussed with other,
more mainstream languages, but very natural with OCaml.
</p>

<h2>A brief history of OCaml</h2>

<p>For many of today's programming languages, there was a solitary
large problem that helped bringing them into existence by pointing at
some important ideas: C was born because a sufficiently abstract
language was needed to port an operating system between different
machine architectures (cf. <a href="http://cm.bell-labs.com/cm/cs/who/dmr/chist.html">The
Development of the C Language</a>). Perl was written because Larry
Wall had to struggle with scripting tasks that became too complex to
be done with the prehistoric "Unix swiss army knife" <tt>awk</tt>. The
same is true for the ancestor of OCaml, which is the ML language, and
it is presumably quite useful to know a bit about this history to
understand how some of the fundamental concepts that may seem 
somewhat strange during first contact with ML were "discovered".
</p>

<h3>On Theorems and Proofs</h3>

<p>Humans do formal reasoning, humans make mistakes, hence humans make
mistakes at formal reasoning. Still, with formal reasoning being
formal, it should be possible to have some kind of machine that checks
a properly written down formal proof for its correctness. Let us call
a program that can do this a "proof checker". Now, using a proof
checker certainly is a lot of work, as first of all, a proof has to be
brought into a machine-readable form, so we have to be far more
elaborate than in a mathematical textbook, where we may just say
"proof by induction" when the reader will be able to work out the
details of his own. As many proofs are repetitive in the sense that
there are re-occurring patterns of reasoning, it would be nice to have
something more like an "automatic proof assistant", which allows
construction of parts of a proof by just specifying some general
method and works out the details of its own. Of course, even more
convenient would be a theorem proving program, but combinatorical
explosion perhaps prevents this fro working effectively. There is no
substitute for human intuition in proving theorems.
</p>

<p>When working with theorems and partial proofs, we need some kind of
"language" to assemble larger proof strategies from smaller ones, and
talk about terms and theorems. This language should be both very
flexible and very abstract, as we will have to express very abstract
ideas in it. A fundamental point which is perfectly natural for
mathematicians is that a theorem is something very holy: having a
theorem means that I can handle some situations by applying that
theorem instead of having to go through a whole sequence of maybe even
prohibitively complicated reasoning. Therefore, it is very natural to
try to lift this concept of a theorem directly onto the machine. So,
the machine should have some knowledge that any term that has theorem
status is true, without having to go through all the atomic steps of a
proof that demonstrate this. 
</p>

<p>Note carefully that a simple-minded object oriented approach cannot
do this: the object oriented point of view presumably should be that a
theorem is an entity (hence, object) for which it makes sense to ask
whether it is true - which therefore should have an
"<code>am_I_true</code>" method. According to the object-oriented
philosophy, I could always subclass a "<code>theorem</code>" with a
class that provides a specialized "<code>am_I_true</code>" method, and
hence have objects which are theorems (trough "is-a" inheritance), but
not necessarily true - an unsatisfactory state of affairs (vulgo:
complete rubbish).
</p>

<p>Hence, we need something else. The main objects of our studies are
theorems, terms, and proof strategies. Evidently, these will
furthermore also involve natural numbers, boolean values, and maybe
some other fundamental data types, as well as tuples, sets, and
similar "containers". Let us consider a simple example and try to
interpret the monotonicity of addition as a proof strategy. It says
that, given two theorems of the form "<tt>a&lt;b</tt>" and
"<tt>c&lt;d</tt>", we have a new theorem "<tt>a+b &lt; c+d</tt>", so
<em>this is a function mapping a pair of theorems to a new
theorem</em>. Now, if we attach types to our values, the system can
watch that this function cannot be applied to get a theorem from just
a pair of terms: we have to feed it with theorems to get a new
theorem.
</p>

<p>
<table border="1" width="80%">
<tbody><tr><th colspan="3">Simple proof strategies, their types, and examples</th></tr>
<tr>
<td>Monotonicity of addition</td>
<td><code> (theorem, theorem) -&gt; theorem</code></td>
<td><code>(a&lt;b , c&lt;d) -&gt; a+c &lt; b+d</code></td>
</tr>
<tr>
<td>Proof by induction</td>
<td>
<table>
<tbody><tr><td><code>(theorem,</code></td></tr>
<tr><td><code>&nbsp;&nbsp;theorem)</code></td></tr>
<tr><td><code>&nbsp;</code></td></tr>
<tr><td><code>-&gt; theorem</code></td></tr>
</tbody></table></td>
<td><table><tbody><tr><td><code>(Sum(n=0..0;n)=0,</code></td></tr><tr><td><code>&nbsp;For_all(k): (Sum(n=0..k;n) = k(k+1)/2</code></td></tr><tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp; =&gt; Sum(n=0..k+1;n) = (k+1)((k+1)+1)/2))</code></td></tr><tr><td><code> -&gt; For_all(k): Sum(n=0..k;n) = k(k+1)/2</code></td></tr></tbody></table>
</td>
</tr>
<tr>
<td>A is A</td>
<td><code> term -&gt; theorem</code></td>
<td><code>a -&gt; a=a</code></td>
</tr>
</tbody></table>
</p>

<p>
So, if we take care that the only way to obtain a theorem is via a
valid proof strategy, or from axioms, then we just know by the fact
that some value has the type theorem that it has to represent
something true. It may happen that a function claiming to produce a
theorem fails to do so, because it does not terminate. But if we get
something, and it's a theorem, it must be true.
</p>

<p>This is the essential idea behind Milner's LCF - see the paper 
<a href="http://portal.acm.org/citation.cfm?id=512760.512773&amp;dl=portal&amp;dl=ACM&amp;type=series&amp;idx=512760&amp;part=Proceedings&amp;WantType=Proceedings&amp;title=Annual%20Symposium%20on%20Principles%20of%20Programming%20Languages">A Metalanguage for interactive proof in LCF</a> for further reading.</p>

<p>Actually, if one looks at one of the real ML-based proof
assistants, all this is a somewhat gross over-simplification. Things
are actually quite a bit more involved, but the broad idea is
right. In a certain sense, one could say that the type system fulfils
the old philosopher's dream of creating a language in which it is not
possible to lie. For those who want to know more about proof
assistants, it may be interesting to have a look at <a href="http://www.cl.cam.ac.uk/users/jrh/hol-light/manual-1.1.pdf">The
HOL Light manual</a> (which, by the way, also contains a brief
introduction to CAML, which is a very very close relative of OCaml).
</p>

<p>Types are very important with OCaml, and you will experience this
of your own very soon. But other languages do have types as well, so
in which way does this differ from the type systems of C, or Python? 
Giving a good answer would take quite some time, so I will instead
just provide some food for thought: First, how would one define
something like tuples in C? How could one make sure that a tuple of one
kind then cannot be passed into a function expecting a tuple of a
different kind? And when does the type checking happen? Is it possible
to pass a value of the wrong type into a function which will
eventually only find out about this much later, during a lengthy
computation?
</p>

<p>Now, this may all sound very interesting, but raises the question:
why does it matter to us in engineering, with primarily numerical
applications in mind? I will elaborate on this in more detail, but for
now, the brief answer is: mathematical proof strategies are among the
most abstract things one can imagine. During their work n formal proof
systems, people found out that the "Meta Language" with which they
manipulated the "object language" entities - theorems - actually is a
very convenient and useful tool to handle far more real world problems
than they were interested in initially. Actually, for a system that
makes it easy and convenient to work with entities even as abstract as
mathematical theorems, it should be a piece of cake to deal with the
algorithmically nontrivial parts of many problems. In particular, it
should especially make it easy to write software in a much more
abstract and generic way: instead of solving just one specific problem
- say, generating a stiffness matrix for the Laplacian on a mesh with
first order elements, it will become feasible to attack the much more
general problem of discretizing any first or second order differential
operator on a mesh of any dimension, with any element order.
</p>

<p>Of course, one may say that from the machine perspective, there is
nothing that can be done in OCaml which cannot be done in C. After
all, one uses just a C compiler to build the OCaml compiler from its
sources, so one may regard OCaml as being nothing else but a
collection of conventions that allow one to use a different notation
for programs. So, technically speaking, it is not impossible to write
highly abstract software in C, or even FORTRAN. However, programming
is a human activity, so the only relevant question is: what can be
achieved with reasonable human effort? So, if one insists that
everything can be done in C, that's certainly true, but by the same
token, one could claim that there is no need for theorems in
mathematics, as one may always analyze any given mathematical problem
by just applying a long sequence of axioms, definitions, and
deductions.
</p>

<p>But back to OCaml history: ML was developed in Edinburgh, evolved
over the years, and got more people interested in that approach,
especially concerning applications to the field of reasoning about
programs, like compiler writers do. Hence, ML was adopted by the
french <a href="http://www.inria.fr/">INRIA</a> institute, who
actually wanted to use it for real applications, and so then evolved
it further into the dialect OCaml, which is still developed and
maintained by INRIA today. By now there are a few major noteworthy
applications written in OCaml that nicely demonstrate its potential in
the battlefield, among them the <a href="http://pauillac.inria.fr/%7Emaranget/hevea/">HeVeA</a> LaTeX/HTML
translator, the <a href="http://freshmeat.net/projects/unison/">unison
file synchronizer</a>, the <a href="http://www.fftw.org/faq/section2.html#languages">FFTW</a>
Fourier Transform library, and some more. For further examples, see
e.g. <a href="http://caml.inria.fr/about/successes.en.html">INRIA's
applications page</a>.
</p>

<p>Let us conclude this excursion with a reference to <a href="http://delysid.org/programming.html">http://delysid.org/programming.html</a>,
which contains a very good brief history of a number of interesting
programming languages, including the ML family.
</p>

<h2>The Language</h2>

<p>As alluded to earlier, the type system of OCaml will be quite
interesting, as it is very different from the type system of other
languages. For now, we will limit ourselves to the discussion of the
"Core Language", which is, up to syntactic nuances, the part of the
language that is shared between all ML dialects, such as OCaml and
SML.
</p>

<h3>Fundamental data types</h3>

<p>By "fundamental" data types, we mean built-in data types known to
the system right from the beginning. However, it is easy to extend
OCaml with new data types that behave in any relevant aspect like
these fundamental ones. Every piece of data will have some memory
representation, and we will consider a data type as being
"fundamental", or rather "atomic", if it is not possible to change the
value of an entity through any assignment operation. This may sound
very strange at first, especially from the perspective of a C
programmer where something like this effectively does not exist, but
will become relevant later when we talk in more detail about assignments.
</p>

<p>
<table border="1"><tbody><tr><th colspan="4">Fundamental data types of OCaml</th></tr>
<tr><th>Type</th><th>Models</th><th>Example</th><th>Notes</th></tr>
<tr><td><code>int</code></td><td>Machine integers</td><td><code>17</code></td><td>Range: -2^30..2^30-1 (on 32 bit machines)</td></tr>
<tr><td><code>bool</code></td><td>Boolean values</td><td><code>true</code></td><td></td></tr>
<tr><td><code>float</code></td><td>IEEE 754 Double-precision floatingpoint values</td><td><code>-2.38e9</code></td><td></td></tr>
<tr><td><code>char</code></td><td>8-bit Characters</td><td><code>'a'</code></td><td></td></tr>
<tr><td><code>unit</code></td><td>Type with just a single value</td><td><code>()</code></td><td>May also be regarded as the unique 0-tuple.</td></tr>
</tbody></table>
</p>

<p>Even with those few types, there would be a lot to say about
special quirks of OCaml. For example, while <code>-1</code> is a valid
literal for an integer number, <code>+1</code> is not. Quite in
general, we will not go into such language details in this course,
whose main objective is to present the structure of the language, and
show how one should approach and analyze the real problems, not the
artificial ones introduced by the language. Now, take your C++ bible
and check which exercise questions deal with real world issues and
which deal with mundane quirks of the language.
</p>

<h3>Some "containers"</h3>

<p>From simple, atomic data, we build more complex values by sticking
them into containers. For now, we will limit ourselves to just four:
strings, tuples, arrays, and lists. There are of course more, such as
records (quite similar to C structures), and some very ML-specific
ones, which we will discuss later on in this course. For now, we want
to have something that helps us to get going with the language.
</p>

<h4>Strings</h4>

<p>Strings behave like fixed-size vectors of 8-bit characters. One of
the somewhat unfortunate limitations of OCaml is that on 32-bit
systems, the maximal length of a string is slightly less than 16 MB,
but in practice there usually are ways to work around this if it
becomes an issue. Nevertheless, it should not be like that.  The
notation is as usual, with <code>"hello"</code> being a five-character
string. Escape sequences like <code>\n</code>, <code>\t</code>,
<code>\xf2</code> and such work as expected, but instead of octal
triplets, OCaml uses decimal triplets, so <code>\n</code> is not
<code>\012</code> but <code>\010</code>. The name of the type is
<code>string</code>.
</p>

<h4>Tuples</h4>

<p>Tuples are fixed-length ordered sequences of values, which may be
of different type. It is not possible to assign to a tuple, but we
will have to say more about the fine points of this statement
later. For now, it is better if we do not think too much at all about
modifying values. The notation is like <code>(17,true,"hello")</code>,
that is, a tuple is a comma-separated sequence of values enclosed in
round parentheses. Some language lawyers may say that in OCaml, these
parentheses are optional in many situations, but as they are mandatory
in any other relative of OCaml, it will simplify communication with
other programmers to always place them. The type of this particular
tuple would be <code>int * bool * string</code>, and other tuple types
are constructed likewise. The type of the tuple
<code>(1,(true,2.3),'x')</code> would be <code>int * (bool * float) *
char</code>. The unit value <code>()</code> may be regarded as being
the empty tuple, and one-tuples do not exist: <code>(x)</code> is just
the same as <code>x</code>.
</p>

<p>How can one extract data from the various slots of a tuple? Here,
OCaml uses an approach that may appear somewhat strange at first, but
actually turns out to be quite convenient in many situations:
structural matching. We will just give an example (which, actually, no
advanced OCaml programmer would write that way) to demonstrate how
this looks like and define a function that maps a triple to its middle
component:
</p>

<p>
<table border="1">
<tbody><tr><th>Structural Matching - mapping a triple to its middle component</th></tr>
<tr><td>
<pre><code>
let tuple_2_of_3 = fun (a,b,c) -&gt; b;;

</code></pre>
</td></tr>
</tbody></table>
</p>

<p>For now, the reader should just try to generalize this example and
define similar accessor functions whenever he needs one. We will later
on learn how to write this in a more elegant way.
</p>

<h4>Arrays</h4>

<p>Arrays behave like fixed-length vectors of values of homogeneous
type. It is possible to assign to array entries, and the time for
array lookup and assignment will not depend on the index (up to
caching effects, of course). On 32 bit systems, the memory
representation of an OCaml array cannot be longer than about 16 MB,
and as every array entry occupies either four bytes or eight (only for
float arrays), such machines have an array length limitation of about
4 million entries (2 million for float arrays). This certainly is not
very well suited for large numerical data, but there is a specialized
kind of arrays for that. These generic arrays can hold just about
anything, such as tuples which are pairs of integers and strings. The
notation is like <code>[|1;2;5|]</code>, and array elements can be
accessed with the special syntax <code>a.(5)</code>. However, lisp
hackers may believe to have good reasons to use a function here and
prefer to write <code>Array.get a 5</code>. Note that array index
counting starts at 0, as in C (which, by the way, is the only
reasonable convention, since array indices starting at 1 would require
crazy correction factors when one maps indices from two-dimensional
arrays to linear indices). The type of the array
<code>[|1;2;3|]</code> is <code>int array</code>, the type of the
array <code>[|(1,true);(2,false)|]</code> is <code>(int * bool)
array</code>.
</p>

<h4>Lists</h4>

<p>OCaml lists are variable-length singly linked lists of homogeneous
values. While access to the <code>n</code>-th element requires the
more time the larger <code>n</code>, as pointer sequences have to be
chased, it is very easy (small constant time effort) to compute a new
list from a given list by appending or removing an entry at the list's
head. Note that an array would have to be copied for this. It is
possible (and not infrequently seen) that multiple lists share a
common tail. Just like tuples, lists are non-modifiable, and one
normally uses funny syntactic constructs to get data from a list. The
notation is like <code>[1;2;3]</code>, and this particular list would
have the type <code>int list</code>.
</p>

<p>For the time being, we will use the comparison <code>x = []</code>
when we have to find out whether a list is empty, and the functions
<code>List.hd</code> and <code>List.tl</code> to get the head element,
respective tail, of a list. When <code>x</code> is a list, and we want
another list that is just <code>x</code>, extended with a new head
<code>h</code>, we just write <code>h::x</code> for this new
list. Note that computing such a new and extended list does not change
the list <code>x</code>!
</p>

<h3>Running the interpreter</h3>

<p>OCaml provides both a compiler and an interpreter. For now, we will
limit ourselves to playing around with the interpreter at its
interactive command prompt. But first of all, we will build ourselves
a custom interpreter that already comes with all the useful libraries
which we are going to use pre-loaded. So, we first create an
<code>ocaml-tutorial</code> directory and make that special extended
interpreter in there:
</p>

<p>
<table border="1">
<tbody><tr><th>Setting up the scene</th></tr>
<tr><td>
<pre><code>
~$ mkdir ocaml-tutorial
~$ cd ocaml-tutorial/
~/ocaml-tutorial$ ocamlmktop -o ext-ocaml unix.cma nums.cma str.cma graphics.cma
~/ocaml-tutorial$ ls -la
total 1120
drwxr-xr-x   2 tf tf    4096 2005-12-08 15:25 .
drwxr-xr-x  20 tf tf    4096 2005-12-08 15:24 ..
-rwxr-xr-x   1 tf tf 1134018 2005-12-08 15:25 ext-ocaml
~/ocaml-tutorial$ ./ext-ocaml
        Objective Caml version 3.08.3

# ^D
~/ocaml-tutorial$ 
</code></pre>
</td></tr>
</tbody></table>
</p>

<p>Like any nicely behaving Unix program with a toplevel, sending an
End-Of-File (Control-D) at the prompt will quit the interpreter. A
running computation can be interrupted with Control-C. Some people
may find it useful to start our OCaml interpreter from within an
(x)emacs shell by entering <code>M-x shell</code> in (x)emacs. The
advantage of this is that one can use all of emacs' buffer editing
facilities on the history transcript of an interactive session. (Note:
if a "<code>ls</code>" in an emacs shell produces trash, try telling
the shell to "<code>unalias ls</code>".) There is a normally even
better way to use Emacs to interoperate with OCaml, the so-called
"Caml mode". We will look into this later.
</p>

<p>Now, at the top level, OCaml just behaves like a "pocket calculator
on steroids" that not only knows about numbers, but just as well about
many other kinds of data. One should know:
</p>

<p>
</p><ul>
<li><p>There are no "commands", only expressions.</p></li>
<li><p>Every expression has a value.</p></li>
<li><p>Expressions that are to be evaluated by the toplevel must be terminated with "<code>;;</code>"</p></li>
<li><p>Definitions are made in the form <code>let this_variable = this_value</code>.
(Actually, a toplevel definition is something slightly different from an expression.)</p></li>
</ul>
<p></p>

<p>So, let us just give a few definitions and play with them:
</p>

<p>
<table border="1">
<tbody><tr><th>Playing with the interpreter</th></tr>
<tr><td>
<pre><code>
~/ocaml-tutorial$ ./ext-ocaml 
        Objective Caml version 3.08.3

# 2*3;;
- : int = 6

# 1+2+3+4+5+6+7+8+9+10;;
- : int = 55

# let lightspeed = 299792458.0;;
val lightspeed : float = 299792458.

# let light_time_to_sun = 149.6e9 /. lightspeed;;
val light_time_to_sun : float = 499.011886416435459

# light_time_to_sun /. 60.0;;
- : float = 8.31686477360725718

# let pi = 3.1415926535897932384626;;
val pi : float = 3.14159265358979312

# let sphere_surface = fun x -&gt; x *. x *. pi;;
val sphere_surface : float -&gt; float = &lt;fun&gt;

# sphere_surface(10.0);;
- : float = 314.159265358979326

# let my_abs_float = fun x -&gt; if x &lt; 0.0 then -. x else x;;
val my_abs_float : float -&gt; float = &lt;fun&gt;

# my_abs_float(-2.3);;
- : float = 2.3

# let tuple_3_of_4 = fun (x1,x2,x3,x4) -&gt; x3;;
val tuple_3_of_4 : 'a * 'b * 'c * 'd -&gt; 'c = &lt;fun&gt;

# let some_quadruple = ("foo",("bar",27),[1;2;3],false);;
val some_quadruple : string * (string * int) * int list * bool =
  ("foo", ("bar", 27), [1; 2; 3], false)

# tuple_3_of_4(some_quadruple);;
- : int list = [1; 2; 3]

#
~/ocaml-tutorial$ 
</code></pre>
</td></tr>
</tbody></table>
</p>

<p>Paying close attention to those examples, we see a few noteworthy
things: first of all, there are different arithmetic infix operators
for integer and floatingpoint operations: integer addition is
"<code>+</code>" and floatingpoint addition is
"<code>+.</code>". Likewise for the other operators,
i.e. "<code>/</code>" vs. "<code>/.</code>" and "<code>*</code>"
vs. "<code>*.</code>". The same holds for unary minus, as we see in
the "... <code>then -. x</code> ..." piece. This may seem strange and
does require some getting used to, and indeed, other relatives of
OCaml use different approaches here. Why is this necessary? Actually,
this has to do with type inference: if we define a function such as
"<code>sphere_surface</code>", the system can "magically determine"
that this is mapping <code>float</code> to <code>float</code>. Why so? 
As the argument <code>x</code> is used in a floatingpoint
multiplication, it must be <code>float</code>, and likewise reasoning
tells us that the result also is float. Now, here one may say that
this could also be derived from the fact that a number explicitly
known to be a floatingpoint value appears in the product, namely
"<code>pi</code>". But then, there are situations like this one:
</p>

<p>
<table border="1">
<tbody><tr><th>Why different arithmetic operators for int and float?</th></tr>
<tr><td>
<pre><code>
# let square_int = fun x -&gt; x*x;;
val square_int : int -&gt; int = &lt;fun&gt;

# let square_float = fun x -&gt; x*.x;;
val square_float : float -&gt; float = &lt;fun&gt;

</code></pre>
</td></tr>
</tbody></table>
</p>

<p>Evidently, OCaml does not do any implicit conversion between
integers and floats, as C or C++ would do. This might be considered to
be a good thing, as implicit conversion, especially in conjunction
with the extreme richness of integer types in C, turned out to be one
frequent source of security bugs in many programs, see e.g. <a href="http://www.netfilter.org/security/2004-06-30-2.6-tcpoption.html">this
linux kernel bug</a>. However, this means that we will require
additional functions that convert between integers and floats. These
are <code>float_of_int</code> and <code>int_of_float</code>.
</p>

<p>If one looks very close, one may wonder why there does not seem to
be a "<code>&lt;.</code>" float comparison function then, as we use
the comparison "<code>x&lt;0</code>". This is a slightly hairy issue,
and turns out to be one of the dark corners of OCaml. For us, it is
sufficient to know that OCaml extends the natural order given on the
fundamental data types via lexicographical ordering to containers as
well.
</p>

<h2>A Beginner's Survival Guide To OCaml</h2>

<p>Newcomers to OCaml frequently are quite annoyed at first that the
system often complains about type mismatch in the code they
write. This is usually followed by a phase where one masters the type
system and is quite delighted to discover that actually, once the
program does typecheck, it will usually also just run as expected. The
next step then is that one sets out to test drive the system, to
discover its limits, to attack much more complex problems than one
would look into when armed only with C. This eventually leads to
getting more and more frequently into situations where the type system
no longer is that useful - as more and more of the problems occur not
at the language, but at the conceptual level. In the end, programmers
always spend a considerable amount of time in a confused state of mind,
but OCaml programmers usually tend to be confused about much more
sophisticated issues than C programmers. Now that we have seen some of
the background and original motivation behind ML, and already played
around a little bit with the interpreter, some members of the audience
may be keen to get something done with it. For this, we need a
collection of useful first facts that get us going.
</p>

<h3>Some language facts</h3>

<p>
</p><ul>
<li><p>In OCaml programs, indentation does not matter: the language is
format-free (unlike Python, Haskell, or even Perl, but like C, C++, or
Java)</p></li>

<li><p>Comments start with "<code>(*</code>" and end with "<code>*)</code>" and can be nested (which is a good thing!)</p></li>

<li><p>There are interpreter directives, toplevel definitions, and
expressions.</p>

<p>
</p><ul>
<li><p>All interpreter directives start with "<code>#</code>",
such as "<code>#use "my_script.ml"</code>", which loads and runs the
file "<code>my_script.ml</code>".</p></li>

<li>
<p>Toplevel definitions have the general form "<code>let
left_hand_side = expression;;</code>", where the left hand side is
either a variable name, or some structure containing multiple variable
names. (The double semicolon is not strictly speaking necessary, but
for the sake of consistency we will always put it.) The names
appearing at the left hand side are then defined such that they match
the expression at the right hand side, that is, 
"<code>let (p,(q,r),s) = (1,(2,(3,4)),5);;</code>" will define
<code>p</code> as <code>1</code>, <code>q</code> as <code>2</code>,
<code>r</code> as <code>(3,4)</code>, and <code>s</code> as <code>5</code>.
There are some further special forms, in particular for defining functions,
which we will see later.
</p>
</li>

<li><p>Every expression has a value. There are no "instructions". In
particular, the conditional "<code>if condition then val_true else
val_false</code>" has a value, which is very unlike the corresponding
<code>if/else</code> construct in C, but rather corresponds to C's
"<code>?:</code>" operator. The <code>condition</code> must be an
expression of boolean type, and both branches must be expressions of
the same type.</p>
</li>
</ul>
<p></p>
</li>

<li><p>OCaml source file names usually end in "<code>.ml</code>". Emacs
as well as the ocaml tools will recognize them by this ending.
</p></li>

<li><p>OCaml scripts are run by starting the interpreter with
"<code>ocaml file.ml</code>" (or some other custom-made variant of the
interpreter). Expressions from that file are then evaluated
sequentially one after another - there is no concept like the
<code>main()</code> function in C. However, as long as we only use
OCaml as a super-calculator, we do not have to worry about running
standalone scripts - and we can already do quite much from the command
prompt.</p></li>

<li><p>There is a short-hand notation for function definitions of the form
"<code>let square = fun x -&gt; x*x;;</code>": One can just as well write:
"<code>let square x = x*x;;</code>". 
</p></li>

<li><p>Subject to a few restrictions, definitions can be made
recursive (i.e. one can use the entity that is being defined on the
right hand side of the definition) by using "<code>let rec</code>" in
place of "<code>let</code>":</p>

<p>
<table border="1">
<tbody><tr><th>Recursive definitions</th></tr>
<tr><td>
<pre><code>
# let rec sum_integers_up_to = fun n -&gt; if n = 0 then 0 else n+sum_integers_up_to (n-1);;
val sum_integers_up_to : int -&gt; int = &lt;fun&gt;

# sum_integers_up_to 100;;
- : int = 5050

(* Equivalently... *)

# let rec sum_integers_up_to n = if n = 0 then 0 else n+sum_integers_up_to (n-1);;
val sum_integers_up_to : int -&gt; int = &lt;fun&gt;

(* And even (infinite circular list): *)

# let rec zeroes = 0::zeroes;;
val zeroes : int list =
  [0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
   0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
   0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
   ...]
</code></pre>
</td></tr>
</tbody></table>
</p>
</li>

<li><p>In function calls, the argument parentheses actually are
optional: There just are no "function call parentheses", so
"<code>f(x)</code>" can be re-written as "<code>f x</code>" just as
"<code>2+(3)</code>" can be re-written as "<code>2+3</code>". Usually,
function call parentheses are omitted. Note how this matches the
convention that there are no 1-tuples, as 1-tuples are just the values
inside the tuple.
</p>
</li>

<li><p>Negative numbers should be parenthesized: better always write
"<code>(-1)</code>" instead of "<code>-1</code>".</p>
</li>

<li>
<p>Function-local definitions (i.e. definitions that mimic
toplevel definitions, but only are valid and visible inside a given 
function) can be made with a variant of "<code>let</code>": 
"<code>let definition in body_expression</code>". Example:
</p>

<p>
<table border="1">
<tbody><tr><th>Local definitions</th></tr>
<tr><td>
<pre><code>let hypotenuse (a,b) =
  let square x = x *. x in
  sqrt(square a +. square b);;		 
</code></pre>
</td></tr>
</tbody></table>
</p>

<p>Local definitions behave like global definitions, but are only
visible in the <code>body_expression</code>. In particular, they also
can be recursive.
</p>

</li>
</ul>
<p></p>

<h3>Some useful functions</h3>

<p>This table of selected pre-defined functions should be useful to
get a first impression of what's there and to allow one to play with
the system. Usual guesses about this selection are typically
right. (I.e. if there is <code>sin</code>, there also should be
<code>cos</code>, <code>tanh</code>, <code>acos</code>, and such.)
</p>

<p>
<table border="1">
<tbody><tr><th>Function</th><th>Type</th><th>Computes</th><th>Example</th></tr>

<tr><td>abs</td><td><code>int -&gt; int</code></td><td>Absolute value</td><td><code>abs (-5)</code> =&gt; <code>5</code></td></tr>
<tr><td>abs_float</td><td><code>float -&gt; float</code></td><td>Absolute value</td><td><code>abs_float (-3.0)</code> =&gt; <code>3.0</code></td></tr>

<tr><td>sin</td><td><code>float -&gt; float</code></td><td>Sine</td><td><code>sin 3.1415</code> =&gt; <code>9.265...e-5</code></td></tr>
<tr><td>not</td><td><code>bool -&gt; bool</code></td><td>Negation</td><td><code>not false</code> =&gt; <code>true</code></td></tr>

<tr><td>floor</td><td><code>float -&gt; float</code></td><td>Round down to next integer</td><td><code>floor 5.2</code> =&gt; <code>5.0</code></td></tr>
<tr><td>modf</td><td><code>float -&gt; (float * float)</code></td><td>Floatingpoint fractional and integer part</td><td><code>modf 2.71828</code> =&gt; <code>(0.71828, 2.)</code></td></tr>

<tr><td>float_of_int</td><td><code>int -&gt; float</code></td><td>Conversion</td><td><code>float_of_int 5</code> =&gt; <code>5.0</code></td></tr>
<tr><td>int_of_float</td><td><code>float -&gt; int</code></td><td>Conversion (same as '<code>truncate</code>')</td><td><code>int_of_float 5.2</code> =&gt; <code>5</code></td></tr>

<tr><td>string_of_bool</td><td><code>bool -&gt; string</code></td><td>Name of boolean value</td><td><code>string_of_bool true</code> =&gt; <code>"true"</code></td></tr>
<tr><td>string_of_int</td><td><code>int -&gt; string</code></td><td>Integer formatting</td><td><code>string_of_int 42</code> =&gt; <code>"42"</code></td></tr>

<tr><td>int_of_string</td><td><code>string -&gt; int</code></td><td>Integer parsing</td><td><code>int_of_string "1337"</code> =&gt; <code>1337</code></td></tr>
<tr><td>print_string</td><td><code>string -&gt; unit</code></td><td>Prints a string</td><td><code>print_string "Hello"</code> =&gt; <code>()</code> (and prints "Hello")</td></tr>

<tr><td>read_line</td><td><code>unit -&gt; string</code></td><td>Reads in a line</td><td><code>read_line ()</code> =&gt; [input from stdin, without terminating \n]</td></tr>
<tr><td>read_int</td><td><code>unit -&gt; int</code></td><td>Reads in an integer</td><td><code>read_int ()</code> =&gt; [input from stdin]</td></tr>

<tr><td>read_float</td><td><code>unit -&gt; float</code></td><td>Reads in a float</td><td><code>read_float ()</code> =&gt; [input from stdin]</td></tr>
<tr><td>flush_all</td><td><code>unit -&gt; unit</code></td><td>Flush all output channels</td><td><code>flush_all ()</code> =&gt; <code>()</code> (and flushes buffers)</td></tr>

<tr><td>String.length</td><td><code>string -&gt; int</code></td><td>String length</td><td><code>String.length "hello"</code> =&gt; <code>5</code></td></tr>
</tbody></table>
</p>

<h3>Some important binary infix Operators</h3>

<p>Likewise, here is a table of selected binary operators:
</p>

<p>
<table border="1">
<tbody><tr><th>Operator(s)</th><th>Computes</th><th>Example</th></tr>
<tr><td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></td><td>Integer sum, difference, ...</td><td><code>2+3</code> =&gt; <code>5</code></td></tr>

<tr><td><code>+.</code>, <code>-.</code>, <code>*.</code>, <code>/.</code></td><td>Float sum, difference, ...</td><td><code>2.0+.3.0</code> =&gt; <code>5.0</code></td></tr>
<tr><td><code>=</code></td><td>Comparison ("equal")</td><td><code>(1,"abc")=(1,"abc")</code> =&gt; <code>true</code></td></tr>

<tr><td><code>&lt;&gt;</code></td><td>Comparison ("inequal")</td><td><code>(1,"abc")&lt;&gt;(1,"abc")</code> =&gt; <code>false</code></td></tr>
<tr><td><code>==</code></td><td>Comparison ("same")</td><td><code>(1,2)==(1,2)</code> =&gt; <code>false</code> (not the same "object" in the computer's memory!)</td></tr>

<tr><td><code>!=</code></td><td>Comparison ("not the same")</td><td><code>(1,2)!=(1,2)</code> =&gt; <code>true</code></td></tr>
<tr><td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td><td>Comparison (two values of the same type only!)</td><td><code>(5,"aa")&lt;(5,"aaa")</code> =&gt; <code>true</code></td></tr>

<tr><td><code>&amp;&amp;</code></td><td>Boolean "and" (uses short-circuit evaluation!)</td><td><code>(1&lt;&gt;1) &amp;&amp; (1/0&gt;100) </code> =&gt; <code>false</code> (!!!)</td></tr>
<tr><td><code>||</code></td><td>Boolean "or" (uses short-circuit evaluation!)</td><td><code>2&gt;3 || 7&gt;6 </code> =&gt; <code>true</code></td></tr>

<tr><td><code>lor</code></td><td>Bit-wise logical "or"</td><td><code>129 lor 3</code> =&gt; <code>131</code></td></tr>

<tr><td><code>lsl</code></td><td>Bit-wise logical shift left</td><td><code>1 lsl 6</code> =&gt; <code>64</code></td></tr>

<tr><td><code>mod</code></td><td>Integer modulus</td><td><code>13 mod 10</code> =&gt; <code>3</code></td></tr>


<tr><td><code>**</code></td><td>Floatingpoint exponentiation</td><td><code>2.0 ** 0.25</code> =&gt; <code>1.189...</code></td></tr>

<tr><td><code>::</code></td><td>List extension</td><td><code>1::[2;3]</code> =&gt; <code>[1;2;3]</code> (actually, this is an "<em>infix constructor</em>")</td></tr>
</tbody></table>
</p>

<h2>Further tricks</h2>

<p>There are a few things which we will only be able to fully
understand later on, but which will simplify our life greatly if we
have access to them right from the start.
</p>

<h3>Pretty-Printing</h3>

<p>The module <code>Printf</code> contains functions for formatted
output to <code>stdout</code>, to other streams, and to strings that
behave quite similar to C's <code>printf</code>, <code>fprintf</code>
and <code>sprintf</code> functions, but the syntax is a bit
strange. (OCaml has a somewhat special notion of "formatting strings
and arguments".)
</p>

<p>Examples:</p>

<p></p><pre><code>let x = 1.2 in Printf.sprintf "x^x = %f for x = %f\n" (x**x) x;;</code>
 =&gt; <code>"x^x = 1.244565 for x = 1.200000\n"</code></pre><p></p>

<p></p><pre><code>let user="root" in Printf.printf "Hello, %s!\n%!" user;;</code>
 =&gt; <code>()</code> (and prints "Hello, root!&lt;newline&gt;")</pre><p></p>

<p>Note: the OCaml-special format directive '<code>%!</code>' is a
convenient shorthand: it causes the output buffer to be flushed after
printing.
</p>

<h3>Tracing function calls</h3>

<p>The execution of toplevel functions can be monitored with
"<code>#trace this_function;;</code>". To turn off the tracing of a function, use
"<code>#untrace this_function;;</code>" or "<code>#untrace_all;;</code>"
</p>

<h3>How to deal with "impossible" or erroneous situations</h3>

<p>There is a very special function named '<code>failwith</code>' that
takes as argument a string and claims to return something that is of
<em>any</em> type, so one can use this e.g. in a situation similar in
structure to this:
</p>
<p><code></code></p><pre>let make_table_row x =
  if x &lt; 0.0
   then failwith "make_table_row argument must be positive!"
   else [|x;sqrt(x);x**3.0|]
;;</pre>
<p></p>

<h3>A first look at the compiler</h3>

<p>Let us create a file named "<code>hello.ml</code>", which just
looks as follows:
</p>

<p><table border="1">
<tbody><tr><th>A very simple example</th></tr>
<tr><td><pre><code>
Printf.printf "Hello out there\n%!";;

let rec fibonacci n = if n &lt; 3 then 1 else fibonacci (n-1) + fibonacci (n-2);;

Printf.printf "Please enter an integer number: %!";;

let n = read_int ()
in Printf.printf "The %d'th Fibonacci number is %d\n%!" n (fibonacci n);;
</code></pre></td></tr></tbody></table></p>

<p>We can now either run this directly in the interpreter, either by
running it as a script, or loading it at the interpreter prompt. We
can also compile it to a standalone application, using the OCaml
compiler:
</p>

<p><table border="1">
<tbody><tr><th>Running interpreted and compiled code</th></tr>
<tr><td><pre><code>
~/ocaml-tutorial$ ocaml hello.ml
Hello out there
Please enter an integer number: 20
The 20'th Fibonacci number is 6765


~/ocaml-tutorial$ ocaml
        Objective Caml version 3.08.3

# #use "hello.ml";;
Hello out there
- : unit = ()
val fibonacci : int -&gt; int = &lt;fun&gt;
Please enter an integer number: - : unit = ()
20
The 20'th Fibonacci number is 6765
- : unit = ()
# (* Note that here, we get the toplevel's output about
 successful evaluations mixed up with the actual output
 of our code. *)

^D

~/ocaml-tutorial$ ocamlopt -o hello hello.ml
~/ocaml-tutorial$ ./hello
Hello out there
Please enter an integer number: 20
The 20'th Fibonacci number is 6765
~/ocaml-tutorial$ ls -la hello
-rwxr-xr-x  1 tf tf 160207 Dec  8 21:28 hello
~/ocaml-tutorial$ file hello
hello: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV),
       for GNU/Linux 2.2.0, dynamically linked (uses shared libs), stripped
~/ocaml-tutorial$ ldd hello
	libm.so.6 =&gt; /lib/libm.so.6 (0x20028000)
	libdl.so.2 =&gt; /lib/libdl.so.2 (0x2004a000)
	libc.so.6 =&gt; /lib/libc.so.6 (0x2004d000)
	/lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x20000000)

~/ocaml-tutorial$ # Speed Comparison:

~/ocaml-tutorial$ time sh -c "echo 34 | ./hello"
Hello out there
Please enter an integer number: The 34'th Fibonacci number is 5702887

real	0m0.082s
user	0m0.070s
sys	0m0.000s
~/ocaml-tutorial$ time sh -c "echo 34 | ocaml ./hello.ml"
Hello out there
Please enter an integer number: The 34'th Fibonacci number is 5702887

real	0m0.569s
user	0m0.540s
sys	0m0.010s

$ # Compiled code is about seven times as
  # fast as interpreted code. The same in python:

~/ocaml-tutorial$ cat fib.py
def fibonacci(n):
  if n&lt;3:
    return 1
  else: return (fibonacci(n-1) + fibonacci(n-2))

print fibonacci(34)

~/ocaml-tutorial$ time python fib.py
5702887

real	0m8.045s
user	0m8.010s
sys	0m0.000s

$ # For this example, the ocaml interpreter is about 14 times faster
  # than the python interpreter.

~/ocaml-tutorial$ cat fib.c

#include &lt;stdio.h&gt;

int fibonacci(int n)
{
  return n&lt;3?1:fibonacci(n-1)+fibonacci(n-2);
}

int main(void)
{
  printf("fibonacci(34)=%d\n",fibonacci(34));
  return 0;
}

~/ocaml-tutorial$ gcc -O3 -o fib fib.c
~/ocaml-tutorial$ time ./fib
fibonacci(34)=5702887

real	0m0.110s
user	0m0.090s
sys	0m0.000s

$ # This is roughly the same amount of time
  # (slightly more) as used by our compiled ocaml code.
</code></pre></td></tr></tbody></table></p>

<p>A word of warning is in order here: one must not take
microbenchmarks like those too seriously. However, this at least
demonstrates that the claim that OCaml can play in the same
league as C is not unjustified.
</p>


<h2>How to write small programs in OCaml</h2>

<p>So far, we have heard a lot about data types, values, containers,
expressions, functions, and definitions. But how do we actually write
programs? That is, how do we assign to variables, execute statements
one after another, and such? The answer is: normally we don't. There
are some languages, like in particular Haskell, where strictly
speaking, all of this is even impossible, but which nevertheless allow
one to write large and beautiful programs. The <code>darcs</code>
version control system is an application written completely in
Haskell. OCaml is less radical here, but still, it is generally
considered much better to avoid a programming style that works with
lots of assignments and side effects if possible. At least, if we
define a variable with <code>let</code>, it is not possible to
over-write the value of that variable in OCaml: <em>Variables are NOT
"containers" where values are being stored, but just "names" for
values!</em>. True, it is possible to tell the toplevel to replace a
definition by another one, but this is not intended to be used in the
sense of changing the values of variables, and actually should only be
used interactively when "sketching" new code.
</p>

<p>That may sound pretty weird: we cannot assign to variables. But
actually, this is a very, very good thing. If we look at the C
programming language, where I just assume that most people in the
audience have some proficiency with, then it is customary there to
specify everything down to the level of what value goes where
when. Those who can read assembly language will agree that most C
statements can be transliterated very easily almost 1:1 to matching
assembly code - at least for many processors not from the x86 line;
for x86, things unfortunately are a bit odd and ugly. So, C makes it
comparatively easy to write a simple C compiler. However, this level
of detail also makes it difficult to write a sophisticated optimizing
C compiler! Why so? Because a compiler has to reason about what a
piece of code does, and this is easier if the code just says <em>what
should be done</em>, rather than how precisely the programmer thinks
this should be done on a register machine. Let us look at the
following C program:
</p>

<p><table border="1">
<tbody><tr><th>On spurious dependencies in C code</th></tr>
<tr><td><pre><code>
#include &lt;stdio.h&gt;

int main(void)
{
  int dummy;

  int x=10,y=20,a=30,b=40;

  printf("(x,y)=(%d,%d) - (a,b)=(%d,%d)\n",x,y,a,b);

  dummy=x;x=y;y=dummy;
  dummy=a;a=b;b=dummy;

  printf("(x,y)=(%d,%d) - (a,b)=(%d,%d)\n",x,y,a,b);

  return 0;
}
</code></pre></td></tr></tbody></table></p>

<p>This just exchanges the elements of two pairs of integer
values. Note that on a modern superscalar microprocessor, which has
more than one integer unit, one can imagine that both exchanges can
easily be performed in parallel - at least, in principle. However,
this is obscured by the re-use of the buffer variable
"<code>dummy</code>". So, in order to compile this to efficient
machine code, the compiler has to derive that the double use of the
<code>dummy</code> variable to exchange the elements of the first
pair, and of the second pair, does not lead to a conflict, and both
exchanges can be done in a different way that uses two dummy variables
(or none, if there is a primitive register exchange machine
operation). Guess how modern C compilers do that: they first re-write
the C source into an intermediate functional form, called SSA (static
single assignment), where every variable is just defined once, and
never changed, and then turn this into machine code. So, C is
<em>either</em> close to machine language, <em>or</em> fast, but
usually not both at the same time!
</p>

<p>So, even from the perspective of a compiler, having code written in
a form where assignments just do not occur is a great benefit. From
the perspective of the programmer, what matters most is if we can
express concisely <em>what</em> must be done, rather than <em>how</em>
we think it should be decomposed into elementary machine steps (where
we may guess very wrong). So, we should rather try to analyze our
problems in terms of a convenient mathematical decomposition of
problems into smaller problems, rather than a convenient
machine-centric decomposition. Of course, there are limitations to how
far we can take this shift of focus in reality. But it's presumably a
step in the right direction, as it is better for everyone that has to
read the code: both humans and compilers.
</p>

<p>The basic small-scale building blocks of our code will be
functions. On larger scales, there may be objects, classes, modules,
and such, and some functions may turn out to become object
methods. But the fundamental idea is to primarily think in terms of
mappings. It is quite amazing how far we can go by just thinking about
mappings, and ignoring all the details concerning input, output, and
user interaction. Virtually all algorithmic problems can be formulated
very well entirely in terms of functions. So, let us for now stick
with extending our super-calculator that not only knows about numbers
with new functions that make it smarter and smarter, and which we will
use from the interactive toplevel. In later lectures, we will start
worrying about input and output.
</p>

<h3>Some examples</h3>

<p>Let us look at some very simple examples to show how one analyzes
the mathematical side of a problem in such a way that this leads to an
OCaml function.
</p>

<h4>Euclid's algorithm for greatest common divisors</h4>

<p>Given two natural numbers <var>a</var> and <var>b</var>, there will
be a largest integer dividing both of them, the greatest common
divisor, <code>gcd</code>. Evidently, this cannot be larger than
either of <var>a</var> and <var>b</var>. Now, if <var>b</var> divides
<var>a</var>, the <code>gcd</code> will just be
<var>b</var>. Otherwise, this division of <var>a</var> by <var>b</var>
will produce a rest, which is strictly smaller than <var>b</var>.
Now, the greatest common divisor must also divide this rest, so it
must be the greatest common divisor of <var>b</var> and this
rest. Note that after this first step, which leads us to the
computation of <code>gcd(b,rest)</code>, the second argument is
smaller than the first one. So, if we just ensure that argument order
is such that with every recursive call, the first argument gets
smaller, we have a method that must eventually produce the correct
result. Hence:

</p><p><table border="1">
<tbody><tr><th>Euclid's gcd algorithm in OCaml</th></tr>
<tr><td><pre><code>
let rec gcd(a,b) =
  if b=1 then 1 else
  let rest = a mod b
      (* If we did not know mod,
	 we may have used "let rest = a-(a/b)*b" *)
  in
  if rest = 0 then b else gcd(b,rest);;

# val gcd : int * int -&gt; int = &lt;fun&gt;

# gcd(2,3);;
- : int = 1

# gcd(12,8);;
- : int = 4

# gcd(8,12);;
- : int = 4

# gcd(60,42);;
- : int = 6
</code></pre></td></tr></tbody></table></p>
<p></p>

<h4>Horner's method to evaluate polynomials</h4>

<p>Given a polynomial in one variable, such as
<code>5*x^4-2*x^3+8*x^2+6*x-3</code>, an efficient way to compute its
value for a given value of <code>x</code> is to re-write it in the
form <code>(((5*x-2)*x+8)*x+6)*x-3</code>. That is, we perform a
sequence of steps on a single value, which we keep in mind, where
every step consists of multiplying with <code>x</code>, and adding
another coefficient. One very nice way to represent a vector of
coefficients in OCaml is to use a <code>float array</code>, so let us
use that. We then furthermore have to know in every step at which
position in the polynomial we are. So, we actually do not remember
just a number, but a pair of a number and a position. We start out
with the leading coefficient and the position of the sub-leading
coefficient.
</p>

<p><table border="1">
<tbody><tr><th>Horner's method in OCaml</th></tr>
<tr><td><pre><code>

let horner (poly_coeffs,x) =
  let nr_coeffs=Array.length poly_coeffs in
  let rec multiply_add (value_now,position) =
    if position = nr_coeffs
    then value_now
    else multiply_add (value_now*.x+.poly_coeffs.(position),position+1)
  in
  if nr_coeffs=0 then 0.0 (* Note that we have to handle this special case *)
  else
    multiply_add (poly_coeffs.(0),1)
;;

# horner ([|1.0;0.0;0.0;0.0;4.0|],10.0);; (* x^4+4 at x=10 *)
- : float = 10004.

# horner ([|3.0;9.0;9.0;3.0|],9.0);; 
  (* 3x^3 + 9x^2 + 9x + 3 = 3(x+1)^3 for x=9 *)
- : float = 3000.

# (* Note that we also can do something very nice with OCaml: *)
  let vivify_polynomial poly_coeffs = fun x -&gt; horner(poly_coeffs,x);;
val vivify_polynomial : float array -&gt; (float -&gt; float) = &lt;fun&gt;

# (* This maps a vector of coefficients to a polynomial *function*! *)
  let poly_x3_plus_3x = vivify_polynomial [|1.0;0.0;3.0;0.0|];;
val poly_x3_plus_3x : float -&gt; float = &lt;fun&gt;

# (* This function then can be used like every other function *)
  poly_x3_plus_3x 10.0;;
- : float = 1030.

# (* All this will become very important later on *)

</code></pre></td></tr></tbody></table></p>

<!-- XXX more examples -->


<h2>Getting Help</h2>

<p>How to get help with OCaml problems? First of all, there is the
OCaml documentation. This is available e.g. via the info system. In
Emacs, <code>Control-h i</code> will bring up the info
pages. Internally, we've made this available as well via 
<a href="http://alpha.sesnet.soton.ac.uk/docs/ocaml/"><tt>http://alpha.sesnet.soton.ac.uk/docs/ocaml/</tt></a>. Later on, especially section IV on libraries will become an important source for us.
</p>

<p>
Furthermore, there is the "Developing Applications With Objective
Caml" free online book, which is also available at
<a href="http://alpha.sesnet.soton.ac.uk/docs/ocaml-book/"><tt>http://alpha.sesnet.soton.ac.uk/docs/ocaml-book/</tt></a>.
</p>

<p>And, of course, you can always ask the instructor. Please just do
so when questions come up. I want to learn where beginners have
problems. Note: if you want to learn OCaml, you are supposed to do
these exercises!
</p>

<h2>Exercises</h2>

<p>All of the following exercises are of the "how can I do
this-and-that in OCaml" type, rather than the "what is the OCaml
notation for this and that" type. One certainly has to know a bit
about the language, but becoming a language lawyer without any real
programming experience is utterly pointless. The list seems to be
quite long, however, some exercises are very easy. 
</p>

<p>
</p><ol>

<li><p>Define an OCaml function that computes the least common
multiple of two positive integer numbers. Extra style points for doing
this in such a way that the correct answer is found for the least
common multiple of 3000000 and 7000000.</p></li>


<li><p>Define a factorial function.
</p></li>

<li><p>Define a function that maps the pair of integers
<code>(n,m)</code> to the binomial coefficient "<code>n</code> over
<code>m</code>". Can you do this with the smallest possible number of
multiplications and divisions?</p></li>

<li><p>Define binomial coefficients for non-integer <code>n</code>.
</p></li>

<li><p>OCaml comes with a square root function. Define your own, using
Heron's method. (Reminder: given an estimate <var>x</var> for the
square root of <var>n</var>, another estimate which is at least as
good is given by taking the average of <var>x</var> and
<var>n/x</var>.  Stop when the relative difference between
<var>x</var> and <var>n/x</var> is smaller than 1 in 10^8.) <em>Note:
never ever, no matter what programming language, define functions
which have exactly the same name as built-in functions!</em> </p></li>

<li><p>In the above discussion of Horner's method, we used a
<code>float array</code> to represent coefficients. One may also
represent coefficients as a <code>float list</code>. The advantage of
using a list is that one can "shorten" the list in every step by
passing just its tail to the recursive call, and hence go without
determining the length beforehand, and also without remembering the
coefficient position. Write an implementation of Horner's method using
lists to represent coefficients that heeds these considerations.
(Unrelated side note: The disadvantage of using a list here is that in
every step, the machine has to chase a pointer.)
</p></li>

<li><p>For a given continuous function <code>f</code> that is negative
at <code>a</code> and positive at <code>b</code>, there must be a zero
in between. Write a function that takes a triplet <code>(f,a,b)</code>
of type <code>((float -&gt; float),float,float)</code> and uses
successive interval bisection to numerically determine the location of
the zero. Generalize in such a way that this works whenever <code>f
a</code> and <code>f b</code> have different sign.
</p></li>

<li><p>The hyperbolic tangent satisfies the addition theorem
<code>tanh(a+b)=(tanh(a)+tanh(b))/(1+tanh(a)*tanh(b))</code>.  Define
an OCaml function that checks this addition theorem by mapping
<code>(a,b)</code> to the pair of values on the the left hand side and
right hand side of that equation. (What is the type of that function?)
Furthermore, assuming that for values of absolute magnitude smaller
than 10^(-8), <code>tanh x</code> always can be approximated by
<code>x</code>, use the addition theorem to define your own variant of
a <code>tanh</code> function. Use the tracing features to monitor the
computations done by your hyperbolic tangent. How much does your
variant deviate from the built-in <code>tanh</code> function,
typically?</p>

<p>Note: spend some thought on the problem first!</p></li>

<li><p>Define your own exponential function using your factorial
function and the <code>vivify_polynomial</code> function from the
Horner example.</p></li>

<li><p>The exponential function satisfies an addition theorem
<code>exp(a+b)=exp(a)*exp(b)</code>. Furthermore, for numbers of
absolute magnitude smaller than 10^(-8), <code>exp(x)</code> can be
approximated as <code>1+x</code>. Use this to define your own
exponential function.
</p></li>

<li><p>Normally, you can only use values defined previously in a
definition. The "<code>let rec</code>" construct allows us to make
recursive definitions. Sometimes, this is not good enough and we want
to define multiple functions at the same time, which can recurse into
one another. This is done with "<code>let rec ... and</code>". (This
is a special case of "<code>let ... and</code>" which also may be nice
to know about, but which we will not discuss here.) Mutual recursion
works as follows:
</p>

<p><table border="1">
<tbody><tr><th>How to define mutually recursive functions</th></tr>
<tr><td><pre><code>

let rec humpty = fun x -&gt; if x=0 then [] else "humpty"::(dumpty (x-1))
and dumpty = fun x -&gt; if x=0 then [] else "dumpty"::(humpty (x-1));;

(* This is equivalent to: *)

let rec humpty x = if x=0 then [] else "humpty"::(dumpty (x-1))
and dumpty x = if x=0 then [] else "dumpty"::(humpty (x-1));;

#   val humpty : int -&gt; string list = &lt;fun&gt;
val dumpty : int -&gt; string list = &lt;fun&gt;
# dumpty 3;;
- : string list = ["dumpty"; "humpty"; "dumpty"]
# dumpty 4;;
- : string list = ["dumpty"; "humpty"; "dumpty"; "humpty"]
# humpty 4;;
- : string list = ["humpty"; "dumpty"; "humpty"; "dumpty"]

(* Note that someone might have the clever idea to do it that way,
   but unfortunately, OCaml's "let rec" is slightly flawed,
   so it will not allow this: *)

let rec (humpty,dumpty) = 
  ((fun x -&gt; if x=0 then [] else "humpty"::(dumpty (x-1))),
   (fun x -&gt; if x=0 then [] else "dumpty"::(humpty (x-1))))
;;
</code></pre></td></tr></tbody></table></p>

<p>For <code>x</code> of absolute value smaller than
<code>10^(-8)</code>, <code>sin(x)</code> can be approximated by
<code>x</code>, and <code>cos(x)</code> can be approximated by
<code>1</code>. Use the addition theorems
<code>sin(x+y)=sin(x)cos(y)+sin(y)cos(x)</code> and
<code>cos(x+y)=cos(x)cos(y)-sin(x)sin(y)</code> to define your own
variants of <code>sin</code> and <code>cos</code>. Test them for very
small arguments first. Is this a good method to compute sine and
cosine functions? If not, where is the problem, and how might this be
improved?
</p>

</li><li><p>We are slowly developing a feeling for what it means to write
programs by extending "the OCaml programmable calculator" with new
definitions. Let us now see how to do a problem in OCaml which is more
like a typical beginner's example for C programmers: Write a small
game that determines a random number between 1 and 100 and lets the
user repeatedly guess that number until he gets it right. When he did
not guess right, the program should tell him whether he guessed too
high or too low.</p>

<p>Hints:</p>

<p>
</p><ul>
<li><p>The function <code>Random.int</code> takes an integer argument
<code>n</code> and produces a random integer number in the range
<code>[0..(n-1)]</code>.</p>
</li>

<li><p>Here is a function you may find very helpful. We cannot yet really
understand how it works, but we do not have to at present. All that
matters is that it will take a string as an argument, print this out,
ask the user to enter an integer, and return that integer. If the user
entered nonsense, it just persistently asks again.</p>

<p><table border="1">
<tbody><tr><th>A function that maps a query to a user-provided integer</th></tr>
<tr><td><pre><code>
let user_query_int query =
  let rx_int = Str.regexp "^[ \t]*\\(-?[0-9]+\\)[ \t\n\r]*$" in
  let int_from_string s =
    if Str.string_match rx_int s 0 
    then Some (int_of_string (Str.matched_group 1 s))
    else None
  in
  let rec ask last_answer_was_bad =
    let () = Printf.printf "%s%s"
	(if last_answer_was_bad then "Please enter an integer.\n" else "")
	query
    in match (int_from_string (read_line ())) with
    | None -&gt; ask true
    | Some n -&gt; n
  in ask false
;;
</code></pre></td></tr></tbody></table></p>
</li>
</ul>
<p></p>
</li>
</ol>

<br><hr><br>
    <h1>More about Functions</h1>

<p>Evidently, functions do play an ubiquitous role in a functionally
oriented language. So, it is a good idea to spend a bit more time with
them. In a nutshell, the contents of this lesson may be summarized as:
"with very few exceptions, functions just behave in the natural way
one should expect them to behave."
</p>

<p>In particular, this means:</p>

<p>
</p><ol>
<li>Functions just are values that may be given names, passed around,
put into arrays, lists, and tuples, and evaluated.</li>

<li>Once we have a function, it does not matter when and where we
evaluate it: We can pass it around, and still it behaves as it did
when and where we created it.
</li>

<li>A function need not be given a name, just as an integer, a tuple,
or any other value need not have a name.
</li>
</ol>
<p></p>

<p>Now, all this may sound very obvious. Actually, it is not, as there
are many programming languages which do not provide us with functions
that have all these properties. Let us just look at the third point to
give an example. In C, one could write:
</p>

<p>
</p><center>
<table border="1"><tbody><tr><th>Anonymous entities in C</th></tr>

<tr><td><pre><code>
#include &lt;stdio.h&gt;

char *a_string_named_charly={'C','h','a','r','l','y',0};
/* Ah, joys olf Hungarian Notation */

int function_number_five(void)
{
  return 5;
}

int main(void)
{
  printf("This is charly: %s\n",a_string_named_charly);
  printf("This is function five: %d\n",function_number_five());
  
  printf("Here, we use an un-named (anonymous) string: %s\n",
	 "I have no (variable) name");

  /* 
  printf("Here, we would like to use an anonymous function...",
	 ???);
  ...but something like that actually does not exist in C */

  return 0;
}
</code></pre></td></tr>
</tbody></table>
</center>
<p></p>



<p>The major differences between OCaml functions and the mathematical
concept of a function as a mapping are:
</p>

<p>
</p><ol>
<li>We may want to think and even talk about the amount of effort
involved in the evaluation of a function. (In mathematics, it is not a
problem to e.g. define the determinant in a very "inefficient" way if
it helps to prove theorems.)
</li>

<li>A function need not at all produce a value. It may just run
forever and never return anything.</li>

<li>Mathematical functions are mappings from a given domain to a given
co-domain that "never change": <code>f(5)</code> will always be the
same value, no matter where the evaluation of <code>f</code> at the
point <code>5</code> occurs in a line of reasoning. In OCaml, there
are functions for which this is not the case, such as
e.g. <code>Random.int: (int -&gt;int)</code>.
</li>

<li>Furthermore, the evaluation of an OCaml function may "change the
world around us". For example, evaluating <code>Unix.unlink: (string
-&gt; unit)</code> may delete a file.
</li>
</ol>
<p></p>


<p>From the C example above, we see that there is a fundamental
difference between functions and other values in C: Functions cannot
be constructed anonymously. Actually, this is just a symptom of a much
deeper problem: <em>The C programming language does not have any
"functions"!</em>. What do I mean by that? Even though C terminology
calls constructions like "<code>function_number_five</code>" above a
"function", technically speaking it is not: it merely is a pointer to
a block of memory where machine code instructions lie that go through
a sequence of operations and can be called with arguments. From our
point of view, this is rather just a subroutine than a proper
function.
</p>

<p>It is very instructive to look at the history of the Perl
programming language in order to understand what is going wrong
here. Indeed, the Perl developers got this issue of anonymous values
wrong over and over again, first for arrays, then for file handles,
then for regular expressions, and at some point in time had to repair
it. This is one reason why the Perl programming language is so uneven.
</p>

<p>Initially, Perl did not have a concept of arrays as other
programming languages do: instead of a container value to which one
could refer as <em>this array</em>, perl provided an unique concept of
"plurality", which is, there are means to refer to <em>that value</em>
(a single one), or <em>those values</em> (a collection). Now, this
concept of plurality did not allow to talk about e.g. using an array
of arrays to represent a matrix: in no useful sense could <code>those
values</code> be composed of elements which represented <em>these
other values</em> each. Putting a "group" of values into another group
of values just gives a larger group in Perl. One give collections of
values a name, but one could not treat them as a separate new entity
which could be passed around freely in a program.
</p>

<p>So, what people did here was to introduce a concept of "symbolic
references", which roughly means that they introduced a way to
interpret an ordinary string as a variable name, so that one then
could just pass around the string name of an array and use that
whenever needed. This seemed to somewhat solve the problem, but
surely, it neither was elegant, nor overly bright: When one wanted to
write a function that created a matrix, one had to invent
internal-only unique name strings for every row, and as this methods
really introduced a set of new variables whose values had to be the
rows. This led to all sorts of problems, such as that it was difficult
to take care that on the one hand, making a new matrix did not
over-write a pre-existing one and at the other hand, the entries of a
matrix were freed properly once it was no longer in use.
</p>

<p>
<table border="1">
<tbody><tr><th>Making an array of arrays in old perl (schematically)</th></tr>
<tr><td>
<pre><code>
sub make_matrix
  {
    ($nr_rows,$nr_cols,$base_name)=@_;
    
    @matrix=();
    for($r=0;$r&lt;$nr_rows;$r++)
      {
	@row=map {"Row $r, Column $_"} (0..$nr_cols-1);
	$row_name="$base_name-$r";
	$$row_name=@row;
	push @matrix, $row_name;
      }
    return  @matrix;
  }
</code></pre>
</td></tr>
</tbody></table>
</p>

<p>What's changed with modern Perl is that they introduced two new
concepts: first, that of a proper array in the sense of "this
collection of values", second, this new container data type comes with
an "anonymous array constructor", that is, a way to create an array
without having to give it a name.
</p>

<p>
<table border="1">
<tbody><tr><th>What changed with Perl5</th></tr>
<tr><td>
<pre><code>
sub make_matrix_perl5
  {
    my($nr_rows,$nr_cols,$base_name)=@_;
    
    my @matrix;
    
    for(my $r=0;$r&lt;$nr_rows;$r++)
      {
	@row=map {"Row $r, Column $_"} (0..$nr_cols-1);
	$matrix[$r]=[ @row ];
	#           ^ anonymous array constructor!
      }
    return \@matrix;
  }
</code></pre>
</td></tr>
</tbody></table>
</p>

<p>This example serves us as a double warning, more so as in
particular with Perl, the very same problem re-occurred in other
guises (as mentioned), where the initial (or even present) approaches
were about as bad as these "symbolic references": First, one must
admit that it is surprisingly easy to be confused about the issue of
why and how to properly support anonymous composite values in a
programming language. Second, it usually is not a good idea not to
think enough about the underlying abstract concepts. In the end, it
will just turn out that one cannot avoid them anyway, and inventing
some ad-hoc approaches that don not get the fundamental idea right
might bite back badly.
</p>

<p>We already have seen how to create anonymous functions in OCaml in
the last lesson. As a reminder:
</p>

<p>
<table border="1">
<tbody><tr><th>Reminder: Anonymous functions in OCaml</th></tr>
<tr><td>
<pre><code>
# let some_list = [(fun x -&gt; x+10);(fun x -&gt; x+11);(fun x -&gt; x+12)];;
val some_list : (int -&gt; int) list = [&lt;fun&gt;; &lt;fun&gt;; &lt;fun&gt;]

# (List.hd some_list) 100;;
- : int = 110
</code></pre>
</td></tr>
</tbody></table>
</p>

<p>Here, we created a list of three functions mapping integers to
integers. As the type of such a function is <code>int -&gt;
int</code>, the type of that particular list has to be <code>(int
-&gt; int) list</code>. Note that the parentheses around <code>(fun
...)</code> are actually necessary here (but admittedly for somewhat
unfortunate reasons).
</p>

<p>This settles another point: how to put functions into lists (,
arrays, tuples, ...), and how to retrieve them and evaluate
them. <em>Whenever we want to evaluate a function, we just put the
argument after the function.</em> This is a very important general
rule and we will have more to say about this very soon.
</p>

<p>What does it mean then that the behaviour of a function, when
evaluated, must not depend on where that evaluation takes place?
Actually, this is something very simple and natural, and it may just
be that we are not familiar enough yet with functions so that it does
not sound strange. So, let us demonstrate the concept with arrays,
where it is just the same: Suppose I give the following definition:
</p>

<p>
<table border="1">
<tbody><tr><th>Arrays and Scope</th></tr>
<tr><td>
<pre><code>
# let my_array_v1 =
    let a1 = [|1.0;2.0;3.0|] in
    let a2 = [|10.0;20.0;30.0|] in
   [|a1;a1;a2|]
;;

val my_array_v1 : float array array =
  [|[|1.; 2.; 3.|]; [|1.; 2.; 3.|]; [|10.; 20.; 30.|]|]

# let my_array_v2 =
    let a1 = [|1.0;2.0;3.0|] in
    let a2 = [|10.0;20.0;30.0|] in
   [|a1;Array.copy a1;a2|]
;;

val my_array_v2 : float array array =
  [|[|1.; 2.; 3.|]; [|1.; 2.; 3.|]; [|10.; 20.; 30.|]|]
</code></pre>
</td></tr>
</tbody></table>
</p>

<p>If we go back to our list of operators from the first lesson, we
see that there is a difference between "being the same" and "being
equal", and we can express this difference in meaning in OCaml by
using either the "<code>==</code>" or the "<code>=</code>" comparison
operator, the former testing for same-ness. Now, in our situation, we
get (look sharp):
</p>

<p>
<table border="1">
<tbody><tr><th>Arrays and Scope, continued</th></tr>
<tr><td>
<pre><code>
# my_array_v1.(0) = my_array_v1.(1);;
- : bool = true

# my_array_v1.(0) = my_array_v1.(2);;
- : bool = false

# my_array_v1.(0) == my_array_v1.(1);;
- : bool = true

# my_array_v2.(0) == my_array_v2.(1);;
- : bool = false

# my_array_v2.(0) = my_array_v2.(1);;
- : bool = true
</code></pre>
</td></tr>
</tbody></table>
</p>

<p>So, <code>my_array_v1</code> and <code>my_array_v2</code> may look
very similar at first, but actually, they are structurally very
different: In the first case, the first and second entry of this array
are the very same entity, while in the second case, they are not. So,
if I just replaced <code>my_array_v2.(0).(1)</code> with 500, I would
get what I asked for, but if I did this with
<code>my_array_v1.(0).(1)</code>, then
<code>my_array_v1.(1).(1)</code> would change accordingly!
</p>

<p>This may not be as unexpected if we manipulated the rows in the
scope where <code>a1, a2</code> are defined, but it might require some
getting used to that in fact, these row entities survive beyond the
scope where they are defined via being referenced in the final
array-of-arrays value. After the definition of
<code>my_array_v1</code>, the names <code>a1</code> and
<code>a2</code> are gone forever - they were only valid locally. But
through the value returned from that scope, we retain a handle on
them.
</p>

<p>It is just the same with functions. To demonstrate this, let us
look at a function which is returned from a local scope that contained
a variable which entered in the definition of that function. Here is
an equivalent of the last example using functions instead of arrays:
</p>

<p>
<table border="1">
<tbody><tr><th>Functions and Scope</th></tr>
<tr><td>
<pre><code>
# let my_fun =
    let a1 = [|1.0;2.0;3.0|] in
    let a2 = [|10.0;20.0;30.0|] in
   (fun n -&gt; if n &lt; 2 then a1 else a2)
;;

val my_fun : int -&gt; float array = &lt;fun&gt;
# my_fun 0;;
- : float array = [|1.; 2.; 3.|]

# my_fun 1;;
- : float array = [|1.; 2.; 3.|]

# my_fun 0 == my_fun 1;;
- : bool = true

# my_fun 2;;
- : float array = [|10.; 20.; 30.|]
</code></pre>
</td></tr>
</tbody></table>
</p>

<p>I suppose there should be little debate that the particular
behaviour of scoping issues and anonymously created arrays is both
desirable and useful. But then, what would be more natural than to
demand that with anonymously created functions, where these issues
arise in just the same form again, things work just in the same way?
</p>

<p>In fact, we already have seen something like this in the last
lesson: remember the "<code>vivify_polynomial</code>" function which
briefly showed up in the Horner example and the exercises? Here as
well, we define a function which retains some memory over values from
the scope it was defined in. This is a very powerful technique that
allows us to do all sorts of tricks. To give a very simple example, we
can define functions such as the following that map a number to a
"machine" adding that number to another number:
</p>

<p>
<table border="1">
<tbody><tr><th>Functions and Scope: another simple example</th></tr>
<tr><td>
<pre><code>
# let add =
   (fun to_add -&gt;
     (fun x -&gt; x + to_add))
;;

val add : int -&gt; (int -&gt; int) = &lt;fun&gt;

# (* Actually, I put in the parentheses by hand.
     We will have to say more about this soon. *)

# let add_five = add 5;;
val add_five : int -&gt; int = &lt;fun&gt;

# add_five 3;;
- : int = 8

# add_five 1000;;
- : int = 1005
</code></pre>
</td></tr>
</tbody></table>
</p>

<p>Actually, it's the simplest thing in the world. Or maybe not. Just
for the sake of looking over the fence, here is the equivalent in
LISP, in a form which is understood by both the Emacs interpreter as
well as by a proper Common LISP system, such as Bruno Haible's CLISP:
</p>

<p>
<table border="1">
<tbody><tr><th>The same example in LISP (Common LISP and Emacs LISP)</th></tr>
<tr><td>
<pre><code>
(defun add (to_add)
  (lambda (x) (+ x to_add)))

(defvar add_five (add 5))
add_five

(funcall add_five 1000)
;; Emacs says: Symbol's value as a variable is void: to_add
;; CLISP says: 1005

;; Even worse:

(defvar to_add 27)

(funcall add_five 1000)
;; Emacs says: 1027
;; CLISP still says: 1005
</code></pre>
</td></tr>
</tbody></table>
</p>

<p>Not infrequently, one encounters the situation that, given a
function of multiple arguments, we want to fix some of them and treat
it as a function of fewer arguments. For example, kinetic energy is a
function of mass and velocity. Usually, we want to consider a given
body with fixed mass. Then, it is just a function of velocity. This
can be modeled very nicely and directly with these techniques:
</p>

<p>
<table border="1">
<tbody><tr><th>Example: fixing parameters</th></tr>
<tr><td>
<pre><code>

# let kinetic_energy = (fun (m,v) -&gt; 0.5*.m*.v*.v);;
(*
   Equivalently, we also could have defined:
   
   let kinetic_energy (m,v) = 0.5*.m*.v*.v;;
 *)

val kinetic_energy : float * float -&gt; float = &lt;fun&gt;

# let kinetic_energy_of_ball =
    fun v -&gt; kinetic_energy (10e-3,v);;

val kinetic_energy_of_ball : float -&gt; float = &lt;fun&gt;

# kinetic_energy_of_ball 5.0;;
- : float = 0.125
</code></pre>
</td></tr>
</tbody></table>
</p>



<p>Let us consider something more convoluted, but actually very
useful: as we have seen, we can map values like the number five above
to functions that "know" about that value. Of course, the initial
values can also be functions, and there are some very interesting
mathematical concepts which may be understood in terms of mappings
from functions to functions which we can capture that way. Actually,
what we can do is limited by the fact that all we can do in order to
get information about what's "inside" a function is to call it. So, we
will not be able to model, say, symbolic derivatives, in this way. We
can, however, model taking a derivative, or gradient, numerically. Let
us try this for the one-dimensional gradient of a function which is
given as a <code>float -&gt; float</code> function <code>f</code> in
OCaml. Now, how does one compute such a gradient? We will have to
evaluate the function <code>f</code>, as that is all we can do to
<code>f</code> anyway. It will not help us to know <code>f</code> only
at one place if we want to know something about how strongly it
varies. So, we have to evaluate it at least at in two places. And two
is already sufficient to get a numerical approximation for the
gradient. But we may want to do more in some situations. For the sake
of simplicity, let us be content with only two evaluations here. What
we furthermore have to know is the distance <code>epsilon</code> of
the locations where we evaluate <code>f</code>. We would get the
proper gradient in by taking the limit where <code>epsilon</code> goes
to zero, but we clearly cannot do this on the machine. So we will
content ourselves with something much more primitive and just choose
<code>epsilon=10^(-8)</code>. (There are deeper reasons for choosing a
value just about this large.) So, when we know <code>epsilon</code>,
and the function <code>f</code>, we can then make a function that maps
a position <code>x0</code> to the numerically determined derivative of
<code>f</code> at <code>x0</code> with step width
<code>epsilon</code>. Let us have a try:
</p>

<p>
<table border="1">
<tbody><tr><th>Defining the gradient - first try</th></tr>
<tr><td>
<pre><code>
# 
let grad_v1 (epsilon,f) =
  let epsilon_half = 0.5*. epsilon in
  let inv_epsilon = 1.0/.epsilon in
  (fun x0 -&gt; 
    ((f (x0+.epsilon_half)) -. (f (x0-.epsilon_half)))
      *.inv_epsilon)
;;


val grad_v1 : float * (float -&gt; float) -&gt; (float -&gt; float) = &lt;fun&gt;

# let test_grad_v1 = grad_v1 (1e-8,(fun x -&gt; x*.x));;
val test_grad_v1 : float -&gt; float = &lt;fun&gt;

# test_grad_v1 5.0;;
- : float = 10.00000082740371
</code></pre>
</td></tr>
</tbody></table>
</p>

<p>Here, we made <code>epsilon</code> a parameter, which is slightly
more useful than having it fixed as <code>10^(-8)</code>. One could
always apply the parameter fixing technique shown above then. In
particular, we may then introduce a function
<code>grad_with_epsilon_fixed</code> which takes <code>epsilon</code>
as a parameter and returns a gradient-taking function <code>f</code>
that uses this <code>epsilon</code>:
</p>

<p>
<table border="1">
<tbody><tr><th>Defining the gradient - a slight generalization</th></tr>
<tr><td>
<pre><code>
# 
let gradient_with_epsilon_fixed epsilon =
  (fun f -&gt; grad_v1 (epsilon,f))
;;

val gradient_with_epsilon_fixed :
 float -&gt; (float -&gt; float) -&gt; (float -&gt; float) =
  &lt;fun&gt;

# let another_grad = gradient_with_epsilon_fixed 1e-5;;
val another_grad : (float -&gt; float) -&gt; float -&gt; float = &lt;fun&gt;

# let test_another_grad = another_grad (fun x -&gt; sin x +. x*.x);;
val test_another_grad : float -&gt; float = &lt;fun&gt;

# test_another_grad 0.0;;
- : float = 0.999999999995833222
</code></pre>
</td></tr>
</tbody></table>
</p>

<p>But if this is useful - a function that allows us to specify
epsilon beforehand, why don't we just eliminate the intermediate pair,
as well as the function taking that pair as an argument?
</p>

<p>
<table border="1">
<tbody><tr><th>Defining the gradient - second try (simplification)</th></tr>
<tr><td>
<pre><code>
#
let grad_v2 epsilon =
  let epsilon_half = 0.5*. epsilon in
  let inv_epsilon = 1.0/.epsilon in
  (fun f -&gt;
    (fun x0 -&gt; 
      ((f (x0+.epsilon_half)) -. (f (x0-.epsilon_half)))
	*.inv_epsilon))
;;

val grad_v2 : float -&gt; (float -&gt; float) -&gt; float -&gt; float = &lt;fun&gt;

# let test_grad_v2 = grad_v2 1.0e-8 (fun x -&gt; x**1.5);;
val test_grad_v2 : float -&gt; float = &lt;fun&gt;

# test_grad_v2 1.0;;
- : float = 1.49999999088379354
</code></pre>
</td></tr>
</tbody></table>
</p>

<p>Note that we have seen earlier that "<em>Whenever we want to
evaluate a function, we just put the argument after the
function</em>"? This works here as well. <code>grad_v2 1.0e-8</code>
is a function, so if we just put the argument <code>(fun x -&gt;
x**1.5)</code> behind it, we evaluate the function for this
argument. Extra parentheses are not necessary here. This is indeed the
preferred notational style in OCaml for evaluating functions which
themselves are the result of a function evaluation. Simple and
convenient. And actually, it is not really worse than passing a pair
for us as well, as there is no reason at the conceptual level why one
should treat <code>epsilon</code> and <code>f</code> as belonging
together in a pair. But then, we may just as well write e.g.:
</p>

<p>
<table border="1">
<tbody><tr><th>Evaluation by putting arguments after functions</th></tr>
<tr><td>
<pre><code>
# grad_v2 1.0e-8 (fun x -&gt; x**1.5) 1.0;;
- : float = 1.49999999088379354

# grad_v2 1.0e-8 (fun x -&gt; x**1.5) 4.0;;
- : float = 3.00000007058542906
</code></pre>
</td></tr>
</tbody></table>
</p>

<p>Here, evaluating <code>epsilon_half</code> and
<code>inv_epsilon</code> is not really a lot of computational effort,
so it does not hurt if we do not pre-compute that value, but compute
<code>1/epsilon</code> whenever we actually do compute a gradient
value. Let me just put this at the innermost level to demonstrate
something else, as we then get a nice repetitive <code>(fun ... (fun
...  </code> structure:
</p>

<p>
<table border="1">
<tbody><tr><th>Repetitive <code>fun</code> after <code>fun</code></th></tr>
<tr><td>
<pre><code>
let grad_v3 =
  (fun epsilon -&gt;
    (fun f -&gt;
      (fun x0 -&gt; 
	let epsilon_half = 0.5*. epsilon in
	let inv_epsilon = 1.0/.epsilon in
	((f (x0+.epsilon_half)) -. (f (x0-.epsilon_half)))
	  *.inv_epsilon)))
;;
</code></pre>
</td></tr>
</tbody></table>
</p>

<p>Remember that <code>let something = fun argument -&gt; body</code>
can be re-written as <code>let something argument = body</code>
without a change in meaning? (Actually, there may be a difference if
one looks very closely at memory requirements and execution speed. But
even if there is, there should be no reason why it should be - an
optimizer should be able to recognize this situation).  We actually
can even do this repeatedly. Look how nicely all this then simplifies:
</p>

<p>
<table border="1">
<tbody><tr><th>Multiple arguments at the left hand side of a let</th></tr>
<tr><td>
<pre><code>
let grad_v4 epsilon =
  (fun f -&gt;
    (fun x0 -&gt; 
      let epsilon_half = 0.5*. epsilon in
      let inv_epsilon = 1.0/.epsilon in
      ((f (x0+.epsilon_half)) -. (f (x0-.epsilon_half)))
	*.inv_epsilon))
;;

let grad_v5 epsilon f =
  (fun x0 -&gt; 
    let epsilon_half = 0.5*. epsilon in
    let inv_epsilon = 1.0/.epsilon in
    ((f (x0+.epsilon_half)) -. (f (x0-.epsilon_half)))
      *.inv_epsilon)
;;

let grad_v6 epsilon f x0 =
  let epsilon_half = 0.5*. epsilon in
  let inv_epsilon = 1.0/.epsilon in
  ((f (x0+.epsilon_half)) -. (f (x0-.epsilon_half)))
    *.inv_epsilon
;;
</code></pre>
</td></tr>
</tbody></table>
</p>

<p>Of course, one could just as well throw out the
<code>inv_epsilon</code> here - there no longer is any point in
carrying this around. But that's a very minor issue. Now, let us look
at the type of any of those functions: OCaml reports it as
"<code>float -&gt; (float -&gt; float) -&gt; float -&gt; float</code>". Here, one
should know that for functions returning functions, the convention for
types is that "<code>a -&gt; b -&gt; c</code>" will always mean
<code>a -&gt; (b -&gt; c)</code>, that is, parentheses have to be
inserted to the right. So, fully parenthesized, this type would read:
"<code>float -&gt; ((float -&gt; float) -&gt; (float -&gt;
float))</code>". Indeed, we map a <code>float</code> (namely,
<code>epsilon</code> to a function mapping <code>float -&gt; float</code>
functions to other such functions - which is just what the gradient
does. As we have seen, there seems to be kind of a duality between
functions whose arguments are tuples and functions which produce other
functions: one may regard a function such as addition either as a
mapping from a pair of numbers to a number, or alternatively, as a
mapping from numbers to mappings from numbers to numbers, where every
number <code>N</code> is mapped to the <code>increase-by-N</code>
function. Both ways to express addition contain the same amount of
information, but the advantage of the purely functional point of view
is that it can do without any notion of tuples and such. In fact, it
is easy to define a notion of a tuple purely in terms of such
functions producing functions. 
</p><p>

</p><p>For the example at hand, this means that we could just as well
re-interpret this a bit more superficially as a function taking a
float and a <code>float -&gt; float</code> function <code>f</code>, as
well as a position <code>x0</code>, and producing a
<code>float</code>, which is the corresponding numerical
<code>epsilon</code>-approximation to the gradient of <code>f</code>
at <code>x0</code>.
</p>

<p>Functions like these whose values are again functions are known as
"higher-order functions", and the number of arguments one may feed
into such a function generally is called the "arity" of that
function. However, that terminology may be considered as slightly
misleading, as the major distinction is whether a language does
support functions properly or not, and not on the maximal arity of a
function.
</p>

<p>This convenient way to deal with functions of multiple arguments as
functions mapping functions to functions comes at a small price,
however. First of all, there are no functions of zero arguments:
whenever a "function" does not really depend on an argument, the best
we can do is to make clear that we deal with an evaluation by using
<code>()</code> as a pseudo-argument, which of course is not used in
the computation. (How could it be anyway?) Second, we cannot really
have "variable argument" functions. That is, while in Common LISP,
there are functions that can be evaluated with an arbitrary number of
arguments such as <code>(gcd 60 80 100)</code>, something similar
cannot exist in OCaml. Usually, neither really is a noticeable problem.
</p>

<p>One should note that the vast majority of OCaml's library functions
use precisely this style to pass multiple arguments. The order of
arguments usually is that of most reasonable increasing
specialization. For example, <code>String.concat</code> takes as
arguments a string representing a "glue sequence" and a list of
strings, and produces a new string which is all the strings from the
list concatenated to one another, with the glue sequence placed
between any two adjacent strings. One most likely would want to use
this with a given glue sequence, such as <code>"\n"</code>, or
<code>":"</code>, or <code>", and "</code>, etc. on a variety of
string lists, so it seems appropriate to have the glue string as the
first argument.
</p>

<p>A very interesting library function which I wanted to point out is
"<code>Array.init</code>". This will map a length <code>N</code> and a
function mapping an index to the corresponding array element to an
array that consists of the values of that function for all indices
from <code>0</code> up to and including <code>N-1</code>:
</p>

<p>
<table border="1">
<tbody><tr><th><code>Array.init</code> example</th></tr>
<tr><td>
<pre><code>
# Array.init 10 (fun x -&gt; x*x);;
- : int array = [|0; 1; 4; 9; 16; 25; 36; 49; 64; 81|]
</code></pre>
</td></tr>
</tbody></table>
</p>

<p>Unfortunately, we cannot yet fully understand the type of this
function - just as that of quite some other library function. But with
a little bit of intuition on what they should do, this should not be a
problem: if we just use them, they will normally work as expected.
</p>

<p>One more notational detail: instead of <code>fun x -&gt; fun y -&gt;
body</code>, we may also for anonymous functions always write
<code>fun x y -&gt; body</code>, and likewise for higher orders of
arguments.
</p>


<p>Actually, all this really was cheating a bit. From this lesson, one
may get the impression that OCaml behaves in a much more systematic
way than it actually does. I want to warn my audience that there
indeed are quite some dark corners where things do not work out as
expected.
</p>

<h2>Some practical Notes</h2>

<h3>Interacting with OCaml</h3>

<p>Now that we got somewhat proficient with using OCaml from within an
Emacs shell, it is perhaps appropriate to point out some other ways to
interact with the OCaml interpreter that sometimes are more
useful. The most important one is Emacs' <code>caml-mode</code>. As
the audience may have noticed, whenever we load a <code>.ml</code>
file into an emacs buffer, this will activate Emacs' <code>caml</code>
major mode. As in every Emacs major mode, <code>Control-h m</code>
will give a short list of the most important mode-specific
keystrokes. What's interesting is that we can just use <code>Control-c
Control-e</code> whenever the cursor is somewhere on a lengthy OCaml
expression to send this expression to an OCaml sub-process attached to
emacs and see what it evaluates to. Emacs will even be so nice to
first start that ocaml process for us if necessary. Another useful
keystroke is <code>Control-c Control-h, which will show the part of
the OCaml documentation belonging to the function the cursor is
on. Also useful is <code>Control-c tab</code> for auto-completion.
</code></p>

<p>There is another Emacs mode for editing OCaml, the so-called
<code>tuareg-mode</code>, usually available as a separate
package. This claims to be more intelligent than bare
<code>caml-mode</code>, but to some extent this will also mean that it
will more easily show strange opinions on OCaml code.
</p>

<h3>The OCaml documentation</h3>

<p>Within Emacs, there are multiple ways to access the OCaml
documentation: either via <code>Control-c Control-h</code> in
<code>caml-mode</code>, or via the info system, via navigating to the
OCaml entry. (The Emacs info system can be opened with <code>Control-h
i</code>.) Another useful utility to navigate the OCaml documentation
is the <code>ocamlbrowser</code> program, as this can often also refer
directly to the implementation of a given function.
</p>

<hr>

<h2>Exercises</h2>

<p>
</p><ol>
<li><p>Define a function that counts the number of occurrences of a
given character (such as space, tab, newline, etc.) in a string.</p>
</li>

<li><p>Define a "scalar product" function on float arrays.</p>
<p>(Hint: this is structurally somewhat similar to the Horner's method
example in the last lesson: Here, we walk through two arrays,
remembering a partial sum in every step.)</p>
</li>

<li><p>Define a function that uses <code>Random.float</code> to
numerically determine the value of the integral of a <code>float -&gt;
float</code> function on a given interval. (Note:
<code>Random.float</code> might give random numbers of too low quality
for serious applications.) 
</p></li>

<li><p>Define a function that maps a nonnegative integer number
<code>N</code> to a floatingpoint unit matrix (in the form of an array
of arrays).
</p></li>

<li><p>Define a function that generalizes <code>Array.init</code> to
matrices: given a number of rows and columns, and a function mapping a
row and column number to the corresponding entry, it will produce a
matrix.
</p></li>

<li><p>Define a function that multiplies matrices of the forementioned
form.</p></li>

<li><p>Use <code>Array.init</code> and <code>String.concat</code> (and
maybe some other library functions which you will find in the
documentation of the <code>Array</code>, <code>List</code>, and
<code>String</code> modules) to define a plotting function that
behaves as follows:
</p>

<p>
<table border="1">
<tbody><tr><th><code>Array.init</code> example</th></tr>
<tr><td>
<pre><code>
# Printf.printf "%s" (plot_graph 40 (fun x -&gt; 5.0*.x*.x) (-2.0) (2.0));;
 -2.0000: ####################
 -1.8974: ##################
 -1.7949: ################
 -1.6923: ##############
 -1.5897: ############
 -1.4872: ###########
 -1.3846: #########
 -1.2821: ########
 -1.1795: ######
 -1.0769: #####
 -0.9744: ####
 -0.8718: ###
 -0.7692: ##
 -0.6667: ##
 -0.5641: #
 -0.4615: #
 -0.3590: 
 -0.2564: 
 -0.1538: 
 -0.0513: 
  0.0513: 
  0.1538: 
  0.2564: 
  0.3590: 
  0.4615: #
  0.5641: #
  0.6667: ##
  0.7692: ##
  0.8718: ###
  0.9744: ####
  1.0769: #####
  1.1795: ######
  1.2821: ########
  1.3846: #########
  1.4872: ###########
  1.5897: ############
  1.6923: ##############
  1.7949: ################
  1.8974: ##################
  2.0000: ####################
- : unit = ()
</code></pre>
</td></tr>
</tbody></table>
</p></li>

</ol>
<p></p>


<br><hr><br>
    <h1>Parametric Polymorphism and Structural Induction</h1>

<h2>Polymorphism - parametric and ad-hoc</h2>

<p>So far, we mostly dealt with functions that operate on numbers, or
larger structures built from numbers. There were a few occasions where
we almost stumbled across a higher level of abstraction which is
provided by all the languages of the ML family (and some more), and
indeed, all the examples have been chosen in such a way as to navigate
us around it. Not because the underlying concepts would be overly
complex or difficult to master, but rather because they deserve being
discussed separately.
</p>

<p>While it is practically never necessary, one may explicitly specify
the type of a variable rather than having it derived by OCaml's type
inference. That is, one could define:
</p>

<p>
<table border="1"><tbody><tr><th>Definitions with types specified explicitly</th></tr>
<tr><td><pre><code>
# let square (x:int) = x*x;;
val square : int -&gt; int = &lt;fun&gt;

(* Of course, this does not allow us to
   override the types derived by inference: *)

# let square (x:float) = x*x;;
Characters 24-25:
  let square (x:float) = x*x;;
                         ^
This expression has type float but is here used with type int

</code></pre></td></tr>
</tbody></table>

</p><p>
Sometimes, this is useful for providing more documentation in the code
(what is it actually that I am passing around?), and sometimes, it
helps discovering errors. Some cryptic error message may be resolved
by putting extra type specifiers into the code to discover where the
system's opinions on a type differ from ours. This may be especially
useful in conjunction with higher order functions and forgotten
arguments.
</p>

<p>
Actually, OCaml's close relative SML does not know separate sets of
operators for integer and floatingpoint arithmetics. Rather than
"<code>*</code>" and "<code>*.</code>", we only have "<code>*</code>",
which defaults to integer addition. Should we want floatingpoint
addition, we have to tell the system so by explicitly providing that
type, unless this can be derived by using <code>*</code> in a context
where one of the arguments is known to be floatingpoint anyway:
</p>

<p>
<table border="1"><tbody><tr><th>Explicitly specified types in SML</th></tr>
<tr><td><pre><code>
$ sml
Standard ML of New Jersey v110.42 [FLINT v1.5], October 16, 2002
- fun square_int x = x*x;;
val square_int = fn : int -&gt; int

- fun square_float (x:real) = x*x;;
val square_float = fn : real -&gt; real

- fun circle_area r = r*r*3.1415926;;
val circle_area = fn : real -&gt; real
</code></pre></td></tr>
</tbody></table>
</p>

<p>So, let us just define a function that swaps the entries of a pair
of integers:
</p>

<p>
<table border="1"><tbody><tr><th>Swapping a pair of integers</th></tr>
<tr><td><pre><code>
# let swap_int_pair_v1 ((a:int),(b:int)) = (b,a);;
val swap_int_pair_v1 : int * int -&gt; int * int = &lt;fun&gt;

# let swap_int_pair_v2 ((a,b):(int*int)) = (b,a);;
val swap_int_pair_v2 : int * int -&gt; int * int = &lt;fun&gt;

# let swap_int_pair_v3 (a,b) = ((b:int),(a:int));;
val swap_int_pair_v3 : int * int -&gt; int * int = &lt;fun&gt;

(* All of these definitions above are equivalent *)

# swap_pair_v1 (2,3);;
- : int * int = (3, 2)
</code></pre></td></tr>
</tbody></table>
</p>

<p>How do we define a function that swaps a pair of a string and a
boolean value?
</p>

<p>
<table border="1"><tbody><tr><th>Swapping a <code>string * bool</code> pair</th></tr>
<tr><td><pre><code>
# let swap_sb_pair ((a,b):(string * bool)) = (b,a);;
val swap_sb_pair : string * bool -&gt; bool * string = &lt;fun&gt;

# swap_sb_pair ("hello",true);;
- : bool * string = (true, "hello")
</code></pre></td></tr>
</tbody></table>
</p>

<p>Now, as the types tell us, we can use our integer pair swapping
functions only on pairs of integers, and our string/bool pair swapping
functions only on string/bool pairs. But what would we get if we just
made a definition like:
</p>

<p>
<table border="1"><tbody><tr><th>Swapping as a polymorphic function</th></tr>
<tr><td><pre><code>
# let swap_pair (a,b) = (b,a);;
val swap_pair : 'a * 'b -&gt; 'b * 'a = &lt;fun&gt;

# swap_pair (2,3);;
- : int * int = (3, 2)

# swap_pair (true, 5);;
- : int * bool = (5, true)

# swap_pair ((1,2),"three");;
- : string * (int * int) = ("three", (1, 2))
</code></pre></td></tr>
</tbody></table>
</p>

<p>If we ignore the type of this <code>swap_pair</code> function for
now, we at least note that if we make the definition without
explicitly referring to a type, then we get a variant that can be used
on all sorts of pairs. Actually, while there are pairs of many
different kinds, all we have to know in order to swap the entries is
that we are dealing with a pair, <em>any</em> pair. We do not really
have to look into the contents of that "container" data structure for
this particular operation: this indeed also holds from the machine
perspective: the very same sequence of machine instructions will swap
any pair. This idea of "I do not have to look into it, but know how to
do it just from the structure" has far-reaching consequences and goes
by the name of <em>parametric polymorphism</em>.
</p>

<p>OCaml has a funny way to express the type of a polymorphic
function: it will use so-called <code>type jokers</code>. In
mathematics, one conventionally uses Greek letters for type variables,
and this funny apostrophe-letter notation is supposed to be read in
that way, "<code>'a</code>" denoting "alpha", "<code>'b</code>"
denoting "beta", and so on. But actually, OCaml sticks to using the
Latin alphabet <code>'a</code> to <code>'z</code>, then
<code>'a1</code> to <code>'z1</code>, and so on, if there is need for
really really many jokers. Usually, there is not. Should we ever have
to specify a type joker of our own, we can use an arbitrary name that
is formed like a variable name, and prepend a "<code>'</code>"
character. So, we may use meaningful joker names such as
<code>'position</code> if we want to.
</p>

<p>Whenever an expression whose type is polymorphic (that is, contains
one or more type jokers) is used in some given context, OCaml checks
whether it is possible to specialize the jokers in an appropriate way
to match that context. If this succeeds, the original expression
behaves as if it had the specialized type right from the
beginning. Note that this check already occurs at compile time, not
only at run time, and this is the reason why the OCaml language is
called "statically typed".
</p>

<p>
There are some slight over-simplifications in that description of type
inference, and actually, it is a bit difficult to describe it in a
completely correct way without resorting to some mathematical
formalism. However, one should know that it is easy to get used to its
behaviour and develop an intuition for it by just playing around with
it for some time. In a certain sense, this is very "natural".
</p>

<p>We presumably just need a few more examples:
</p>

<p>
<table border="1"><tbody><tr><th>More examples for parametric polymorphism</th></tr>
<tr><td><pre><code>
# let make_twin_pair x = (x,x);;
val make_twin_pair : 'a -&gt; 'a * 'a = &lt;fun&gt;

# let make_triplet_aab a b = (a,a,b);;
val make_triplet_aab : 'a -&gt; 'b -&gt; 'a * 'a * 'b = &lt;fun&gt;

# let rotate_triplet (a,b,c) = (c,a,b);;
val rotate_triplet : 'a * 'b * 'c -&gt; 'c * 'a * 'b = &lt;fun&gt;

# let make_triplet_baa a b = rotate_triplet (make_triplet_aab a b);;
val make_triplet_baa : 'a -&gt; 'b -&gt; 'b * 'a * 'a = &lt;fun&gt;

# let left_of_pair (p,q) = p;;
val left_of_pair : 'a * 'b -&gt; 'a = &lt;fun&gt;

# let identity x = x;;
val identity : 'a -&gt; 'a = &lt;fun&gt;

# let apply_twice f x = f(f x);;
val apply_twice : ('a -&gt; 'a) -&gt; 'a -&gt; 'a = &lt;fun&gt;

# apply_twice (fun x -&gt; x+2) 6;;
- : int = 10

# apply_twice (fun x -&gt; x*.8.0) 6.0;;
- : float = 384.

# apply_twice (fun (p,q) -&gt; (p,q+10)) (true,5);;
- : bool * int = (true, 25)

# let compose f g = fun x -&gt; f (g x);;
val compose : ('a -&gt; 'b) -&gt; ('c -&gt; 'a) -&gt; 'c -&gt; 'b = &lt;fun&gt;

# let constantly x = fun y -&gt; x;;
val constantly : 'a -&gt; 'b -&gt; 'a = &lt;fun&gt;

# let c3 = constantly 3 in c3 100;;
- : int = 3

(* Clearly, the empty list has to be polymorphic as well *)

# [];;
- : 'a list = []

(* Many of the functions from the standard library are polymorphic *)

# List.length;;
- : 'a list -&gt; int = &lt;fun&gt;

# List.length [1;10;100];;
- : int = 3

# List.length [0.5;0.7];;
- : int = 2

# Array.make;;
- : int -&gt; 'a -&gt; 'a array = &lt;fun&gt;

# Array.make 5 true;;
- : bool array = [|true; true; true; true; true|]

# Array.make 7 "dwarf";;
- : string array =
[|"dwarf"; "dwarf"; "dwarf"; "dwarf"; "dwarf"; "dwarf"; "dwarf"|]

(* This especially holds for most of the really useful tools:
   They are so useful because they express an abstract idea that
   can be applied in a broad class of situations.
*)

# Array.map;;
- : ('a -&gt; 'b) -&gt; 'a array -&gt; 'b array = &lt;fun&gt;

# Array.map (fun x -&gt; x*2) [|1;2;3;4;5|];;
- : int array = [|2; 4; 6; 8; 10|]

# Array.map (fun x -&gt; (x,x)) [|1;2;3;4;5|];;
- : (int * int) array = [|(1, 1); (2, 2); (3, 3); (4, 4); (5, 5)|]

# let array_add_2 = Array.map (fun x -&gt; x+2) in
   (array_add_2,array_add_2 [|1;2;3;4;5|]);;
- : (int array -&gt; int array) * int array = (&lt;fun&gt;, [|3; 4; 5; 6; 7|])

</code></pre></td></tr>
</tbody></table>
</p>

<p>To make things a bit more complicated, there are some functions and
operators in OCaml which appear in the guise of being parametrically
polymorphic, but in fact are not - far from it. The most prominent
examples are the comparison operators: evidently, just comparing two
integers should be in some sense much simpler than lexicographically
comparing complex composite values. So, OCaml is cheating a bit
here. Even worse, it pretends that something like equality comparisons
existed for functions. It is important to know about these cases of
mundane ad-hoc polymorphism in the guise of parametric
polymorphism. Actually, the examples are quite few, and the
distinction does not matter too much in most applications, but it is
important to know it's there.
</p>

<p>
<table border="1"><tbody><tr><th>Examples of "Fake" parametric polymorphism in OCaml</th></tr>
<tr><td><pre><code>
# let is_smaller a b = a &lt; b;;
val is_smaller : 'a -&gt; 'a -&gt; bool = &lt;fun&gt;

# let is_equal a b =  a=b;;
val is_equal : 'a -&gt; 'a -&gt; bool = &lt;fun&gt;

# is_equal (fun x -&gt; x*2+2) (fun x -&gt; (x+1)*2);;
Exception: Invalid_argument "equal: functional value".

(* Note that this raises an exception at run time while actually,
   the notion of "equality" cannot naturally be extended to functions,
   and hence, equality cannot be parametrically polymorphic. Still,
   OCaml claims so *)

(* Some other exotic functions are even worse sinners, such as: *)

# output_value;;
- : out_channel -&gt; 'a -&gt; unit = &lt;fun&gt;
# stdout;;
- : out_channel = <abstr>
# output_value stdout (2,3);;
\204\225^@^@^@^C^@^@^@^A^@^@^@^C^@^@^@^C&nbsp;BC- : unit = ()

(* This is for the serialization of values.
   We may even crash OCaml if we are careless with that: *)

# Marshal.to_string (2,3) [];;
- : string =
"\132\149\166\190\000\000\000\003\000\000\000\001\000\000\000\003\000\000\000\003\160BC"

# let x = Marshal.to_string (2,3) [] in
   let (y:(bool*string)) = Marshal.from_string x 0
   in y;;

Process inferior-caml segmentation fault
</abstr></code></pre></td></tr>
</tbody></table>
</p>

<p>It is interesting to see how polymorphism interacts with
abstracting out some sub-functionality from a given function:
</p>

<p>
<table border="1"><tbody><tr><th>Why parametric polymorphism is important - an Example</th></tr>
<tr><td><pre><code>
let pointwise_add f g = fun x -&gt; (f x) + (g x);;

let pointwise_multiply f g = fun x -&gt; (f x) * (g x);;

let pointwise_max f g = fun x -&gt; max (f x) (g x);;

let f0 = pointwise_max (fun x -&gt; 0) (fun x -&gt; 10-x*x);;

val f0 : int -&gt; int = &lt;fun&gt;

# f0 3;;
- : int = 1

# f0 2;;
- : int = 6

# f0 5;;
- : int = 0

(* Now, pointwise this and pointwise that is always almost the same,
so we may just extract that out: *)

# let pointwise c f g x = c (f x) (g x);;
val pointwise :
 ('a -&gt; 'b -&gt; 'c) -&gt; ('d -&gt; 'a) -&gt; ('d -&gt; 'b) -&gt; 'd -&gt; 'c = &lt;fun&gt;

(* That type actually is quite a bit complicated. Let us re-write it
   in an equivalent form. We may always re-name type jokers, so
   we do it like this:

   'a =&gt; 'fx,  'b =&gt; 'gx, 'c =&gt; 'fx_c_gx, 'd =&gt; 'x. 

   Then, this reads:

   ('fx -&gt; 'gx -&gt; 'fx_c_gx) -&gt; ('x -&gt; 'fx) -&gt; ('x -&gt; 'gx) -&gt; 'x -&gt; fx_c_gx

*)

# let test_pointwise = pointwise (fun x y -&gt; x+y) (fun x -&gt; x*1000) (fun x -&gt; x*10);;
val test_pointwise : int -&gt; int = &lt;fun&gt;

# test_pointwise 3;;
- : int = 3030

# let pointwise_add_v2 = pointwise (fun x y -&gt; x+y);;
val pointwise_add_v2 : ('_a -&gt; int) -&gt; ('_a -&gt; int) -&gt; '_a -&gt; int = &lt;fun&gt;

(* Pay close attention to the strange '_a type joker.
   Whenever something like this shows up, bad things are about to happen.
   This usually occurs when we globally define a function by partial
   application of a polymorphic function. If we give that function
   its required extra parameters, which we just pass on to the right
   hand side, everything is fine:
*)

# let pointwise_add_v3 f g x= pointwise (fun x y -&gt; x+y) f g x;;
val pointwise_add_v3 : ('a -&gt; int) -&gt; ('a -&gt; int) -&gt; 'a -&gt; int = &lt;fun&gt;
</code></pre></td></tr>
</tbody></table>
</p>

<p>Note that by looking at what's common among "pointwise sum",
"pointwise product", and other similar functions, and abstracting out
that which is special for every single case, we were able to find a
function that just represents the abstract idea behind "doing
something pointwise". The definition of the function
<code>pointwise</code> is interesting: it does not involve any numbers
or tuples or anything else - just functions. All there is to it is
which function's value is passed on into which other function, and how
values are distributed between functions. Such a function is called a
<em>combinator</em>. There is quite a lot of mathematical theory on
combinators. Two other (much simpler) combinators, which we already
have seen in this lecture, are <code>identity</code> and
<code>constantly</code>, and indeed, one can have a lot of fun with
those three only.
</p>

<p>In a certain sense, one may say that polymorphism just kind of
solves the same problem that C++ claims to solve via templates. At
least, pretty much everything that is in the C++ Standard Template
Library (STL) is just parametrically polymorphic. However, the C++
approach does come with a few serious flaws. To see this, let us look
at the following example:
</p>

<p>
<table border="1">
<tbody><tr><th>Parametric Polymorphism and C++</th></tr>
<tr><td><pre><code>
// File pair.cpp

#include &lt;iostream&gt;

using namespace std;

template&lt;class T1,class T2&gt; pair&lt;T2,T1&gt; swap(pair&lt;T1,T2&gt; p)
{
  return pair&lt;T2,T1&gt;::pair(p.second,p.first);
}

int main()
{
  pair&lt;int*,int*&gt; pp1 = pair&lt;int*,int*&gt;::pair(0,0);

  pair&lt;int*,int*&gt; spp1 = swap(pp1);

  cout &lt;&lt;"(" &lt;&lt; (unsigned long)(pp1.first) &lt;&lt; ", "
             &lt;&lt; (unsigned long)(pp1.second) &lt;&lt; ")" &lt;&lt; "\n";

  cout &lt;&lt;"(" &lt;&lt; (unsigned long)(spp1.first) &lt;&lt; ", "
             &lt;&lt; (unsigned long)(spp1.second) &lt;&lt; ")" &lt;&lt; "\n";

  pair&lt;char*,char*&gt; pp2 = pair&lt;char*,char*&gt;::pair(0,0);
  pair&lt;char*,char*&gt; spp2 = swap(pp2);

  cout &lt;&lt;"(" &lt;&lt; (unsigned long)(pp2.first) &lt;&lt; ", "
             &lt;&lt; (unsigned long)(pp2.second) &lt;&lt; ")" &lt;&lt; "\n";

  cout &lt;&lt;"(" &lt;&lt; (unsigned long)(spp2.first) &lt;&lt; ", "
             &lt;&lt; (unsigned long)(spp2.second) &lt;&lt; ")" &lt;&lt; "\n";


  return 0;
}
</code></pre></td></tr>
<tr><th>Analyzing the binary</th></tr>
<tr><td>
<pre><code>
$ g++ -O3 -o pair pair.cpp

$ ls -la pair
-rwxr-xr-x  1 tf tf 14025 Dec 14 02:26 pair

$ ./pair
(0, 0)
(0, 0)
(0, 0)
(0, 0)

$ nm pair|grep swap
08048920 W _Z4swapIPcS0_ESt4pairIT0_T_ES1_IS3_S2_E
08048950 W _Z4swapIPiS0_ESt4pairIT0_T_ES1_IS3_S2_E

$ objdump -d pair

pair:     file format elf32-i386

(...)

08048920 &lt;_Z4swapIPcS0_ESt4pairIT0_T_ES1_IS3_S2_E&gt;:
 8048920:	55                   	push   %ebp
 8048921:	89 e5                	mov    %esp,%ebp
 8048923:	83 ec 08             	sub    $0x8,%esp
 8048926:	8b 4d 10             	mov    0x10(%ebp),%ecx
 8048929:	8b 45 08             	mov    0x8(%ebp),%eax
 804892c:	8b 55 0c             	mov    0xc(%ebp),%edx
 804892f:	89 4d fc             	mov    %ecx,0xfffffffc(%ebp)
 8048932:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
 8048935:	89 55 f8             	mov    %edx,0xfffffff8(%ebp)
 8048938:	89 08                	mov    %ecx,(%eax)
 804893a:	8b 4d f8             	mov    0xfffffff8(%ebp),%ecx
 804893d:	89 48 04             	mov    %ecx,0x4(%eax)
 8048940:	89 ec                	mov    %ebp,%esp
 8048942:	5d                   	pop    %ebp
 8048943:	c2 04 00             	ret    $0x4
 8048946:	90                   	nop    
 8048947:	90                   	nop    
 8048948:	90                   	nop    
 8048949:	90                   	nop    
 804894a:	90                   	nop    
 804894b:	90                   	nop    
 804894c:	90                   	nop    
 804894d:	90                   	nop    
 804894e:	90                   	nop    
 804894f:	90                   	nop    

08048950 &lt;_Z4swapIPiS0_ESt4pairIT0_T_ES1_IS3_S2_E&gt;:
 8048950:	55                   	push   %ebp
 8048951:	89 e5                	mov    %esp,%ebp
 8048953:	83 ec 08             	sub    $0x8,%esp
 8048956:	8b 4d 10             	mov    0x10(%ebp),%ecx
 8048959:	8b 45 08             	mov    0x8(%ebp),%eax
 804895c:	8b 55 0c             	mov    0xc(%ebp),%edx
 804895f:	89 4d fc             	mov    %ecx,0xfffffffc(%ebp)
 8048962:	8b 4d fc             	mov    0xfffffffc(%ebp),%ecx
 8048965:	89 55 f8             	mov    %edx,0xfffffff8(%ebp)
 8048968:	89 08                	mov    %ecx,(%eax)
 804896a:	8b 4d f8             	mov    0xfffffff8(%ebp),%ecx
 804896d:	89 48 04             	mov    %ecx,0x4(%eax)
 8048970:	89 ec                	mov    %ebp,%esp
 8048972:	5d                   	pop    %ebp
 8048973:	c2 04 00             	ret    $0x4
 8048976:	90                   	nop    
 8048977:	90                   	nop    
 8048978:	90                   	nop    
 8048979:	90                   	nop    
 804897a:	90                   	nop    
 804897b:	90                   	nop    
 804897c:	90                   	nop    
 804897d:	90                   	nop    
 804897e:	90                   	nop    
 804897f:	90                   	nop    

(...)

$ 
</code></pre>
</td></tr>
</tbody></table>
</p>

<p>If we compile this and analyze the binary with utilities such as
<code>nm</code> and <code>objdump</code>, we see that the compiler
indeed did generate two different swap functions. However, the code is
precisely the same, even up to the number of padding NOP instructions
in both cases! So, indeed, at least the GNU C++ compiler (maybe others
as well) has the potential to generate great code bloat when it comes
to expanding templates. Actually, this was even much much worse with
earlier versions of C++ compilers, where template instantiation meant
that <em>every</em> single method and function that was defined for
that particular template was expanded into code - whether it was
actually used or not. Even nowadays, one can still find references to
the claim that all complaints about C++ templates generating code
bloat are out-dated, as C++ compilers will no longer compile "dead
methods" that never get called into the binary. That may well be so by
now, but still, C++ templates have a tendency to introduce quite ugly
unnecessary code bloat through repetitive expansion: there really is
no difference between swapping a pair of pointers to integers, or
swapping a pair of pointers to whatever else, so there is no reason at
all why the same code should be generated multiple times. (Actually,
having the same code more than once is not especially nice to
instruction caches and therefore CPU memory bandwidth, as well as
dynamic branch prediction.) Of course, some template authors are aware
of this problem and design their templates in such a way that the
parametrically polymorphic aspects are only compiled once, and every
instantiation of that template is just a front-end to the really
parametric code. But this inevitably requires some ugly casts, which
templates were designed to prevent. So, if we see it that way, then
templates split the C++ programmers into two classes: template users
which never are supposed to use casts, and proficient template
implementors, who may and must use casts to deal with parametric
polymorphism. A very unsatisfactory state of affairs, actually.
</p>

<p>To be fair, the C++ template idea is somewhat more general. If we
swapped a pair of a pointer and something larger, the code would be
different, as the pair container would normally truly contain a copy
of its entries, and not just reference them. While C++ templates are
used in perhaps the overwhelming majority of cases to deal with
parametric polymorphism, they are general enough to also handle ad-hoc
polymorphism. Whether this actually is a good thing, in particular as
this kind of prevents us to handle parametric polymorphism in a really
nice and elegant way in C++, is up to the audience to decide.
</p>

<h2>Structural Induction</h2>

<p>One of the basic ideas of object-oriented programming is that
objects are entities which satisfy certain contracts that are
specified through their classes, which themselves may form a hierarchy
of abstraction built on more generic contracts, base classes. Looking
in the opposite direction, one can always specialize and subclass a
given class.
</p>

<p>So, from the object-oriented point of view, it would be natural to
treat the natural numbers, that is the numbers <code>1,2,...</code>
without any artificial and arbitrary machine limit - as objects in a
class which we may call, say, <code>NaturalNumbers</code>.
</p>

<p>However, this approach would be conceptually flawed. The reason is
that through subclassing, one could always introduce a new class of
entities which technically speaking also are
<code>NaruralNumbers</code>, through a <code>is-a</code> inheritance
relationship, but which are not in the numbers
<code>1,2,3,...</code>. Mathematicians like to define the natural
numbers as follows:
</p>

<p>
</p><ol>
<li><p>Zero is a natural number.</p></li>

<li><p>Every natural number has a successor, which again is a natural number.</p></li>

<li><p>Zero is not the successor of any natural number.</p></li>

<li><p>If two numbers have the same successor, they are the same.</p></li>

<li><p>Nothing else is a natural number. So, the natural numbers are the 
"smallest" structure that satisfies the above rules.
</p></li>

</ol>
<p></p>

<p>
The important point here is the <em>"nothing else"</em> statement. In
fact, this is equivalent to the principle of induction over natural
numbers. So, if we drop that statement, as we inevitably would do by
modeling natural numbers in a class, we lose the power to do stringent
reasoning over the natural numbers.
</p>

<p>This may be even clearer with boolean values: there just are two of
them: <code>true</code> and <code>false</code>. No one would ever
think about sub-classing a <code>Boolean</code> class in order to
implement extensions to boolean values, say <code>most likely</code>,
<code>presumably</code>, <code>presumably not</code> and such. All
hell would break loose if values like <code>presumably</code> crept up
in a program expecting a boolean value to be either <code>true</code>
or <code>false</code>.
</p>

<p>So, there is a conceptual difference between the idea of a class,
which roughly says: "I do not really know in detail what it is that I
am dealing with, but it promised me to provide a particular interface,
and as long as it does this, I am fine", and the idea of mathematical
exclusive definitions which are made for stringent reasoning over all
possible cases. Each has its place in this world, and if possible, one
should perhaps not try to use the one as a substitute for the
other. If a system supports exclusive definitions, it usually can also
check automatically whether the case analysis is complete; when using
classes for the same task, this certainly cannot be possible, as they
are built for extensibility: they are abstract contracts which may be
satisfied by a lot of things, and we may not know all the
possibilities from the beginning. On the other hand, when using
exclusive definitions instead of classes, we may end up in a situation
where we eventually find out that actually, we should consider more
cases than the ones we provided initially. But then, we would have to
make changes all over the place: wherever we go through all the
possibilities in our code, we have to add a further one.
</p>

<p>So much about the theory. Now, let us see how this actually looks
like in OCaml.
</p>

<p>
<table border="1"><tbody><tr><th>Defining new types</th></tr>
<tr><td><pre><code>
(* A poker example *)

# type suit = Clubs | Diamonds | Hearts | Spades;;
type suit = Clubs | Diamonds | Hearts | Spades

# type color = Red | Black;;
type color = Red | Black

# 
let suit_color_v1 s =
  if s = Clubs || s = Spades then Black
  else Red
;;

val suit_color_v1 : suit -&gt; color = &lt;fun&gt;

#   
let suit_color_v2 s =
  match s with
  | Clubs -&gt; Black
  | Spades -&gt; Black
  | Diamonds -&gt; Red
  | Hearts -&gt; Red
;;

val suit_color_v2 : suit -&gt; color = &lt;fun&gt;

# 
let suit_color_v3 s =
  match s with
  | Clubs -&gt; Black
  | Spades -&gt; Black
  | Diamonds -&gt; Red
;;

          Characters 26-97:
Warning: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Hearts
  ..match s with
    | Clubs -&gt; Black
    | Spades -&gt; Black
    | Diamonds -&gt; Red
val suit_color_v3 : suit -&gt; color = &lt;fun&gt;

#
let suit_color_v4 s =
  match s with
  | Clubs -&gt; Black
  | Spades -&gt; Black
  | x -&gt; Red
;;

val suit_color_v4 : suit -&gt; color = &lt;fun&gt;
</code></pre></td></tr>
</tbody></table>
</p>

<p>First, we introduce a so-called "variant" type
"<code>suit</code>", which has four constructors: <code>Clubs</code>,
<code>Diamonds</code>, <code>Hearts</code>, <code>Spades</code>. One
may think of this as a four-valued equivalent of the two-valued
<code>bool</code> type, which has "constructors" <code>true</code> and
<code>false</code>. As a general rule, the names of all constructors
must begin with an uppercase letter.
</p>

<p>The <code>suit</code> data type is mostly equivalent to a C-style
<code>enum</code>, as those constructors just represent four different
values. The major difference to an <code>enum</code> is type safety: a
C <code>enum</code> value is just a number. Our constructors cannot be
accidentally confused with numbers. So, we may then proceed likewise
to define a cards' color, which is <code>Red</code> or
<code>Black</code>. There is an obvious function mapping a card's suit
to its color. We can either define this the old-fashioned way using
<code>if ... then ... else</code>, or we can instead use the matching
operator, which allows us to just list all the cases. Conceptually,
this seems to be similar to a C <code>switch/case</code>, but
actually, this will turn out to be far more powerful. The syntax may
require some getting used to, but is quite suggestive: we just list
all the cases, one after another, with the pattern at the left hand
side. Note that we may also use variables at the left hand side. Then,
the corresponding right hand side case is used when the left hand side
structure can be made to match the argument of <code>match</code> by
binding variables appropriately. Here, this is quite trivial in the
<code>suit_color_v4</code> example: we just use a variable to match
"any remaining cases". Note that <code>x</code> does not appear at the
right hand side. With more complicated patterns, it may. There is a
convention to use the special name "<code>_</code>" (underscore) for
such "don't care" variables.
</p>

<p>Constructors play the role of "hooks" that hold data and allow us
to define structural patterns on the left hand side of a matching
rule. This gets much more interesting with constructors that carry
arguments:
</p>

<p>
<table border="1"><tbody><tr><th>Constructors with arguments</th></tr>
<tr><td><pre><code>
type card =
    Joker 
  | Ace   of suit
  | King  of suit
  | Queen of suit
  | Jack  of suit
  | Number of suit * int
;;

type hand = card list;;

(* This is just a type alias. "hand" and "card list"
   can be used in a fully interchangeable way. *)

let some_hand=[Ace Spades;
	       Queen Hearts;
	       Number (Hearts,5); 
	       Number (Clubs,2);
	       Joker
	     ];;

(* Defining a function on such a type *)

let blackjack_value card =
  match card with
  | Joker -&gt; failwith "Not used in blackjack!"
  | Ace _ -&gt; 11 (* or 1, but let's ignore this for now *)
  | Number (_,n) -&gt; n
  | _ -&gt; 10 (* King, Queen, Jack *)
;;
</code></pre></td></tr>
</tbody></table>
</p>

<p>Note how the structured value to the left of a matching rule
provides a pattern against which the argument to <code>match</code> is
checked. When more than one rule could match, the first one is
taken. We also see this here with the default rule. If we moved this
last line to the first line, every card's value would be
"<code>10</code>".
</p>

<p>Things get even more interesting with recursive type
definitions. We may use the type which we are defining right now
inside the argument type definition of a constructor to define
hierarchically structured values. This looks as follows:
</p>

<p>
<table border="1"><tbody><tr><th>Recursive variant types</th></tr>
<tr><td><pre><code>
type boolean_term =
 | Bool_Constant of bool
 | Bool_Var of string
 | Bool_And of boolean_term * boolean_term
 | Bool_Or of boolean_term * boolean_term
;;

let some_term =
  Bool_And(Bool_Constant true,
	   Bool_Or (Bool_Var "x",
		    Bool_And(Bool_Var "y",Bool_Var "z")));;

(* Defining a function on such terms: *)

let rec term_contains_variable_with_name v bterm =
  match bterm with
  | Bool_Constant _ -&gt; false
  | Bool_Var x -&gt; x=v
  | Bool_And (t1,t2) -&gt;
      term_contains_variable_with_name v t1 ||
      term_contains_variable_with_name v t2
  | Bool_Or (t1,t2) -&gt;
      term_contains_variable_with_name v t1 ||
      term_contains_variable_with_name v t2
;;

(* Example:
# term_contains_variable_with_name "z" some_term;;
- : bool = true

# term_contains_variable_with_name "w" some_term;;
- : bool = false
*)
</code></pre></td></tr>
</tbody></table>
</p>

<p>Furthermore, variant types may be polymorphically parametric. We
already have encountered parametric recursive types: the list is the
prime example. Let us just re-invent the list with an own definition
to see how polymorphic variant types are introduced and how they
behave.
</p>

<p>
<table border="1"><tbody><tr><th>Polymorphic recursive variant types</th></tr>
<tr><td><pre><code>
type 'a mylist =
  | Empty
  | Head_Tail of 'a * ('a mylist)
;;

let some_mylist = Head_Tail (10,Head_Tail(20, Head_Tail(30,Empty)));;

(* A naive definition of a length function: *)

let rec len_mylist li =
  match li with
  | Empty -&gt; 0
  | Head_Tail (_,tl) -&gt; 1 + len_mylist tl
;;

(*
The type is:

- : 'a mylist -&gt; int = &lt;fun&gt;

Example:

# len_mylist some_mylist;;
- : int = 3
*)

(* Variant types also can be polymorphic in more than one way: *)

type ('a,'b) mytree =
    Leaf of 'a
  | Fruit of 'b
  | Branch of ('a,'b) mytree * ('a,'b) mytree
;;

let some_tree = Branch (Leaf 5, Fruit "xyz");;
(* This is:
val some_tree : (int, string) mytree = Branch (Leaf 5, Fruit "xyz")
*)
</code></pre></td></tr>
</tbody></table>
</p>

<h2>Records</h2>

<p>Another kind of data structure provided by OCaml which will become
very important in programs that are less mathematically inclined, but
have to deal with a lot of bookkeeping, is the record. This is roughly
equivalent to a C struct. Actually, with all the background we have
developed so far, there is not too much to be said about records. They
are defined and anonymously constructed as follows:
</p>

<p>
<table border="1"><tbody><tr><th>Records</th></tr>
<tr><td><pre><code>

type file =
    {name: string;
     access_flags: int;
     size: int;
     creation_time: int;
   };;

let some_file=
  {name="/etc/passwd";
   access_flags= 6*8*8 + 4*8 + 4; (* mode 644 *)
   size=1733;
   creation_time=0;
 };;

let s = some_file.size;;

type 'num arithmetics =
    {addition: 'num -&gt; 'num -&gt; 'num;
     multiplication: 'num -&gt; 'num -&gt; 'num;
     zero: 'num;
    }
;;

let bool_arith =
  {addition=(fun a b -&gt; a || b);
   multiplication=(fun a b -&gt; a &amp;&amp; b);
   zero=false;
 }
;;

let generic_scalar_product arith v1 v2 =
  let add = arith.addition in
  let mult = arith.multiplication in
  let zero = arith.zero in
  let len = Array.length v1 in
  if Array.length v2 &lt;&gt; len
  then failwith "Scalar product arrays must have same length!"
  else
    let rec sum_up sum_now pos =
      if pos = len then sum_now
      else let contrib = mult v1.(pos) v2.(pos) in
      sum_up (add contrib sum_now) (1+pos)
    in sum_up zero 0
;;

(*
This has type:

# val generic_scalar_product :
  'a arithmetics -&gt; 'a array -&gt; 'a array -&gt; 'a = &lt;fun&gt;

Actually, one would in practice usually prefer to
use the OCaml module system to get such functionality.
(Not discussed here.)
*)

generic_scalar_product bool_arith [|false;false;true|] [|false;true;false|];;
(* Gives "false" *)
</code></pre></td></tr>
</tbody></table>
</p>

<p>One should know about records that it is not permitted to have two
records defined in the same OCaml module which both have an entry with
the same name. This is quite unfortunate, and considered a pretty
stupid design bug of OCaml. Again, the reason is type inference, the
idea being that by just mentioning a single slot, the system should be
able to derive the type of the record.
</p>

<p>This concludes our discussion of data types in OCaml for this crash
course. Beginners usually need some practice to get used to
programming by pattern matching and case analysis. The exercises will
give ample opportunity for this.
</p>

<h2>Exercises</h2>

<p>
</p><ol>

<li><p>Define a variant type that represents a binary tree with a
value in every node.
</p>
</li>

<li><p>Define a function on the tree of the previous exercise that
returns its maximal depth.
</p>
</li>

<li><p>Define another function on this tree data structure that
collects the data values of all its nodes in a list.
</p>
</li>

<li>
<p>Define a function "<code>scan_list property list
what_if_not_found</code>" that scans a list for the first element on
which the function <code>property</code> is true, producing the value
<code>what_if_not_found</code> if no such element was found, test it,
and explain its type. Hint: use <code>ocamlbrowser</code> to look up
the definitions of <code>List.hd</code> and <code>List.tl</code> to
see how to use the list constructor "<code>::</code>" in pattern
matching.
</p>
</li>

<li>
<p>Define a function <code>eval_bterm term var_occupations</code> that
takes as arguments a <code>boolean_term</code> (as defined in the
text) as well as a list of pairs
<code>(variable_name,boolean_value)</code> of variable occupations,
and produces the boolean value (either <code>true</code> or
<code>false</code>) represented by this term which one gets by
substituting the variables with the values provided and reducing
afterwards.
</p>
</li>

<li><p>Define a function that takes as argument a list and produces a
pair of two lists, one containing the elements with even index in the
original list, the other one containing the elements with odd
index.</p>
</li>

<li><p>Look up the documentation of <code>List.map</code> and
<code>List.map2</code> and define a corresponding function
<code>array_map2</code> on arrays. (Hint: use <code>Array.init</code>)
</p>
</li>

<li><p>Define a function that takes as arguments a comparison function
as well as two lists, which can be assumed to be ordered with respect
to this comparison function, and produces a joint list containing all
the elements from both lists, also ordered with respect to the comparison function.
</p>
</li>

<li><p>Use the functions from the last two exercises to define your
own list sorting function.
</p>
</li>

<li><p>Define a function that reverses a list. Note: if the runtime of
your function scales quadratically with the length of the list, you
missed something obvious. Hint: What do you get if you take a stack of
cards and repetitively remove the topmost card and add it to another
stack?
</p>
</li>

<li><p>Define a function mapping a <code>boolean_term</code> to a
<code>string list</code> of all the variable names in it, without
repetition.
</p>
</li>

<li><p>Define a function that tries to find an occupation of variables
for which a given <code>boolean_term</code> is true. Note: this is not
required to be overly efficient. (Again, there would be an entire
mathematical theory behind that!)
</p>
</li>


<li><p>(Difficult!) As briefly mentioned, there is an entire
mathematical theory behind combinators. Show that it is possible to
complete the following definition in such a way that the result
behaves just like the composition function, where the expression that
goes in the place of <code>???</code> is built exclusively out of the
functions <code>pointwise</code>, <code>identity</code>, and
<code>constantly</code> (as well as parentheses, of course):
</p>

<p>
<table border="1"><tbody><tr><th>Some Combinatory Logic</th></tr>
<tr><td><pre><code>
let my_composition f g = ??? f g;;
</code></pre></td></tr>
</tbody></table>
</p>
</li>

</ol>
<p></p>

<br><hr><br>
    <h1>Imperative Features, and some Cleanup</h1>

<p>So far, we were mostly concerned with the functional aspects of
Objective Caml. Now, when interacting with the real world, it is in a
certain sense inevitable to deal with state changes, input and output,
and similar issues. We will also use the opportunity to do a bit of
cleanup work and talk about other features that turn out to be very
useful for real world applications, such as exceptions and exception
handling, named and optional arguments, and more. Indeed, we by now
know - but actually for less than ten years - that there indeed is a
way to formalize all these "dirty" aspects of programming in a purely
functional way even though the principle that same expressions have
same values and may be substituted at will seems to be violated
badly. Haskell is the prime example for a language where everything,
including I/O, has to be done in a purely functional way.
</p>

<p>But as we are not so much interested in on-going programming
language research, but rather in getting some real work done, we do
not have to care about such lofty thoughts. Presumably everybody in
the audience has had some prior exposure to programming in one of the
widespread languages other than Haskell which more or less all "get it
quite wrong". So, we will not spend any time discussing the model of a
register machine with random access memory here, but take for granted
that that is known.
</p>

<h2>Iteration through Tail Recursion</h2>

<p>There are various forms of iteration. In its purest form, it
appears in the guise of inductive mathematical definitions. Let us
look at one such definition which we have seen in the last lesson (at
least, something very very similar to it): taking the length of a
list:
</p>

<p>
<table border="1"><tbody><tr><th>The naive recursive form of a list length function</th></tr>
<tr><td><pre><code>
let rec my_list_len_v1 li =
  match li with
  | [] -&gt; 0
  | (head::tail) -&gt; 1+my_list_len_v1 tail
;;
</code></pre></td></tr>
</tbody></table>
</p>

<p>This may seem to be the obvious way to define list length. However,
there is a slight problem, which can be seen here:
</p>

<p>
<table border="1"><tbody><tr><th>Recursion depth limits</th></tr>
<tr><td><pre><code>
# let very_long_list = Array.to_list (Array.make 1000000 0);;

val very_long_list : int list =
  [0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
   0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
   0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
   ...]
#   my_list_len_v1 very_long_list;;
Stack overflow during evaluation (looping recursion?).

(* Note that the built-in list length function can handle this: *)
# List.length very_long_list;;
- : int = 1000000
</code></pre></td></tr>
</tbody></table>
</p>

<p>Of course, it is quite ridiculous that such a simple function as
taking a list's length should cease to work when the list gets too
long! Let me first demonstrate that indeed, there are other ways how
to define a list length function that does not suffer from this problem,
and discuss what's going on afterwards:
</p>

<p>
<table border="1"><tbody><tr><th>list length function: an improved implementation</th></tr>
<tr><td><pre><code>
let my_list_len_v2 li =
  let rec scan len_scanned_part rest_list =
    match rest_list with
    | [] -&gt; len_scanned_part
    | (_::rest_of_rest) -&gt; scan (1+len_scanned_part) rest_of_rest
  in scan 0 li
;;

(* Example:
# my_list_len_v2 very_long_list;;
- : int = 1000000
*)
</code></pre></td></tr>
</tbody></table>
</p>

<p>There are various ways how to understand the difference between
these implementations. On the purely conceptual level, it is
interesting to compare what the first and second variants do, step by
step.
</p>

<p>
<table border="1"><tbody><tr><th>How <code>my_list_len_v1</code> and <code>my_list_len_v2</code> work</th></tr>
<tr><td><pre><code>
my_list_len_v1 [10,20,30,40] 

=&gt; 1 + (my_list_len_v1 [20,30,40])
=&gt; 1 + (1 + (my_list_len_v1 [30,40]))
=&gt; 1 + (1 + (1 + (my_list_len_v1 [40])))
=&gt; 1 + (1 + (1 + (1 + (my_list_len_v1 []))))
=&gt; 1 + (1 + (1 + (1 + 0)))
=&gt; 1 + (1 + (1 + 1))
=&gt; 1 + (1 + 2)
=&gt; 1 + 3
=&gt; 4


my_list_len_v2 [10,20,30,40]

=&gt; scan 0 [10,20,30,40]
=&gt; scan 1 [20,30,40]
=&gt; scan 2 [30,40]
=&gt; scan 3 [40]
=&gt; scan 4 []
=&gt; 4
</code></pre></td></tr>
</tbody></table>
</p>

<p>Let us consider <code>my_list_len_v1</code> first. In every step
(except the last), we pass on the work of resolving a sub-problem to
another function (which is just again the function
<code>my_list_len_v1</code>, but that does not matter). What is
important now is that once we know the result of that sub-problem,
this has to be post-processed - by adding one - before we can return
our result. This means that, in every recursive call, we have to
remember that we will have to come back to this context after the
recursion finished, and do some more work. Note that this is not how
one normally would execute a task like counting the elements of a list
by hand. One just does not think along the lines of: "<em>the length
of this list is one more than... oh, there is another list, and the
length of that is one more than... (...) and the length of the empty
list is zero; plus one, that is one, plus one, that is two, plus one,
that is three, plus one makes four.</em>" That is about as silly for
the machine as it is for us.
</p>

<p>How to do it better, then? One just models the process one would
execute in one's head. When I go through a list to count its entries,
I remember at every step how many elements I counted so far, and as
soon as I reach the end of the list, I already know the answer. This
is just how <code>my_list_len_v2</code> works. Note that, unlike with
the first definition, the length of the intermediate expressions this
reduces to (which are effectively represented on the call stack of the
machine) does not grow as we proceed, and in particular does not
depend on the length of the list.
</p>

<p>What is the trick, schematically? We use an extra "accumulator
argument" in which we pass along the result of processing the list so
far. As we usually do not want to make this extra accumulator argument
visible to the outside, we will often employ a local recursive
function to do all the work. Note that this is a very general
strategy. In the particular case of lists, quite many of the
situations where one would like to process elements one by one can be
classified as belonging to a set of frequently occurring patterns, and
there are pre-defined functions to deal with these. It is very
tempting to just give a definition of one of them which is called
<code>reduce</code> in many languages, but goes by the name of
<code>List.fold_left</code> in OCaml. The idea is to take a list, a
start value, and a function, go through the list element by element,
and in every step use the function to combine the value obtained so
far with the element at hand.
</p>

<p>
<table border="1"><tbody><tr><th>Definition and applications of <code>reduce</code></th></tr>
<tr><td><pre><code>
let reduce f li start =
  let rec walk so_far rest =
    match rest with
    | [] -&gt; so_far
    | (h::t) -&gt; walk (f so_far h) t
  in walk start li
;;
(* Examples:

# reduce (fun so_far x -&gt; so_far+.x*.x) 0.0 [3.0;4.0;0.0;5.0];;
- : float = 50.

# reduce max 0 [8;3;12;5;4];;
- : int = 12

Even list length can be interpreted as a special case of this:

# reduce (fun so_far _ -&gt; 1+so_far) 0 [10;20;30;40];;
- : int = 4
*)
</code></pre></td></tr>
</tbody></table>
</p>

<p>One conventionally calls such a repetitive sequence of operations
an "iterative process". Here, we use recursive functions to model
iterative processes, and the compiler is clever enough to turn this
into purely iterative code. From the perspective of a compiler writer,
one may say that we call a function by putting its arguments on some
call stack, and jumping to the code that computes the function's value
from those arguments on the stack. Now, one would normally want the
called function to return back to where it was called, and virtually
all processors today provide distinct "<code>jump</code>" and
"<code>jump to subroutine</code>" machine instructions, where the
latter records the return address on the call stack. <em>It is
important to realize, however, that this return address is nothing
else but an extra argument to the function that is called.</em> What
is this argument? <em>It tells the called function whom it should call
with its computed value.</em> So, by putting our return address onto
the stack, we actually pass something like a function argument that
tells the called function how to continue after its work is done. This
holds for every programming language that knows about subroutine
calls. Generally, these go-on functions are called
<em>continuations</em>. Note that in languages such as C, a
continuation (call it a return address if you want) behaves like a
code pointer, but there would be no ANSI-compliant way to obtain, pass
around, or play with that kind of function pointers, with the
exception of the <code>setjmp()</code> and <code>longjmp()</code>
functions.
</p>

<p>This continuation point of view is very powerful. Returning a value
from a function just becomes calling the continuation of that function
with this value. This gives a nicely symmetric description where
calling with a value and returning a value becomes just the same: a
"goto with arguments". This also sheds a new light on a very basic
observation: in many programming languages, such as C, functions can
have zero, one, or more arguments, but they can only return zero or
one value. Now, the point is: <em>if we call a function whose result
is just our result as well, we do not have to put a new continuation
on the call stack, as it is perfectly fine if the function which we
call passes on its result to our own continuation</em>. In other
words: just forget about calls and returns being nicely nested. There
is also jumps and returns to places from where we were not called.
</p>

<p>Sometimes, it is useful to partially transform a certain function
to continuation-passing style by replacing the returning of a value
with an explicit call to a function that represents the
continuation. Things get much more interesting, however, if the
programming language allows us to get a handle on "that which is to be
done afterwards" in the form of an explicit continuation that can be
stored away, passed around, and called, even multiple times. This
allows one to implement quite crazy high wizardry which we
unfortunately have no opportunity to discuss here. Making
continuations explicit is one of the fundamental ideas underlying the
Scheme programming language, a dialect of Lisp. Some other languages
can do this as well, such as Smalltalk, and there is even a variant of
the python interpreter that has advanced continuation support, see
<a href="http://www.stackless.com/"><tt>href="http://www.stackless.com</tt></a>
</p>

<p>A more pedestrian point of view on that matter is that actually,
there is a simple but nice optimization: <em>whenever the last thing
that has to be done inside a function before it returns a result is to
compute the value of another function (which is to be returned), that
inner function can be called with a simple <code>jump</code> rather
than a <code>jump to subroutine</code>, so that the return from the
inner function will be the return from the outer function as well.</em>
</p>

<p>All modern compilers are supposed to perform that particular "tail
call elimination" optimization where appropriate. It is very
interesting to take a closer look at this using a LISP system:
</p>

<p>
<table border="1"><tbody><tr><th>List length in Common LISP (CMUCL)</th></tr>
<tr><td><pre><code>
* 
(defun my-list-length (li)
  (declare (optimize (safety 0) (speed 3)))
  (labels
      ((scan (now rest)
	 (declare (fixnum now) (list rest))
	 (if rest
	     (scan (the fixnum (1+ now)) (cdr rest))
	   now)))
    (scan 0 li)))



MY-LIST-LENGTH
* (compile 'my-list-length)
; Compiling LAMBDA (LI): 
; Compiling Top-Level Form: 

MY-LIST-LENGTH
NIL
NIL
* (disassemble 'my-list-length)

580C1358:       .ENTRY MY-LIST-LENGTH(li)    ; (FUNCTION (T)
                                             ;  (INTEGER -536870899 536870911))
      70:       POP     DWORD PTR [EBP-8]
      73:       LEA     ESP, [EBP-32]

      76:       XOR     EAX, EAX             ; No-arg-parsing entry point
                                             ; [:NON-LOCAL-ENTRY]
      78:       MOV     ECX, EDX
      7A:       JMP     L1

;;; [16] (SCAN (THE FIXNUM (1+ NOW)) (CDR REST))
<font color="red">
      7C: L0:   ADD     EAX, 4               ; [:BLOCK-START]
      7F:       MOV     ECX, [ECX+1]

;;; [8] (LABELS ((SCAN #
                   # ..)))

      82: L1:   CMP     ECX, #x2800000B      ; NIL
                                             ; [:BLOCK-START]
      88:       JNE     L0
</font>
;;; [15] (IF REST (SCAN (THE FIXNUM #) (CDR REST)) NOW)

      8A:       MOV     EDX, EAX             ; [:BLOCK-START]
                                             ; [:BLOCK-START]
      8C:       MOV     ECX, [EBP-8]
      8F:       MOV     EAX, [EBP-4]
      92:       ADD     ECX, 2
      95:       MOV     ESP, EBP
      97:       MOV     EBP, EAX
      99:       JMP     ECX
      9B:       NOP
      9C:       NOP
      9D:       NOP
      9E:       NOP
      9F:       NOP
</code></pre></td></tr>
</tbody></table>
</p>

<p>Note that quite many all Common LISP compilers are combined
compiler/interpreter systems, which means that one can compile LISP
code directly to machine code even from the command prompt. Note that
we cannot do this with OCaml. The set of instructions marked in red is
the inner loop where the counting happens. Note that this is about as
optimized as machine code can be. (There would be more to say why we
add four in the iteration, and not one, to increase the variable
<code>now</code> by one. Remember that OCaml's integers are a bit
shorter than native machine integers? The same holds for LISP, and
this is related to this issue here.)
</p>

<p>So, there is really actually never a need for something like a
<code>for</code> loop in virtually any language. The ability to call
functions recursively and a properly implemented compiler are good
enough. Most languages nevertheless provide this and similar control
statements. In some of them, they are just macros that expand to such
"tail recursive" definitions. If there are extra iteration constructs
besides what we get through recursion alone, one should quite in
general use the approach that allows one to express the underlying
idea in the clearer way. Tail recursiveness generally is a good thing,
but one should be extra careful with lazy functional languages, such
as Haskell, where things behave quite different anyway due to the
wildly different execution model.
</p>

<h2>Side Effects I: Doing one thing after another</h2>

<p>One of the key ideas of functional programming is to express more
directly <em>what</em> a program is supposed to do, rather than
<em>how</em> that what the program is supposed to do may be decomposed
into a sequence of instructions to be carried out one by
one. Therefore, when one learns to work with a functional programming
language, it usually is not a good idea to dive into extensively using
imperative features too early and carry over the bad habits from more
primitive imperative languages which never were designed with that
form of code abstraction in mind which the functional style allows.
</p>

<p>On the other hand, many programs - even quite complex ones -
usually contain a small core where execution time really counts. If
the corresponding manipulations involve large but simple data
structures, such as arrays, it often is a good idea not to create a
new one in every step, but to destructively modify an existing one if
possible. Even in those situations where it may not matter for the
complexity of the algorithm, having to allocate a new array may be a
bit wasteful, especially if this means that we once again have to
transport a lot of data into the processor's data cache when we start
to work on it.
</p>

<p>So, even with the niceties of a functional language around, we may
prefer not to do everything in a purely functional style. But how,
then, do we modify values, and more importantly, if we have done
something, how do we do something else afterwards?
</p>

<p>One might claim that in a certain sense, we already know a bit
about this. Presumably, nobody would be surprised by this particular
function definition:
</p>

<p>
<table border="1"><tbody><tr><th>Measuring execution times of functions</th></tr>
<tr><td><pre><code>
let time_it f x =
  let start_time = Unix.gettimeofday() in
  let result = f x in
  let end_time = Unix.gettimeofday() in
  (end_time-.start_time,result)
;;

let rec fibonacci n = if n &lt; 3 then 1 else fibonacci (n-1) + fibonacci (n-2);;

let timed_fibonacci = time_it fibonacci;;

(* Example:
# timed_fibonacci 32;;
- : float * int = (0.190546989440917969, 2178309)
*)
</code></pre></td></tr>
</tbody></table>
</p>

<p>In a certain sense, this provides kind of an answer to "how do I do
one thing after another". If one approached this question naively, one
may wonder whether the compiler may detect that the definition of
<code>end_time</code> seemingly does not interfere with the definition
of <code>result</code>, and so execution order may be re-arranged to
the fastest possible form. Actually, OCaml guarantees that this is not
done: in a sequence of <code>let</code> definitions, the first one is
evaluated before the second one, etc.
</p>

<p>We may use this e.g. in the following way in order to do one thing
after another:
</p>

<p>
<table border="1"><tbody><tr><th>A sequence of printing instructions</th></tr>
<tr><td><pre><code>
let hello () =
  let () = Printf.printf "Hello " in
  let () = Printf.printf "out there!\n" in
  Printf.printf "DONE.\n%!"
;;

(* Example:
# hello();;
Hello out there!
DONE.
- : unit = ()
*)
</code></pre></td></tr>
</tbody></table>
</p>

<p>What if a function which is called purely for side effect returns
something else but <code>()</code>? We may either use <code>let _ =
...</code> instead, or alternatively use the 
"<code>ignore: 'a -&gt; unit</code>" function.
</p>

<p>There are other ways to do the same. Sometimes, the previous form
is the most elegant one, sometimes it is another one. OCaml provides
slightly different ways to notate a bare sequence of instructions;
which one to use is mostly a matter of taste. For clarity, I strongly
recommend the following alternative style should the <code>let</code>
form be inconvenient:
</p>

<p>
<table border="1"><tbody><tr><th>Another sequence of printing instructions</th></tr>
<tr><td><pre><code>
let hello_v2 () =
  begin
    Printf.printf "Hello ";
    Printf.printf "out there!\n";
    Printf.printf "DONE.\n%!";
    100;
  end
;;

(* Example:
val hello_v2 : unit -&gt; int = &lt;fun&gt;
# hello_v2();;
Hello out there!
DONE.
- : int = 100
*)
</code></pre></td></tr>
</tbody></table>
</p>

<p>All the entries in such a <code>begin ... end</code>
semicolon-separated sequence should have type <code>unit</code>,
except the last one, which will be the value of the entire
sequence. The semicolon after the last value is optional. Actually,
the <code>ignore</code> function is much more useful here than in a
<code>let</code> sequence.
</p>

<p>Aside from these, there are some explicit iteration functions, such as:
</p>

<p>
<table border="1"><tbody><tr><th>Array iteration with index counting</th></tr>
<tr><td><pre><code>
# Array.iteri (fun n x -&gt; Printf.printf "%2d: %6.3f\n" n x) [|100.0;105.0;97.0|];;
 0: 100.000
 1: 105.000
 2: 97.000
- : unit = ()
</code></pre></td></tr>
</tbody></table>
</p>

<h2>Side Effects II: Modifying Arrays, Strings, and Bigarrays</h2>

<p>Now that we have seen how to do something destructive and then
proceed with other work, how do we update array entries? This
presumably will be the most frequent destructive operation we perform.
</p>

<p>There are various approaches to this. A widely supported philosophy
is that all access to modifiable state should run through functions
(or methods, for that matter) for the sake of extensibility and
modifiability of a program. Some C++ programmers know this very
well. So do the Perl programmers, who introduced the concept of
"magic": for any variable, one may register functions which are to be
called when the contents of that variable are being read or updated,
hence "slipping in" custom code in situations where something that
actually required custom code originally was designed in a too simple
minded fashion as just a variable access.
</p>

<p>For the followers of the "everything is a function" school, there
is the "<code>Array.get</code>" and "<code>Array.set</code>"
functions. For those who prefer special syntax and brevity, there is
"<code>array.(n)</code>" and left-arrow assignment:
</p>

<p>
<table border="1"><tbody><tr><th>Getting and setting Array elements</th></tr>
<tr><td><pre><code>
# let some_array = [|(2,3);(4,5);(6,7)|];;
val some_array : (int * int) array = [|(2, 3); (4, 5); (6, 7)|]

# some_array.(0);;
- : int * int = (2, 3)

# some_array.(1) &lt;- (100,200);;
- : unit = ()

# some_array;;
- : (int * int) array = [|(2, 3); (100, 200); (6, 7)|]

# Array.set some_array 2 (0,1);;
- : unit = ()

# some_array;;
- : (int * int) array = [|(2, 3); (100, 200); (0, 1)|]
</code></pre></td></tr>
</tbody></table>
</p>

<p>For strings, this is very similar, only that one uses <code>s.[n]</code>:
</p>

<p>
<table border="1"><tbody><tr><th>Getting and setting String characters</th></tr>
<tr><td><pre><code>
# let some_string="hello";;
val some_string : string = "hello"

# String.set some_string 0 'H';;
- : unit = ()

# some_string;;
- : string = "Hello"

# some_string.[1];;
- : char = 'e'

# some_string.[1] &lt;- 'u';;
- : unit = ()

# some_string;;
- : string = "Hullo"
</code></pre></td></tr>
</tbody></table>
</p>

<p>One may be tempted to abuse strings, which implement 8-bit arrays,
as an alternative to specialized vectors of small data, such as
boolean vectors, or vectors of numbers smaller than 10. In most such
situations, however, one should be better off using the
<code>Bigarray</code> module which provides specialized functions for
potentially large numerical data arrays of all sorts of integer and
floatingpoint numbers. These are intended to be especially useful in
conjunction with C and FORTRAN code, which means in particular that
garbage collection will never move around the data portion of a
<code>Bigarray</code>.
</p>

<p>
In order to use <code>Bigarray</code>, one must either first build a
custom interpreter that knows about the <code>bigarray.cma</code>
library via <code>ocamlmktop</code>, or use an interpreter directive
to load it dynamically, or - when using the compiler - additionally
specify <code>bigarray.cmxa</code> among the compiler
objects. <code>Bigarray</code> provides generic arrays as well as
specialized ones for rank 1,2, and 3. One interesting aspect is that
the data types in the <code>Bigarray</code> may differ from OCaml's
native data types. For example, one may want to use this module to
read an array of single precision floatingpoint numbers generated by
some C code, but OCaml only knows about double precision. This is
resolved through some type mapping: although only single precision
values are stored in the array, what one reads and writes is double
precision, which is converted up from, or down to, single precision as
necessary.
</p>

<p>
<table border="1">
<tbody><tr><th>Bigarray example</th></tr>
<tr><td>
<pre><code>
(* Preparation:
    either make a toplevel via ocamlmktop -o mytop bigarray.cma
    or use #load "bigarray.cma" inside the interpreter
    When compiling, use ocamlopt -o myprog bigarray.cmxa myprog.ml
*)

# let numdata = Array1.create float64 c_layout 100;;
val numdata :
  (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Array1.t =
  &lt;abstr&gt;

# numdata.{0};;
- : float = 8.44821358110015552
# numdata.{1};;
- : float = 206241825936.019043
(* Initially, this contains some memory garbage *)

# numdata.{0} &lt;- 3.5;;
- : unit = ()

# numdata.{0};;
- : float = 3.5

# let numdata_2d = Array2.create float64 c_layout 100 100;;
val numdata_2d :
  (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Array2.t =
  &lt;abstr&gt;

# numdata_2d.{5,9} &lt;- 1.0;;
- : unit = ()

# numdata_2d.{5,9};;
- : float = 1.

# let numdata_single = Array1.create float32 c_layout 100;;
val numdata_single :
  (float, Bigarray.float32_elt, Bigarray.c_layout) Bigarray.Array1.t =
  &lt;abstr&gt;
(* This does some non-trivial float/double mapping *)

# numdata_single.{0} &lt;- 5.200001;;
- : unit = ()

# numdata_single.{0};;
- : float = 5.20000076293945312

# numdata_single.{0} &lt;- 1.0e200;;
- : unit = ()

# numdata_single.{0};;
- : float = infinity
</code></pre>
</td></tr>
</tbody></table>
</p>

<h2>Side Effects III: References and Modifiable Records</h2>

<p>Record entries normally are not modifiable. Modifiability can be
specified on a per-field basis when defining the record type.
</p>

<p>
<table border="1"><tbody><tr><th>Mutable record entries</th></tr>
<tr><td><pre><code>
type user =
    {
     name: string;
     mutable nr_logins: int;
   };;

        type user = { name : string; mutable nr_logins : int; }

# let root = {name="root"; nr_logins=1;};;
val root : user = {name = "root"; nr_logins = 1}

# root.nr_logins &lt;- 2;;
- : unit = ()

# root;;
- : user = {name = "root"; nr_logins = 2}

# root.name&lt;-"nobody";;
Characters 0-19:
  root.name &lt;- "nobody";;
  ^^^^^^^^^^^^^^^^^^^^^
The record field label name is not mutable
</code></pre></td></tr>
</tbody></table>
</p>

<p>While we can modify the contents of some containers, we cannot
modify variables. Unlike in many other languages, variables are just
names for values, and not containers where to store values. Of course,
it sometimes would be nice if such a concept like "container for an
integer which I can update" were available nevertheless. One may
consider using a polymorphic record for this. Actually, OCaml already
provides something quite like this: references.
</p>

<p>
<table border="1"><tbody><tr><th>Polymorphic records as containers</th></tr>
<tr><td><pre><code>
type 'a box =
 {mutable in_box: 'a};;

let my_sum arr =
  let sum_now = {in_box=0} in
  let () = Array.iter (fun n -&gt; sum_now.in_box &lt;- sum_now.in_box+n) arr in
  sum_now.in_box;;

(* Example:

# my_sum [|10;20;30;40|];;
- : int = 100
*)

(* The same with OCaml's built-in references: *)

let my_sum_v2 arr =
  let sum_now = ref 0 in
  let () = Array.iter (fun n -&gt; sum_now.contents &lt;- sum_now.contents+n) arr in
  sum_now.contents;;

(* Alternative access and update syntax for references: *)

let my_sum_v3 arr =
  let sum_now = ref 0 in
  let () = Array.iter (fun n -&gt; sum_now := !sum_now+n) arr in
  sum_now.contents;;
</code></pre></td></tr>
</tbody></table>
</p>

<p>It may be very tempting to just use lots of references to mimic
some imperative coding style with OCaml. This is possible, but quite
often, there are better ways to achieve the same result. In this
particular example, one should prefer using
<code>Array.fold_left</code>.
</p>

<p>Always remember: never use imperative features if there is a better
functional way to achieve the same. Actually, never use X when it can
be done better using Y, whatever X and Y.
</p>

<h2>Side Effects IV: Hash tables</h2>

<p>A very useful data structure is the hash, also known as
"dictionary" in some languages. One may see this as a generalization
of arrays: arrays map small numbers - indices - to values. Hashes
implement a mapping of more general keys to values. Both provide
modifiable associations that may be updated.
</p>

<p>
As hashes internally use some pseudo-randomness, only statistical
statements may be made about their performance. On average, element
lookup takes O(1) time, element insertion amortized O(log N) time, and
deletion also O(1) time, as hashes will not shrink again if we take
out elements. If, however, one hashes data from an external source,
such as URLs from a webserver log, one must consider the question
whether the external source may be modified in such a way that it
targets worst-case behaviour of the hash. This effectively degrades
hashes to associative lists, with average O(N) lookup and O(N)
insertion. There have been attacks based on such techniques in the
past, even on the Linux kernel. One solution is to use more robust
balanced tree data structures which may be a bit slower, but can give
worst case guarantees. (The Perl solution, by the way, is to randomize
the internal hash function at every program start, effectively giving
nondeterministic and irreproducible behaviour whenever there is any
implicit dependency on the order of hash keys in a program. Inherent
irreproducibility in a language will eventually turn out not to be a
good idea, but only if enough people notice the problems.)
</p>

<p>
Hash keys may be almost arbitrary values. This is the major difference
to Perl, where they are restricted to being strings. Python hackers
may wonder whether only immutable types (that is, tuples and
immutable records) are allowed as keys: this is not the case: one may
just as well use strings or arrays as hash keys, but modifying a value
that is used as a key in a hash will have quite bad effects on the
hash, so one never should do this. Lisp hackers may be disappointed to
hear that OCaml does not come with different hashes which can test
keys not only for equality, but also for same-ness. So, it makes
little sense trying to use a function as a hash key.
</p>

<p>
<table border="1"><tbody><tr><th>Hash table example</th></tr>
<tr><td><pre><code>
#
let some_hash = Hashtbl.create 100 (* estimated size *) in
begin  
  Hashtbl.add some_hash "Jim" "Beam";
  Hashtbl.add some_hash "Jack" "Daniels";
  Hashtbl.add some_hash "Jonny" "Walker";
  Hashtbl.add some_hash "Jack" "Sparrow";
  Hashtbl.iter (fun key value -&gt; Printf.printf "%s =&gt; %s\n" key value) some_hash;
  Hashtbl.find some_hash "Jack"
end
;;

Jim =&gt; Beam
Jonny =&gt; Walker
Jack =&gt; Sparrow
Jack =&gt; Daniels
- : string = "Sparrow"
</code></pre></td></tr>
</tbody></table>
</p>

<p>Note that there may be more than one value associated to a given
key. <code>Hashtbl.add</code> will return the last binding made, which
effectively hides the others. If new entries are to be made in a way
that overwrites previous bindings, one should use
<code>Hashtbl.replace</code>. This may seem a bit mysterious, unless
one knows how hash tables usually are implemented. There is much more
to be said about hash tables, this lecture is just supposed to
introduce the underlying idea. For details on hash table functions,
one should consult the <code>Hashtbl</code> module documentation.
</p>

<h2>Side Effects V: Iteration, again</h2>

<p>OCaml also comes with syntactic constructs for iteration that
mimic "<code>for</code>" and "<code>while do</code>". One has to be
careful here, however, as <code>for</code> has funny ideas about index
ranges:
</p>

<p>
<table border="1"><tbody><tr><th>OCaml's <code>for</code> and <code>while do</code></th></tr>
<tr><td><pre><code>
let something_imperative () =
  begin
    for i=0 to 10 do
      Printf.printf "i=%d\n%!" i;
      Unix.sleep 1;
    done;
    let counter = ref 0 in
    while !counter&lt;10 do
      Printf.printf "counter=%d\n%!" !counter;
      counter:= !counter+1;
    done
  end
;;

(* Example:
# something_imperative();;
i=0
i=1
i=2
i=3
i=4
i=5
i=6
i=7
i=8
i=9
i=10
counter=0
counter=1
counter=2
counter=3
counter=4
counter=5
counter=6
counter=7
counter=8
counter=9
- : unit = ()
*)
</code></pre></td></tr>
</tbody></table>
</p>

<p>As the <code>for</code> range includes both the lower and the upper
limit, one is perhaps well advised to adopt the habit of
<em>always</em> using the idiom 
"<code>for var=lower to upper<font color="red">-1</font> do</code>".
</p>

<h2>Exceptions</h2>

<p>Just like many modern programming languages, OCaml comes with means
to implement exceptional non-local execution flow. As in other
languages, this is intended to be used to report exceptional
situations that occur deep in the code to the first caller in the call
hierarchy that considers himself responsible to handle this. We
already have used exceptions, but only in their simplest form:
<code>Failure</code> exceptions which pass on a string and percolate
all the way up to the toplevel. There are a few other pre-defined
exceptions that are used by many library functions, and we may be well
advised to use some of them in our own code as well to match the
behaviour of the libraries. One of them is <code>Not_found</code>,
which is raised e.g. by List.find.
</p>

<p>
<table border="1"><tbody><tr><th>Handling and raising exceptions</th></tr>
<tr><td><pre><code>
let list_find_with_default property li default =
  try
    List.find property li
  with
  | Not_found -&gt; default
;;

(* Example:
# list_find_with_default (fun x -&gt; x&lt;0) [1;2;-3;4;5] 0;;
- : int = -3

# list_find_with_default (fun x -&gt; x&lt;0) [1;2;3;4;5] 0;;
- : int = 0
*)

let array_find property arr =
  let len = Array.length arr in
  let rec walk pos =
    if pos = len
    then raise Not_found
    else
      if property arr.(pos)
      then arr.(pos)
      else walk (pos+1)
  in walk 0
;;

(*
# array_find (fun x -&gt; x&lt;0) [|1;2;-3;4;5|];;
- : int = -3

# array_find (fun x -&gt; x&lt;0) [|1;2;3;4;5|];;
Exception: Not_found.
*)

(* We can also define our own: *)

exception Problem_in_Front_of_Keyboard

exception Oh_my_god of string

let factorial n =
  if n &lt; 0
  then raise Problem_in_Front_of_Keyboard
  else if n &gt; 12
  then raise (Oh_my_god "That is quite big")
  else
    let rec walk so_far m =
      if m&gt;n then so_far
      else walk (so_far*m) (m+1)
    in walk 1 1
;;
</code></pre></td></tr>
</tbody></table>
</p>

<p>As exceptions unwind the call hierarchy, the installation of an
exception handler will prevent tail call elimination. This can be seen
in the following examples. The first of these two implementations of a
function reading a file as a list of line strings will have problems
with long files.
</p>

<p>
<table border="1"><tbody><tr><th>Exceptions and tail call elimination</th></tr>
<tr><td><pre><code>
let qcat_lines_bad filename =
  let fh = open_in filename in
  let rec read_lines so_far =
    try
      let next_line = input_line fh in
      read_lines (next_line::so_far)
    with
      End_of_file -&gt;
       let () = close_in fh in List.rev so_far
  in read_lines []
;;

(*
We have to use quite strange tricks to get this right in a strongly
typed language:
*)

let qcat_lines filename =
  let bad_line = "bad" in
  (* note that we use this in same-ness checks,
     and something read in never == that string! *)
  let fh = open_in filename in
  let rec read_lines so_far =
    let next_line = 
      try
        input_line fh
      with
        End_of_file -&gt; bad_line in
    if next_line == bad_line then List.rev so_far
    else
      read_lines (next_line::so_far)
  in 
  let result = read_lines [] in
  let () = close_in fh in
  result
;;
</code></pre></td></tr>
</tbody></table>
</p>


<h2>Named and Optional Function Arguments</h2>

<p>A nice and very useful extension provided by OCaml but usually not
by other members of the ML family is named and optional function
arguments. These are especially useful if there is no clear order of
specialization in the arguments of a function, or if it is easier to
remember an argument by name rather than by position. 
</p>

<p>
<table border="1"><tbody><tr><th>Named and Optional Arguments</th></tr>
<tr><td><pre><code>
# let pair ~left ~right = (left,right);;
val pair : left:'a -&gt; right:'b -&gt; 'a * 'b = &lt;fun&gt;

# pair ~right:4 ~left:8;;
- : int * int = (8, 4)

# pair ~right:2;;
- : left:'a -&gt; 'a * int = &lt;fun&gt;

(* Optional arguments with default *)
# let gradient ?(epsilon=1.0e-8) f x = (f(x+.epsilon)-.f(x-.epsilon))/.epsilon;;
val gradient : ?epsilon:float -&gt; (float -&gt; float) -&gt; float -&gt; float = &lt;fun&gt;

# gradient (fun x -&gt; x*.x*.x) 1.0;;
- : float = 5.99999998573963467

# gradient ~epsilon:1.0e-2 (fun x -&gt; x*.x*.x) 1.0;;
- : float = 6.00019999999999953

(* One should stick to the convention to never let an optional argument be the last.
   If necessary, better provide an extra () argument. *)

# let gauss_random ?(mean=0.0) ?(sigma=1.0) =
   let (u,v)=(Random.float 1.0,Random.float 1.0) in
    mean +. sigma *. (cos(2.0*.3.141592652589793*.u)*.sqrt(-.2.0*.log v));;
Characters 37-40:
Warning: This optional argument cannot be erased
  let gauss_random ?(mean=0.0) ?(sigma=1.0) =
    let (u,v)=(Random.float 1.0,Random.float 1.0) in
     mean +. sigma *. (cos(2.0*.3.141592652589793*.u)*.sqrt(-.2.0*.log v));;
                                       ^^^
val gauss_random : ?mean:float -&gt; ?sigma:float -&gt; float = &lt;fun&gt;


# let gauss_random ?(mean=0.0) ?(sigma=1.0) () =
   let (u,v)=(Random.float 1.0,Random.float 1.0) in
    mean +. sigma *. (cos(2.0*.3.141592652589793*.u)*.sqrt(-.2.0*.log v));;

val gauss_random : ?mean:float -&gt; ?sigma:float -&gt; unit -&gt; float = &lt;fun&gt;


# Array.init 10 (fun _ -&gt; gauss_random());;
- : float array =
[|0.03577065686519654; -0.72466106138123655; 0.29523377546294616;
  -0.562066964523875168; -1.437069213890769; -0.258813297649262274;
  0.31148502404366418; -1.0830811867756244826; -2.24662224750417527;
  1.01635512121772|]

# Array.init 10 (fun _ -&gt; gauss_random ~sigma:100.0 ());;
- : float array =
[|-70.1711804677790525; 14.1894407039556274; -184.375667344158103;
  -72.6332159099925718; -176.215374334835246; 46.3236371909414331;
  89.8203109743660519; 4.76137882744779262; 60.8437244884956101;
  69.3712412882054679|]
</code></pre></td></tr>
</tbody></table>
</p>

<p>Sometimes, we may want to have optional arguments without providing
a default. This is especially true if the default would nail down a
particular type. If we give an optional argument without providing a
default, OCaml will have to tell our code whether a value has been
provided or not, and what it is. To do this, it uses the "<code>'a
option</code>" polymorphic variant type. This is a very close relative
to "<code>'a list</code>" and may be considered as being equivalent to
a list of at most one value.
</p>

<p>
<table border="1"><tbody><tr><th>The <code>'a option</code> type</th></tr>
<tr><td><pre><code>
(* The option type behaves as if it were defined as: *)

type 'a option = None | Some of 'a;;

(* It is sometimes useful in its own right,
   as it provides a notion for "everything of this type,
   plus one extra separate value".

   This may e.g. sometimes be seen as an alternative
   to using exceptions:
 *)

let try_find_association key li =
  try
    Some (List.find (fun (this_key,this_value) -&gt; this_key=key) li)
  with
  | Not_found -&gt; None
;;

      
(* Examples:

# try_find_association 5 [(1,8);(7,2);(5,11);(2,1)];;
- : (int * int) option = Some (5, 11)

# try_find_association 8 [(1,8);(7,2);(5,11);(2,1)];;
- : (int * int) option = None
*)
</code></pre></td></tr>
</tbody></table>
</p>

<p>If we define an argument as optional, but do not provide a value,
then the corresponding value passed into our function will either be
<code>None</code> if the function was called without that argument, or
<code>Some x</code>, if the value <code>x</code> was given for this
argument.
</p>

<p>
<table border="1"><tbody><tr><th>Optional named arguments without defaults</th></tr>
<tr><td><pre><code>
# let just_return_args ?reason arg = (reason,arg);;
val just_return_args : ?reason:'a -&gt; 'b -&gt; 'a option * 'b = &lt;fun&gt;

# just_return_args 5;;
- : 'a option * int = (None, 5)

# just_return_args ~reason:"Because I say so" 5;;
- : string option * int = (Some "Because I say so", 5)

# just_return_args ~reason:None 5;;
- : 'a option option * int = (Some None, 5)
</code></pre></td></tr>
</tbody></table>
</p>

<h2>"As"-patterns</h2>

<p>One final remark concerns the use of complex patterns. Sometimes it
happens that one wants to extract not only some data deeply hidden
within some complicated nested structure, but at the same time
structures from outer levels. This may be for efficiency reasons,
typically avoiding to re-construct the very same tuple that also
occurred in the matched structure, or because one really needs the
outer and inner structures at the same time.
</p>

<p>
<table border="1"><tbody><tr><th>As-Patterns</th></tr>
<tr><td><pre><code>
# let pairpair_example
   (outer_left, ((inner_left,inner_right) as outer_right)) =
 (inner_left,outer_right);;

val pairpair_example : 'a * ('b * 'c) -&gt; 'b * ('b * 'c) = &lt;fun&gt;


# pairpair_example ("OL",("IL","IR"));;
- : string * (string * string) = ("IL", ("IL", "IR"))
</code></pre></td></tr>
</tbody></table>
</p>

<p>What is slightly annoying about these as-patterns is that OCaml
just does it the other way round than any other functional language
that has them:
</p>

<p>
<table border="1"><tbody><tr><th>As-Patterns in Haskell and SML</th></tr>
<tr><td><pre><code>
[Haskell]
&gt; ppx (1,(2,3)) where ppx (ol,or @ (il,ir)) = (il,or)
(2,(2,3))

[SML]
- fun ppx (ol, or as (il,ir)) = (il,or);
val ppx = fn : 'a * ('b * 'c) -&gt; 'b * ('b * 'c)

- ppx (1,(2,3));
val it = (2,(2,3)) : int * (int * int)
</code></pre></td></tr>
</tbody></table>
</p>

<p>With this remark, let us conclude our round trip through some of
the slightly more esoteric corners. One presumably could give a
demanding half-year course on functional programming without ever
having to touch any single one of these issues, except perhaps tail
call removal. Nevertheless, they turn out to be very useful to know,
especially if one wants to tackle problems from the real world, and
not just some pre-selected exercise questions. Speaking of exercises,
we once again provide plenty of them:
</p>

<h2>Exercises</h2>

<p>
</p><ol>

<li><p>Define your own tail-recursive variant of
<code>List.map</code>. Is the definition in the standard library tail
recursive? (Use <code>ocamlbrowser</code> to check.) Can you use it on
very long lists?</p></li>

<li><p>Define a function that counts how often it has been called so far.
</p></li>

<li><p>Define a "timing" function which will take as arguments a
function <code>f</code> and a value <code>x</code> to be fed into that
function, and optionally a number of evaluations of <code>f x</code>
to perform (to optionally slow things down, defaulting to 1), which
will return the value of <code>f x</code>. In addition to returning
that value, it should print to standard output some information about
how much time the evaluation(s) took.
</p></li>

<li><p>Define a "<code>gensym</code>" function that takes a string as
argument and produces a new string which consists of the old one, a
dash, and a number appended to it counting how often it was called
with that particular string. That is, calling it three times with the
string <code>"xyz"</code> should subsequently produce
<code>"xyz-1"</code>, <code>"xyz-2"</code>, <code>"xyz-3"</code>.
</p></li>

<li><p>Define a function that prints all those entries in a float
array in a nice and readable tabular form, index and value, which are
of absolute magnitude larger than some <code>epsilon</code>, which may
be passed as optional argument, but comes with a reasonable default.
</p></li>

<li><p>Define a function that removes all the entries from a hash
table which satisfy a given property. Note: it is not at all a good
idea to modify a hash table while iterating through it!</p></li>

<li><p>OCaml does not provide a function that can be used to
efficiently return an arbitrary entry from a hash table. This can,
however, sometimes be very useful. Hint: use
<code>Hashtbl.iter</code> and an exception.
</p></li>

<li><p>Write a function that counts how many entries of a hash table
satisfy a given property. Hint: use <code>Hashtbl.iter</code> and a
counter reference.
</p></li>

<li><p>Define a function that maps an array to another array where
duplicate values have been removed. Note: you should be able to do this
with an expected run time of <code>O(N_total log N_left)</code>.
</p></li>

<li><p>Define a variable that contains a reference whose type is
polymorphic. Is it possible to break the type system via assigning to
a polymorphic reference? (Note: this has been an important problem for
some time, see e.g. <a href="http://pauillac.inria.fr/%7Exleroy/publi/polymorphic-assignment.ps.gz">this paper</a> for background information.)
</p></li>

<li><p>Write an OCaml program that can be compiled to a standalone
binary which reads line after line from standard input, and prints
every line it has read to standard output, unless that line was
already encountered earlier.
</p></li>

<li><p>Write a function which takes an array as argument, and
destructively modifies this array in such a way that in the end, it
will be perfectly shuffled. Hint: there is a quite obvious good
algorithm to do this, known as "Fisher-Yates shuffle".
</p></li>

<li><p>The imperative "<code>for ... do ... done</code>" construct can
be modeled by the following conceptually equivalent piece of code:
</p>

<p>
<table border="1"><tbody><tr><th>A <code>for</code> equivalent</th></tr>
<tr><td><pre><code>
let do_for range_start range_end f_todo =
  let rec process n =
    if n &gt; range_end then ()
    else
      begin
	f_todo n;
	process (n+1)
      end
  in process range_start
;;

do_for 0 10 (fun i -&gt; Printf.printf "%d\n" i);;

(* is equivalent to: *)

for i=0 to 10 do Printf.printf "%d\n" i done;;
</code></pre></td></tr>
</tbody></table>
</p>

<p>Find a similar definition which is equivalent to 
"<code>while ... do</code>" that also uses tail recursion
to implement iteration.
</p>
</li>

<li>
<p>Occasionally, one would like to iterate through all the indices of
a higher-rank array. Implement a "<code>multifor</code>" looping
construct along the lines of the previous exercise which works as
in the following example:</p>

<p><code>multifor [|5;2;3|] f</code> will call <code>f
[|0;0;0|]</code>, then <code>f [|0;0;1|]</code>, then <code>f
[|0;0;2|]</code>, then <code>f [|0;1;0|]</code>, <code>f
[|0;1;1|]</code>, and so on up to <code>f [|4;1;2|]</code>. In the
end, <code>f</code> will have been called on all the possible indices
of a 5*2*3 rank-3 array, in lexicographically ascending order.
</p>

<p>This should work with an arbitrary number of indices, so that one
could as well loop through the multi-indices of the entries of a
10*10*10*10 array.
</p>
</li>

<li>
<p>The Java programming language knows a "<code>try [code] finally
[cleanup-code]</code>" statement. (Actually, this is part of
<code>try/catch/finally</code>). This will call <code>[code]</code> in
such a way that regardless of how execution flow leaves this piece of
program code, either via returning a value, or via an exception, the
<code>[cleanup-code]</code> will be evaluated as the call stack is
unwound. In Common LISP, the equivalent construct is called
<code>UNWIND-PROTECT</code>. Implement an OCaml function that mimics
this behaviour as closely as possible, taking two function arguments
that represent <code>[code]</code> and <code>[cleanup-code]</code>,
similar to the previous exercises.</p></li>
<p></p>


</ol>
<p></p>

<h2>A Final Word</h2>

<p>There is much more to be known about OCaml than what could be
covered in this crash course so far. We did not speak in detail about
modules, compilation, tools such as <code>OCamlMakefile</code>, the
debugger, the C interface, and much more. Nevertheless, this
introduction should have given enough background to (1) attack some
real interesting problems using OCaml, and (2) provide a solid basis
for reading and understanding the documentation. The last lecture is
an addendum covering highly technical details most people will not
want to care about anyway.
</p>


<br><hr><br>
    <h1>Modules and the C interface</h1>
    
    <h2>Modules</h2>
    
<p>With very few exceptions, our discussion of OCaml so far only
covered the "core language", as well as some of the standard
libraries. We can by now write and even compile small OCaml scripts,
but we cannot yet build our own libraries. It is now time to change
this. In this lesson, we will not always be as detailed with our
explanations as in the previous ones, but rather take the pragmatic
route and see that we get going - even though this perhaps will
inevitably mean that we will occasionally have to deal with exotic
situations which we cannot fully understand using only the material
presented here. On the other hand, some very basic and general things
have to be covered in great detail, as it is essential to develop an
understanding for the underlying machinery.
</p>

<p>We first have to take a closer look at the compiler. One should
keep in mind that actually, OCaml is not one language, but two, which,
however, are syntactically almost the same (up to toplevel directives,
that is). For many compiler languages, the process of turning an idea
into working code will utilize files of many different types, some of
them source files, some of them intermediate files. This is just as
true for a C compiler (<code>.c</code>, <code>.h</code>,
<code>.o</code>, <code>.so</code>, <code>.s</code>) as it is for, say,
TeX (<code>.tex</code>, <code>.dvi</code>, <code>.aux</code>,
<code>.log</code>), and also holds for OCaml. For some systems, file
endings are just a convention, while others enforce certain
names. OCaml is of the latter type: a file named
<code>something.ml</code> will - for example - always be treated as an
OCaml source file. What other file types does the compiler know about?
</p>

<p>
</p><center>
<table border="1" width="70%"><tbody><tr><th colspan="2">OCaml file types</th></tr>
<tr><td width="30%">Type (machine code equivalent given in parens if different)</td><td>Meaning</td></tr>
<tr><td><code>.ml</code></td><td>OCaml source file</td></tr>
<tr><td><code>.mli</code></td><td>OCaml interface file</td></tr>
<tr><td><code>.cmi</code></td><td>Compiled interface</td></tr>
<tr><td><code>.cmo (.cmxo)</code></td><td>Compiled object</td></tr>
<tr><td><code>.cma (.cmxa)</code></td><td>Compiled object archive (library)</td></tr>
<tr><td><code>.c</code></td><td>C source code</td></tr>
<tr><td><code>.o</code></td><td>C object code</td></tr>
<tr><td><code>.so</code></td><td>C shared object library</td></tr>
</tbody></table></center>
<p></p>

<p>It is nice that the OCaml compiler knows about C source files as
well and will call the C compiler when necessary.  One detail worth to
know is that the manpage of the <code>ocamlc(3)</code> compiler is
incomplete. One may for example wish to explicitly specify which C
compiler to use (say, <code>gcc</code> or intel's <code>icc</code>, or
use a C compiler wrapper such as <code>mpicc</code>). This is
possible, and <code>ocamlc --help</code> as well as the OCaml online
documentation tell us that we can use the <code>-cc</code> option for
this, but this is not mentioned in the manpage. Also note that the
order of objects given to the compiler does matter.
</p>

<p>What is this <code>.mli</code> interface thing about? A
<code>.ml</code> file provides a compilation unit. We may now choose
not to export all the definitions in that compilation unit to the
outside world, or make some type definitions opaque (that is, we just
tell the outside about the existence of a given type, but not its
complete realization). This is what the <code>.mli</code> file is
for. Furthermore, we may want to put extra documentation into that
file - which is provided in the form of comments that adhere to
certain conventions. <code>ocamldoc</code> will then allow us to
automatically generate HTML and latex documentation for our module. A
<code>.mli</code> file is more or less just the list of variable types
and type definitions which the toplevel prints out if we load a
<code>.ml</code> file. It can be auto-generated from a
<code>.ml</code> file (for later editing) via <code>ocamlc -i
code.ml</code>. The fine print says that we acually often can also go
without such an interface file, but as a matter of good practice, we
should always provide one.
</p>

<p>The behaviour of OCaml with respect to re-compilation of modules
often is somewhat picky. It will include cryptographic hash
fingerprints in compiled interface <code>.cmi</code> definitions and a
few other places, and as a consequence, if library/module B uses some
independent module A, which undergoes a change (and if this is even
only the addition of one more function), then B will complain that its
idea of the interface of A no longer matches reality, that is, B has
to be recompiled because A was. Such behaviour is somewhat unexpected
in particular to C programmers, and there have been long discussions
whether this makes sense and is a good thing or not. As one may guess,
it does not especially make life easy for module maintainers and in a
sense, Ocaml tries to be "holier than CVS version control" here.
</p>

<p>Due to very similar issues (<em>especially</em> with component
dependencies), OCaml may feel quite a bit unnatural for seasoned C
developers when it comes to writing Makefiles. Indeed, many newcomers
seem to experience major difficulties here. Hence, one normally is
much better off using a pre-existing tool that deals with most of this
makefile complexity: <code>OCamlMakefile</code>. This is a Makefile
that is to be included in our own Makefiles and provides quite a lot
of intelligence that does most of the really dirty work. In Debian,
it's part of the <code>ocaml-tools</code>
package. <code>OCamlMakefile</code> cooperates quite well with
<code>ocamlfind</code>, which is a package and dependency management
system for OCaml. (Objective Caml provides a simple library location
and loading framework right out of the box, as can be seen by giving a
directive like <code>#load "unix.cma"</code> to the toplevel, but
<code>findlib</code> is much more flexible.) The
<code>ocamlfind</code> Debian package is called
<code>ocaml-findlib</code>.
</p>

<p>When installing <code>ocamlfind</code>, one may want to make a few
adjustments, especially if multiple users in the Unix group
<code>ocaml</code> are supposed to be able to install libraries
system-wide. Oh the author's system, this looks as follows:
</p>

<p>
</p><center>
<table border="1"><tbody><tr><th><code>/etc/ocamlfind.conf</code></th></tr>
<tr><td><pre><code>
destdir="/usr/local/lib/ocaml"
path="/usr/local/lib/ocaml:/usr/lib/ocaml/3.08.3:/usr/lib/ocaml/3.08.3/METAS"
</code></pre></td></tr>
</tbody></table></center>
<p></p>

<p>Further adjustments may have to be made to the file
<code>/usr/lib/ocaml/3.08.3/ld.conf</code> (This is unfortunate and
should not be, as configuration files should always reside under
<code>/etc</code> in Debian):
</p>

<p>
</p><center>
<table border="1"><tbody><tr><th><code>/usr/lib/ocaml/3.08.3/ld.conf</code></th></tr>
<tr><td><pre><code>
/usr/local/lib/ocaml/stublibs
/usr/lib/ocaml/3.08.3/stublibs
</code></pre></td></tr>
</tbody></table></center>
<p></p>

<p>The <code>/usr/local/lib/ocaml</code> structure then was re-built
in such a way that the <code>stublibs</code> directory is a direct
subdirectory of this. <code>/usr/local/lib/ocaml</code> is owned by
user root, group ocaml, and has mode 2775. Packages are installed as
direct subdirectories.
</p>


<h3>The structure of a simple module</h3>

<p>In the project we are working on right now at the University of
Southampton, there is a catch-it-all module which collects small
useful snippets that are not present in the OCaml standard library and
do not justify creating an individual new module either. In this
module, one can find functions for degree to radian conversion just as
well as a function to generate a random number with gaussian
distribution. The directory looks like this:
</p>

<p>
</p><center>
<table border="1">
<tbody><tr><th>In the <code>snippets</code> module's directory</th></tr>
<tr><td><pre><code>
tf@ouija:~/ocaml/snippets$ ls -la
total 84
drwxr-xr-x   4 tf tf  4096 Jan 11 22:12 .
drwxr-xr-x  23 tf tf  4096 Nov 21 15:08 ..
drwxr-xr-x   2 tf tf  4096 Nov 21 15:08 CVS
-rw-r--r--   1 tf tf   267 Nov 11 19:22 META
-rw-r--r--   1 tf tf   525 Nov 11 19:20 Makefile
drwxr-xr-x   3 tf tf  4096 Nov 21 15:08 examples
-rw-r--r--   1 tf tf 44431 Nov 22 16:41 snippets.ml
-rw-r--r--   1 tf tf 14678 Nov 22 16:43 snippets.mli

tf@ouija:~/ocaml/snippets$ # let us stay for a while
tf@ouija:~/ocaml/snippets$ # The important pieces are:
tf@ouija:~/ocaml/snippets$ cat META
<span style="color: blue;">
# Specifications for the "snippets" library:
requires = "unix str"
description = "Snippets"
version = "0.1"
directory = "/usr/local/lib/ocaml/snippets"
browse_interfaces = " Snippets "
archive(byte) = "snippets.cma"
archive(native) = "snippets.cmxa"
</span>
tf@ouija:~/ocaml/snippets$ cat Makefile
<span style="color: blue;">
OCAMLMAKEFILE = /usr/share/ocaml-tools/OCamlMakefile

# We put those in so that they are in place right from the start.
# Do not want to see any surprises later on.

#PACKS = extlib

PACKS = unix str

LIBS = 

OCAMLLIBPATH=

INCDIRS=

LIBDIRS=

EXTLIBDIRS=

# We turn on debugger support in all our modules for now.
OCAMLBCFLAGS = -g
OCAMLBLDFLAGS = -g
RESULT = snippets

SOURCES = snippets.ml snippets.mli

all: byte-code-library native-code-library

mrproper: clean
	rm -f *~ *.cmi *.cmo *.top *.so

.PHONY: mrproper

include $(OCAMLMAKEFILE)
</span>
</code></pre></td></tr>
</tbody></table></center>
<p></p>

<p>Note that by default, the <code>all:</code> target will build both
a bytecode and native-code library. Other interesting dependencies we
may want to include here are "<code>doc</code>" (auto-generate
documentation) and "<code>top</code>" (build a toplevel) - maybe even
"<code>native-code</code>" to build a fast compiled standalone
executable. These are the most common ones; see the OcamlMakeFile
documentation for information on what else there is.
</p>

<p>Note that we furthermore define a "<code>mrproper</code>" symbolic
target for complete cleanup. This is nice and convenient. The name, by
the way, was taken from the Linux kernel source makefiles. Now, if
this builds correctly, we can use the power of
<code>OCamlMakefile</code> and <code>findlib</code> to install it with
a simple <code>make libinstall</code> and remove it again with a
<code>make libuninstall</code>. If some other package now depended on
<code>snippets</code>, we would add <code>snippets</code> to the
<code>PACKS=</code> line in the Makefile, as well as to the
<code>requires</code> line of the <code>META</code> file, which may
then e.g. look like this: <code>requires = "snippets qhull
mt19937"</code>. The META file is used by findlib.
</p>

<p>This more or less tells us how to build and install simple OCaml
modules. "Simple" in the sense that we do not use sophisticated
foreign language interface techniques, but just basic plain OCaml.
</p>

<p>If we want to use such an installed package from the toplevel, the
magical incantations are:
</p>

<p>
</p><center>
<table border="1"><tbody><tr><th><code>Loading findlib packages from the toplevel - example</code></th></tr>
<tr><td><pre><code>
#use "topfind";;
#require "snippets";;

open Snippets;;
</code></pre></td></tr>
</tbody></table></center>
<p></p>

<p>...where the <code>open</code> just imports all the symbols into our
namespace so that we can refer to them directly instead of having to
use names such as <code>Snippets.deg_rad</code>. Note that the
compiler does not understand toplevel directives. So, whenever we have
the situation that some piece of OCaml code (a small script, say) is
to be fed both into the toplevel and the compiler, it makes sense to
add a small toplevel loader wrapper script which just contains the
package loading directives, plus a final <code>#use "mycode.ml";;</code>
directive which then loads the "interesting" code.
</p>


    <h2>The C Interface</h2>
    <h3>(Things you never ever wanted to know, but were forced to find out)</h3>

<p>Even if we had the most elegant, most efficient, most effective
language available, its value would be reduced greatly if it did not
come with an interface to C. The very simple reason for this is that
nowadays, a lot of important functionality is available in the form of
C libraries - especially if speed matters for the task. Sooner or
later, we want to tap that resource, and hence, every language must
provide a C interface, just as every serious programmer should be
somewhat proficient with C (even if he does not use it often).
</p>

<h3>Some very general remarks</h3>

<p>Concerning foreign language interfaces in general, here are
different levels of sophistication, and the answer to the question
what can be achieved depends just as much on the ability of the
language as well as on that of the programmers of both the interface
code and the code to be interfaced. In fact, many things can go wrong,
and should insurmountable problems arise, they are practically always
a consequence of bad design. So, it pays to spend quite some time
thinking about foreign language issues, no matter if one takes on the
role of library implementor, language designer, or interface code
writer.
</p>

<p>One very important point to keep in mind is that it is very easy to
build large and complex systems by combining components which were
never intended to interoperate well. As a rule of thumb, the amount of
internal interface friction in a software project with N components
usually is proportional to N^a, with the exponent a being closer to 2
than to 1. So, the most problematic moments in the development of a
N-component application are whenever there is a version update/change
of at least one component. From this perspective, especially the
philosophy underlying the Debian GNU/Linux system to provide a stable
platform as well as a large library of components whose behaviour is
and stays frozen for long times (up to important bugfixes) comes as a
blessing, and presumably such a concept of behavioural (version)
stability and reliability should find wider recognition as a vital
quality factor.
</p>

<h3>Rule: Keep it simple - do not overdo it!</h3>

<p>Another important general observation: designing the interface to a
foreign language library is a task that often needs a lot of thought
and sometimes a certain amount of experience. One of the major
problems is that the fundamental philosophy underlying the two
languages which are to be bridged is different. (If it were not, at
least one of them would be completely unnecessary.) So, the big
question is how to catch the spirit - the key ideas - underlying the
piece of code to be interfaced and map this in the best possible way
to something that feels smooth from the perspective of the new
language. There is no patent recipe to that question, but there are a
few common observations one should know about. First of all, it is
often a good idea to keep a foreign language interface as direct and
as low level as possible. While it may be tempting to put more
intelligence into the interface and employ the power of the new
language to make things more convenient, this is a double-edged sword,
as it may easily lead to a violation of the <em>principle of least
surprise</em>. In particular if the library in question is well known
and frequently used in its natural environment, one must assume that
many users of the interface will have expectations that were shaped by
the original behaviour. In fact, the author of this lesson still
remembers quite well the shock of finding out that there is a subtle
difference in the behaviour of Perl's built-in <code>fork()</code> and
Unix <code>fork(2)</code>: In case of a fork failure, the latter
returns <code>-1</code> (and sets <code>errno</code> appropriately),
while the former returns <code>undef</code>! That may certainly have
been well meant, but such unexpected surprises may have disastrous
consequences. Another aspect is: the simpler the interface, the less
effort to adjust it to new versions.
</p>

<p>If, however, the target language gives strong safety guarantees
(type safety, bounds checks, crash stability and such), one must
assume that the user of the interfaced library will expect those
safety belts to also work with that particular library. The same holds
for automatic dynamical resource management, such as garbage
collection. So, one usually would like to provide at least these
features in a manually written interface - but again, depending on the
situation, there may be exceptions (e.g. if this turns out to be
prohibitively complicated, or if it is important to stay at the lowest
level, or if it greatly simplifies things, or just if it's too small a
problem to be worth the effort).
</p>

<h3>Rule: Let the machine do it whenever possible</h3>

<p>Writing interface code manually often is a tedious task with many
repetitive steps. True, there are situations where one should use as
much intelligence and wisdom as possible, but there also are
situations where one has to interface dozens of functions in an
uniform way. Then, it is often a good idea not to write all that code
by hand, but use code that automatically generates that part of the
interface code.
</p>

<p>Nowadays, there are tools such as the <em>Simplified Wrapper and
Interface Generator (<a href="http://www.swig.org/">SWIG</a>)</em> that
can help a lot.
</p>

<h3>Rule: Know when not to do it</h3>

<p>Just because something can be done in principle, it need not be a
good idea. If something looks challenging, this may be for a variety
of reasons, one of them being that the author whose work we decided to
build on had chosen an excessively unelegant and clumsy approach,
maybe because he did not fully understand the nature of the
problem. (This is not necessarily a fault of the author. If we only
did things we understand well all the time, there would be virtually
no progress at all! Hence, we desperately need brave souls that tackle
problems which nobody understands properly, and many a breakthrough
was achieved only after a lot of confusion.) Nevertheless, one should
always keep the question in mind: <em>does it really have to be that
way</em>? Can't we achieve the same or a better result with a more
elegant approach, maybe using some other piece of code?
</p>

<p>In particular, whenever you have the impression that you have to
fight against the original author, as his intentions do not at all
match yours, and his code evolves in a different direction than the
one you are interested in, better look for an alternative.
</p>

<h3>Desirable features of a C interface</h3>

<p>As mentioned above, there are different levels of sophistication in
the art of calling foreign functions - from just executing a C
function to print a value to <code>stderr</code> to writing code that
allows one to turn C callback functions into callback functions in the
higher-level language. Other exotic applications may include using the
C compiler at run time to map C code strings into dynamically loaded
shared objects, or telling a C library to use the dynamical memory
management of the higher-level language instead of
<code>malloc(3)/free(3)</code> in order to put its dynamical state into
serializable strings (cf. <a href="http://www.pcre.org/pcre.txt">PCRE</a>).
</p>

<p>Quite in general, one may want a good foreign function interface to
provide the following capabilities:
</p>

<p>
</p><ol>
<li>It is possible to call compiled C code from the language.</li>

<li>It is possible to runtime-link and call C shared object libraries.</li>

<li>It is possible to register callbacks from C into the language.</li>

<li>Calling into C and from there back into the language recursively
"just works as it should". (There are some call stack issues here.)</li>

<li>It is possible to start the high-level language run time system
from within an own C <code>main()</code> function.</li>

<li>It is possible to put code written in the high-level language into
libraries that are callable as C shared object libraries.
</li>

<li>...and this works with any C compiler on your machine (including
in particular compiler wrappers like MPI's <code>mpicc</code>).
</li>

<li>...and it is reasonable and easy to have multiple independent
C-callable <code>.so</code> libraries (that are to be used in
conjunction) utilize code written in the extension language at the
same time.
</li>

<li>One can start the high-level language's
read-eval-print-loop/command-line-interface from within C.
</li>
</ol>
<p></p>

<p>Fortunately, OCaml provides us with a quite powerful C interface
that allows us to do most of the things mentioned above - even if this
sometimes seems to be just by accident. (For example, it is possible
to turn OCaml code into a C-linkable <code>.so</code> shared library
that almost behaves like any other C library, which is great, but this
does not work for 64-bit x86 code.) One problem, however, is that at
present, the documentation is somewhat scattered, and there are
important things to be known which are not well documented at all.
</p>

<h3>OCaml &lt;=&gt;C: first examples</h3>

<p>After these general remarks, it is perhaps appropriate to look at
something more practical and explain the details by means of a few
typical examples. What one should know about the C interface is:
</p>

<p>
</p><ul>
<li>It is documented in Part III (Chapter 18) of the OCaml on-line
documentation.</li>

<li>There is a quite close integration of OCaml and C compilers: the
OCaml compiler will recognize <code>.c</code> source file arguments
and know what to do with them. (See above.)
</li>

<li>Basically, we have to provide C code that can take OCaml values as
argumens and return OCaml values. So, it us up to us (or some foreign
function interface generator) to provide the wrapper code. This is
quite unlike, say, the C interface of CMU Common Lisp, where one can
use <code>alien-funcall</code> and <code>extern-alien</code> to
directly call code from a C library (i.e. all the wrapping information
is provided in Lisp, not C).
</li>

<li>As a consequence of the previous point, we have to be make sure
that whenever we allocate new composite OCaml values (such as tuples)
from within C, we live in harmony with the garbage collector.
</li>

<li>If we do something wrong, this may easily lead to heap corruption,
i.e. mess up the internal memory management data structures of
OCaml. In most situations, this will mean that doing an explicit call
to the OCaml garbage collector via "<code>Gc.full_major ();;</code>"
will result in a program segfault. ("Garbage collection" customarily
is abbreviated as "GC".)
</li>
</ul>
<p></p>

<p>But let us have a look at the perhaps simplest example of a C
function exported to OCaml. We will wrap this up in a dedicated
package, which we call "<code>c_examples</code>". We start out by
creating a corresponding directory, into which we put the following
files:
</p>

<p>
</p><center>
<table border="1">
<tbody><tr><th>Directory Structure</th></tr>
<tr><td><pre><code>
tf@alpha:~/ocaml-tutorial/c_examples$ ls -la
total 28
drwxr-xr-x  2 tf tf 4096 2006-01-12 14:35 .
drwxr-xr-x  3 tf tf 4096 2006-01-12 14:24 ..
-rw-r--r--  1 tf tf  487 2006-01-12 14:34 c_examples_impl.c
-rw-r--r--  1 tf tf   86 2006-01-12 14:33 c_examples.ml
-rw-r--r--  1 tf tf   25 2006-01-12 14:30 c_examples.mli
-rw-r--r--  1 tf tf  435 2006-01-12 14:34 Makefile
-rw-r--r--  1 tf tf  252 2006-01-12 14:25 META
</code></pre></td></tr>

<tr><th><hr></th></tr>
<tr><th>META</th></tr>
<tr><td><pre><code>
# Specifications for the "c_examples" library:
requires = ""
description = "C_examples"
version = "0.1"
directory = "/usr/local/lib/ocaml/c_examples"
browse_interfaces = " C_examples "
archive(byte) = "c_examples.cma"
archive(native) = "c_examples.cmxa"
</code></pre></td></tr>

<tr><th><hr></th></tr>
<tr><th>Makefile</th></tr>
<tr><td><pre><code>
OCAMLMAKEFILE = /usr/share/ocaml-tools/OCamlMakefile

PACKS =

LIBS = 

OCAMLLIBPATH=

INCDIRS=

LIBDIRS=

EXTLIBDIRS=

# We turn on debugger support in all our modules for now.
OCAMLBCFLAGS = -g
OCAMLBLDFLAGS = -g
RESULT = c_examples

SOURCES = c_examples.mli c_examples.ml c_examples_impl.c

all: byte-code-library native-code-library top

mrproper: clean
	rm -f *~ *.cmi *.cmo *.top *.so

.PHONY: mrproper

include $(OCAMLMAKEFILE)
</code></pre></td></tr>

<tr><th><hr></th></tr>
<tr><th>c_examples.mli</th></tr>
<tr><td><pre><code>

val square: int -&gt; int

</code></pre></td></tr>

<tr><th><hr></th></tr>
<tr><th>c_examples.ml</th></tr>
<tr><td><pre><code>

external square: int -&gt; int = "c_ex_square";;

</code></pre></td></tr>

<tr><th><hr></th></tr>
<tr><th>c_examples_impl.c</th></tr>
<tr><td><pre><code>
/* 
   C examples: implementation
 */

/* The "usual" OCaml includes */

#include &lt;caml/alloc.h&gt;
#include &lt;caml/callback.h&gt;
#include &lt;caml/fail.h&gt;
#include &lt;caml/memory.h&gt;
#include &lt;caml/misc.h&gt;
#include &lt;caml/mlvalues.h&gt;

#include &lt;stdio.h&gt;
/* For debugging - we want to have access to printf, stderr and such */

CAMLprim c_ex_square(value ml_nr)
{
  CAMLparam1(ml_nr);
  
  int nr,result;

  nr=Int_val(ml_nr);

  result=nr*nr;

  CAMLreturn(Val_int(result));
}

</code></pre></td></tr>
</tbody></table></center>
<p></p>

<p>Next, to demonstrate that this actually works, we do the following:
</p>

<p>
</p><center>
Building and using the C interface<table border="1"><tbody><tr></tr>
<tr><td><pre><code>
tf@alpha:~/ocaml-tutorial/c_examples$ make
make[1]: Entering directory `/home/tf/ocaml-tutorial/c_examples'
(...)
make[1]: Leaving directory `/home/tf/ocaml-tutorial/c_examples'
tf@alpha:~/ocaml-tutorial/c_examples$ ./c_examples.top 
        Objective Caml version 3.08.3

# C_examples.square;;
- : int -&gt; int = &lt;fun&gt;
# C_examples.square 10;;
- : int = 100
# 

tf@alpha:~/ocaml-tutorial/c_examples$ make libinstall
make[1]: Entering directory `/home/tf/ocaml-tutorial/c_examples'
(...)
Installation successful.
tf@alpha:~/ocaml-tutorial/c_examples$ ocaml
        Objective Caml version 3.08.3

# #use "topfind";;
- : unit = ()
Findlib has been successfully loaded. Additional directives:
  #require "package";;      to load a package
  #list;;                   to list the available packages
  #camlp4o;;                to load camlp4 (standard syntax)
  #camlp4r;;                to load camlp4 (revised syntax)
  #predicates "p,q,...";;   to set these predicates
  Topfind.reset();;         to force that packages will be reloaded
  #thread;;                 to enable threads

- : unit = ()
# #require "c_examples";;
/usr/local/lib/ocaml/c_examples: added to search path
/usr/local/lib/ocaml/c_examples/c_examples.cma: loaded
# open C_examples;;
# square 5;;
- : int = 25
# 
</code></pre></td></tr>
</tbody></table></center>
<p></p>

<p>Now that we have seen that this actually works, let us look in some
more detail at what is going on here. Clearly, the <code>.mli</code>
file just specifies what to export - as we only provide one interfaced
function anyway, this is very straightforward. In the <code>.ml</code>
file, we declare our function as <code>external</code>,
i.e. implemented by a piece of code adhering to C linking conventions,
whose linker name we give as well. The implementation of that function
takes as argument an OCaml value, and has to return an OCaml
value. Here, this is supposed to encode an integer, and we need
conversion functions to map OCaml values to C values and back. For
<code>int</code>, this is pretty straightforward, but we have to keep
in mind that the OCaml integer range is strictly smaller than the C
integer range!
</p>

<p>Note the use of <code>CAMLparamX()</code> and
<code>CAMLreturn</code> macros to declare and handle entities of type
<code>value</code> that represent OCaml values. These are necessary to
live in harmony with the garbage collector. Indeed, there are more of
this type, the next most important ones being the
<code>CAMLlocalX()</code> macros. More about this later.
</p>

<p>We will now proceed to extend our example with further definitions
that demonstrate a few basic techniques. First, let us see how to wrap
up higher order functions, how to pass floatingpoint numbers, and how
to add primitive debugging facilities to the C code: we add the
following definitions and then rebuild:
</p>

<p>
</p><center>
<table border="1">
<tbody><tr><th>Extending our example</th></tr>
<tr><th><code>c_examples.mli</code></th></tr>
<tr><td><pre><code>

val hypotenuse: float -&gt; float -&gt; float

</code></pre></td></tr>

<tr><td><hr></td></tr>
<tr><th>c_examples.ml</th></tr>
<tr><td><pre><code>

external hypotenuse: float -&gt; float -&gt; float = "c_ex_hypotenuse";;

</code></pre></td></tr>


<tr><td><hr></td></tr>
<tr><th>c_examples_impl.c</th></tr>
<tr><td><pre><code>

CAMLprim c_ex_hypotenuse(value ml_x1, value ml_x2)
{
  CAMLparam2(ml_x1,ml_x2);

  double x1,x2, result;

  x1=Double_val(ml_x1);
  x2=Double_val(ml_x2);
  
  result=sqrt(x1*x1+x2*x2);

  fprintf(stderr,"CALL: c_ex_hypotenuse(%f,%f) -&gt; %f\n",x1,x2,result);
  fflush(stderr);
  CAMLreturn(copy_double(result));
}

</code></pre></td></tr>

</tbody></table>
</center>
<p></p>

<p>Indeed, after rebuilding:
</p>

<p>
</p><center>
Using the <code>hypotenuse</code> example<table border="1"><tbody><tr></tr>
<tr><td><pre><code>
tf@alpha:~/ocaml-tutorial/c_examples$ make
make[1]: Entering directory `/home/tf/ocaml-tutorial/c_examples'
(...)
make[1]: Leaving directory `/home/tf/ocaml-tutorial/c_examples'
tf@alpha:~/ocaml-tutorial/c_examples$ ./c_examples.top 
        Objective Caml version 3.08.3

# C_examples.hypotenuse;;
- : float -&gt; float -&gt; float = &lt;fun&gt;
# C_examples.hypotenuse 3.0 4.0;;
CALL: c_ex_hypotenuse(3.000000,4.000000) -&gt; 5.000000
- : float = 5.
#
</code></pre></td></tr>
</tbody></table></center>
<p></p>

<p>The process of wrapping up and unwrappng values from one language
for another language sometimes is called <em>marshalling</em>, but
nowadays this more often refers to "serialization", that is, mapping a
piece of data with potentially complex structure to a string to store
it and retrieve it later on. (Incidentally, OCaml provides a
<code>Marshal</code> library which is all about serialzation.) As we
see, the names of the functions and macros we use to do the mapping is
somewhat non-uniform, but so is their internal mechanics:
<code>Int_val</code> is not much more than a very simple bit-shifting
macro, while <code>copy_double</code> will have to heap-allocate space
to hold a double-float value.
</p>

<p>One should know that higher order functions can only be wrapped in
this way if they have up to five arguments. (Usually, this is enough.) 
Other techniques have to be used for functions with more arguments.
</p>

<h3>Wrapping functions from a library</h3>


<p>Let us try something slightly more challenging next: we want to
wrap some functions from a library other than <code>libc</code> or
<code>libm</code> and pass around strings. Let us use the low level
X11 library <code>xlib</code> here. In particular, we want to be able
to open and close a connection to an X display and obtain the X server
vendor identification string. We hence add the following to our example:
</p>

<p>
</p><center>
<table border="1">
<tbody><tr><th>Extending our example: xlib</th></tr>
<tr><th><code>Makefile</code></th></tr>
<tr><td><pre><code>

LDFLAGS = -L/usr/X11R6/lib -lX11

OCAMLMKLIB = ocamlmklib -ldopt -L/usr/X11R6/lib -ldopt -lX11

</code></pre></td></tr>

<tr><td><hr></td></tr>
<tr><th><code>c_examples.mli</code></th></tr>
<tr><td><pre><code>

type x_display

val x_open_display: string -&gt; x_display

val x_display_is_valid: x_display -&gt; bool
(* This is not an Xlib function! *)

val x_close_display: x_display -&gt; unit

val x_server_vendor: x_display -&gt; string

</code></pre></td></tr>

<tr><td><hr></td></tr>
<tr><th>c_examples.ml</th></tr>
<tr><td><pre><code>
type x_display

external x_open_display: string -&gt; x_display = "c_ex_x_open_display_v1";;

external x_display_is_valid: x_display -&gt; bool = "c_ex_x_display_is_valid_v1";;

external x_close_display: x_display -&gt; unit = "c_ex_x_close_display_v1";;

external x_server_vendor: x_display -&gt; string = "c_ex_x_server_vendor_v1";;
</code></pre></td></tr>
<tr><td><hr></td></tr>
<tr><th>c_examples_impl.c</th></tr>
<tr><td><pre><code>

#define Store_c_field(block,offset,x) (Field(block,offset)=(value)x)

#include &lt;X11/Xlib.h&gt;
/* Goes to the top! */

/* (...) */

CAMLprim c_ex_x_open_display_v1(value ml_display_name)
{
  CAMLparam1(ml_display_name);

  Display *disp;

  disp=XOpenDisplay(String_val(ml_display_name));
  
  CAMLlocal1(block);

  block=alloc(1, Abstract_tag);
  /* Note that Abstract_tag &gt; No_scan_tag
     - cf. sec. 18.2.2 of the OCaml manual
     
     Furthermore note that we just assume that a value cell
     is just as large as a void pointer. This is satisfied
     on all platforms, but we may want to be more careful
     nevertheless.
  */

  Store_c_field(block,0,(value)disp);

  CAMLreturn(block);
}

CAMLprim c_ex_x_display_is_valid_v1(value ml_display)
{
  CAMLparam1(ml_display);

  Display *disp;
  int is_valid;

  disp=(Display *)Field(ml_display,0);

  is_valid=(disp!=0);
  
  fprintf(stderr,"x_display_is_valid(disp=%08x) -&gt; %d\n",disp, is_valid);
  fflush(stderr);
  
  CAMLreturn(Val_bool(is_valid));
}

CAMLprim c_ex_x_close_display_v1(value ml_display)
{
  CAMLparam1(ml_display);

  Display *disp;
  int is_valid;

  disp=(Display *)Field(ml_display,0);

  is_valid=(disp!=0);
  
  if(is_valid)
    {
      XCloseDisplay(disp);
      Store_field(ml_display,0,(value)0);
    }

  CAMLreturn(Val_unit);
}

CAMLprim c_ex_x_server_vendor_v1(value ml_display)
{
  CAMLparam1(ml_display);

  Display *disp;
  int is_valid;
  char *vendor_id="";

  disp=(Display *)Field(ml_display,0);

  is_valid=(disp!=0);
  
  if(is_valid)
    {
      vendor_id=ServerVendor(disp);
      /* This is a macro - there also is an
	 XServerVendor function in libx11.
      */
    }

  CAMLreturn(copy_string(vendor_id));
}
</code></pre></td></tr>

</tbody></table>
</center>
<p></p>

<p>
</p><center>
<table border="1"><tbody><tr><th>Testing the <code>xlib</code> functions</th></tr>
<tr><td><pre><code>
tf@alpha:~/ocaml-tutorial/c_examples$ make
make[1]: Entering directory `/home/tf/ocaml-tutorial/c_examples'
(...)
make[1]: Leaving directory `/home/tf/ocaml-tutorial/c_examples'
tf@alpha:~/ocaml-tutorial/c_examples$ ./c_examples.top 
        Objective Caml version 3.08.3

# open C_examples;;
# let disp = x_open_display ":0.0";;
val disp : C_examples.x_display = &lt;abstr&gt;
# x_display_is_valid disp;;
x_display_is_valid(disp=0808d1e0) -&gt; 1
- : bool = true
# x_server_vendor disp;;
- : string = "The XFree86 Project, Inc"
# x_close_display disp;;
- : unit = ()
# x_display_is_valid disp;;
x_display_is_valid(disp=00000000) -&gt; 0
- : bool = false
</code></pre></td></tr>
</tbody></table></center>
<p></p>

<p>This is already quite nice, but it opens up new questions. If we
"lose" an Xlib pointer, it will be garbage collected, but the
connection stays open. We might instead prefer to have that particular
case handled in such a way that an incidentally forgotten active Xlib
connection that is garbage collected will be closed
automatically. Furthermore, might even want to have Xlib functions
that are called on an inactive/invalid display raise an exception. All
this can indeed be implemented, and will be our next major
example. But before we consider this, let us make an excursion that
explains some more of the background mechanics underlying the low
level implementation and inparticular the C interfaces of many
functional languages.
</p>

<h3>Some background on functional language implementations</h3>

<p>If look under the hood of all the fancy syntax and ignore code
generator issues for now, the relevant questions at the lowest level
are: how are the fundamental data types implemented and mapped to
machine data types, and what conventions are in place that have to be
respected? One important component in this game is the Garbage
Collector, which will from time to time scan the heap (= all the
memory managed by the language where values can reside) and recycle
pieces of data that have become un-reachable and hence ballast.
</p>

<p>What type information has to be available at run time? At the very
least, the system has to be able to find out whether a certain OCaml
value, stored in a given region of memory, contains references to
other OCaml values or not. The Garbage Collector has to know this so
that it can scan all the memory that has been allocated in our running
program for "live" objects and declare all other data as "dead", that
is, unreachable. This evidently means that the memory representation
of an OCaml array (or tuple, say), which may reference (i.e. contain
pointers to) other OCaml values, must contain information about the
length of the array (or tuple). One could imagine that from the
perspective of the garbage collector, the world of hierarchically
constructed types is much simpler, and that indeed, arrays and tuples
might even have precisely the same representation in memory: Both
represent vectors of OCaml values, and even if they behave very
differently from the programmer's perspective, there is no reason why
they should not be just the same internally: after all, the question
what one can do with these data is resolved entirely at compile time.
</p>

<p>So, we may imagine an internal data representation scheme where all
constant-time addressable vectors (tuples, arrays) appear as a region
of memory that contains a single header word (or at most a few words)
that provides length information, followed by pointers to the
contents. This actually would be quite similar to the way how data are
represented internally in the GCL (Gnu Common Lisp) system (see <a href="http://cvs.savannah.gnu.org/viewcvs/gcl/gcl/h/object.h?rev=1.60&amp;view=markup"><code>object.h</code>
in the GCL sources</a>, especially the definition of "<code>union
lispunion</code>"), only that the structure of the header is a little
bit more complicated, and we retain enough information to derive the
actual concrete type at run time - which we have to, as LISP is
dynamically typed. Non-compiler scripting languages like Perl or
Python, which also are dynamically typed, use similar approaches, but
typically are way more verbose in their internal value data structures
(see e.g. <a href="http://cvs.sourceforge.net/viewcvs.py/python/python/dist/src/Include/object.h?rev=2.22">The
corresponding definition of <code>typedef struct _object (...)
PyObject</code></a> and the corresponding comments in the Python
sources), and frequently include in particular a reference count, as
they usually do not have a proper garbage collection (which, by the
way, is a shame, given the existence of the very powerful <a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/">Boehm-Demers-Weiser</a>
garbage collector library).
</p>

<p>Suppose we stick with such a scheme where every value is
represented by a pointer to a piece of memory that holds all the
data. Whenever we pass even the smallest piece of data - like an
ordinary machine integer number - into a function, the system first
has to do dynamic memory allocation to obtain space where to put the
number, adorn it with some header that says, basically, "there is only
this single one word of data, and it is not a pointer to further
values", and then pass a pointer to that piece of memory. The
recipient will then have to look up the number through that
pointer. Now, this "boxing" and "unboxing" is quite a lot of time
consuming overhead, as it is ubiquituous and hence has to be done over
and over again. Therefore, it is evidently desirable to have a
compiler that is intelligent enough to avoid unnecessary boxing (maybe
via inlining) for purely internal functions that are not visible to
the outside. However, when calling a function from an independent
binary-code library, we presumably will have to go through this boxing
and unboxing.
</p>

<p>Imagine creating something as simple as an array of one million
integers. If OCaml used the scheme suggested right above, we would
require two data words (32 bit on 32 bit machines) to represent every
integer, and have an array of pointers, so we would need three words
of memory to encode a single word of data! Clearly, this is a highly
unsatisfactory situation. (Indeed, this is just exactly what happens
with GCL: <a href="#gcl-alloc">see!</a>) Can this be avoided?
Actually, one might think so, as we have all the type information available
at compile time that allows us to discern what's a pointer to a value
and what's just raw data. But consider the following example:
</p>

<p>
</p><center>
<table border="1"><tbody><tr><th></th></tr>
<tr><td><pre><code>

let wrap_up z =
  let wrap_me1 x = ((x,x),x) in
  let wrap_me2 x = wrap_me1 (wrap_me1 x) in
  let wrap_me4 x = wrap_me2 (wrap_me2 x) in
  wrap_me4 z
;;

(* Example:

# wrap_up;;
- : 'a -&gt;
    ((((((('a * 'a) * 'a) * (('a * 'a) * 'a)) * (('a * 'a) * 'a)) *
       (((('a * 'a) * 'a) * (('a * 'a) * 'a)) * (('a * 'a) * 'a))) *
      (((('a * 'a) * 'a) * (('a * 'a) * 'a)) * (('a * 'a) * 'a))) *
     (((((('a * 'a) * 'a) * (('a * 'a) * 'a)) * (('a * 'a) * 'a)) *
       (((('a * 'a) * 'a) * (('a * 'a) * 'a)) * (('a * 'a) * 'a))) *
      (((('a * 'a) * 'a) * (('a * 'a) * 'a)) * (('a * 'a) * 'a)))) *
    (((((('a * 'a) * 'a) * (('a * 'a) * 'a)) * (('a * 'a) * 'a)) *
      (((('a * 'a) * 'a) * (('a * 'a) * 'a)) * (('a * 'a) * 'a))) *
     (((('a * 'a) * 'a) * (('a * 'a) * 'a)) * (('a * 'a) * 'a)))
= &lt;fun&gt;
# wrap_up 3;;
- : (((((((int * int) * int) * ((int * int) * int)) * ((int * int) * int)) *
       ((((int * int) * int) * ((int * int) * int)) * ((int * int) * int))) *
      ((((int * int) * int) * ((int * int) * int)) * ((int * int) * int))) *
     ((((((int * int) * int) * ((int * int) * int)) * ((int * int) * int)) *
       ((((int * int) * int) * ((int * int) * int)) * ((int * int) * int))) *
      ((((int * int) * int) * ((int * int) * int)) * ((int * int) * int)))) *
    ((((((int * int) * int) * ((int * int) * int)) * ((int * int) * int)) *
      ((((int * int) * int) * ((int * int) * int)) * ((int * int) * int))) *
     ((((int * int) * int) * ((int * int) * int)) * ((int * int) * int)))
=
((((((((3, 3), 3), ((3, 3), 3)), ((3, 3), 3)),
    ((((3, 3), 3), ((3, 3), 3)), ((3, 3), 3))),
   ((((3, 3), 3), ((3, 3), 3)), ((3, 3), 3))),
  ((((((3, 3), 3), ((3, 3), 3)), ((3, 3), 3)),
    ((((3, 3), 3), ((3, 3), 3)), ((3, 3), 3))),
   ((((3, 3), 3), ((3, 3), 3)), ((3, 3), 3)))),
 ((((((3, 3), 3), ((3, 3), 3)), ((3, 3), 3)),
   ((((3, 3), 3), ((3, 3), 3)), ((3, 3), 3))),
  ((((3, 3), 3), ((3, 3), 3)), ((3, 3), 3))))
</code></pre></td></tr>
</tbody></table></center>
<p></p>

<p>(Incidentally, this is also a nice example that shows that the
complexity of the type of an expression can grow at least
exponentially with the size of the expression.) What code would the
compiler have to generate so that the garbage collector can know which
entries of all the tuples in this example hold raw data, and which
hold pointers to tuple values? If you think about it long enough, you
will come to the conclusion that actually, we require one bit of
information for every tuple slot. We might conceive collecting these
in a bit-vector which we place right after the tuple header word. This
may indeed be possible, but would make the garbage collector somewhat
clumsy. The approach usually taken instead makes use of the
observation that pointers to values are aligned to divisible-by-four
addresses. That is, the two least significant bits of these pointers
are unused, and always zero. Suppose now we implement the following
scheme: value references will not take the form of ordinary memory
pointers to the address where the referenced value lies, but instead
be pointers to that address plus one. When we want to use this as a
pointer, we use CPU instructions with fixed-offset addressing that
cancel this off-by-one. (This is not a problem for CISC CPUs, which
have such addressing modes in their assembly language opcode set, and
also not a problem for superscalar RISC CPUs, which just have to do one
more offset calculation on one of their integer units - and actually,
speeding up offset calculations is just one of the major reasons why
they do have more than one integer unit (and usually just one memory
access unit) in parallel.) We now declare that every tuple entry whose
least significant bit is a "one" is such a special pointer, and
everything that has a zero as its least significant bit is an
"immediate value", that is, the word itself carries all the data.
</p>

<p>In particular, we may encode <code>true</code> and
<code>false</code> as the binary values <code>0b00</code> and
<code>0b10</code>. The integer <code>N</code> we encode as
<code>N*2</code>. Addition and subtraction will still work as usual,
but when we multiply or divide, we have to do one additional
bit-shifting operation (which usually is quite little effort in
comparison to the multiplication). This means that we will not be able
to discern the memory representations of, say, <code>1</code> and
<code>true</code>, but this does not matter, as it is of no relevance
to the garbage collector, and all conflicts that may happen have been
prevented by the compile-time type checking. Likewise, we can encode
single characters as immediate values. Functions such as
<code>Char.code</code> then may be just eliminated by the compiler.
</p>

<p>Such a pointer tagging scheme is what most functional compiler
systems use nowadays. There are, however, differences in the tagging
schemes implemented. CMUCL/SBCL for example align all memory cells to
8-byte boundaries and use the three least significant bits as type
tags to discern cons cells, characters, structures, arrays, etc. See
<a href="http://cvs.sourceforge.net/viewcvs.py/*checkout*/sbcl/sbcl/doc/cmucl/internals/Attic/object.tex?content-type=text%2Fplain&amp;rev=1.1.1.1">object.tex</a>
in the CVS sources. OCaml chooses to use a least significant bit of 1
to denote integers, which is very unusual. Other systems may implement
other slight variations on the general subject, such as using high
bits instead of low bits. An interesting but very useful curiosity
that works without any extra pointer tag bits is the
Boehm-Demers-Weiser conservative Garbage Collector for C, which comes
as a drop-in malloc() replacement - indeed this is so efficient that
some quite reasonable functional languages (Bigloo Scheme, for
example) decided not to implement their own GC, but rely on this
library instead. How can this possibly work? Basically: if something
looks like a pointer, we just assume it could be a pointer and scan
the corresponding region.
</p>

<p>
Now, one might say that if a CPU were especially designed to support
functional languages, it should provide extra type tag bits for every
value. With modern 64-bit CPUs, there usually is little need for fast
full 64-bit integers, so we may well afford providing only 62-bit
arithmetics, and pointers will not use the full 64-bit address range
anyway due to MMU limitations. (Typically, a page will consist of 1024
8-byte entries, hence use up 13 address bits. The usual three-level
MMUs then only can use 10*3+13=43 address bits. Seen that way, going
to 48 instead of 64 bits may have been more reasonable.) What is
slightly special about OCaml is that its implementors have
deliberately chosen to use internal representations that do not allow
one to re-derive enough type information to print the value in a
meaningful way. Internally, there is no distinction between
"<code>false</code>" and "<code>0</code>", say. This is somewhat
unfortunate, as it means that there is no way to implement an ad-hoc
polymorphic debug-printing function of type <code>'a -&gt;
string</code> that just prints out some OCaml value in a meaningful
way - similar to Perl's <code>Data::Dumper</code>.
</p>

<p>Even though we might not be meant to know what is going on in this
file, it is nevertheless worthwile to have a look at <a href="file:///usr/lib/ocaml/3.08.3/caml/mlvalues.h"><tt>file:///usr/lib/ocaml/3.08.3/caml/mlvalues.h</tt></a>
to see how some of the low-level definitions work. <em>Note that we
are not supposed to rely on that particular realization, as this may
change in the future!</em>
</p>


<p>What are the ML-specific macros such as <code>CAMLprim</code>,
<code>CAMLparam1</code>, <code>CAMLlocal1</code>,
<code>CAMLreturn</code> for? Roughly speaking, <code>CAMLprim</code>
has to do with exporting our functions properly for OCaml. The
<code>CAMLparam/CAMLlocal</code> macros are required for garbage
collection. We can imagine situations where some allocated piece of
memory "almost becomes garbage" in the sense that all references to it
are lost, except some that are passed into C. As a garbage collection
may be triggered at almost any point in time, we must make sure that
even if we are inside C code that holds the last references to a given
value, the Garbage Collection will know that this value still is in
use. In the <code>c_ex_x_open_display_v1</code> C function in our
example, we first introduce a variable of type value named
<code>block</code>, which is made visible to the GC. Then, we allocate
a block which will have a header tag (<code>Abstract_tag</code>) that
tells the GC that this region of memory does not hold a string, an
array or tuple, or any other kind of value OCaml may want to deal with
in some special way: it will just contain "raw data", and it will
always be up to our code to interpret this in the proper way. We
generally are requested to use the <code>Field</code> and
<code>Store_field</code> macros to retrieve and store data from the
fields of a block, if these fields contain ML values. For C data (like
pointers) stored in a custom block, we must not use
<code>Store_field</code>, as this would tell the GC to keep track of
the value in that slot and regard it as a ML value that has to be
scanned - with disastrous consequences. Hence, we introduce our own
<code>Store_c_field</code> macro to make explicit that we do want to
store a value without making the GC worry about it. This macro
actually is implemented in a somewhat hackish way and perhaps should
rather be part of official OCaml, but at the time of this writing, it
is not.
</p>

<p>
Every entry in a block will be large enough to hold one ML value, and
in our example, we implicitly use the slightly dangerous assumption
that a value is at least as large as a pointer. (However, this
actually seems to be true on all platforms.) Note that if we were to
construct a float array from within C on a 32-bit system, we would
have to allocate a block with twice as many <code>value</code> slots
as the number of entries of our floatingpoint array, and we should use
the <code>Double_field</code> and <code>Store_double_field</code>
macros to access them. Here, our payload data is either a C
<code>Display</code> pointer, or a null pointer, denoting an invalid
display. The other C implementations of functions operating on X
displays will extract that value and handle it in an appropriate
way. Note that the example code sometimes is a bit more verbose than
strictly necessary. This is just to clarify the general structure.
</p>

<h3>Finalization and Exceptions</h3>

<p>Quite often, when we wrap C-controlled resources in such a way, we
may want to provide means that the resource is freed automatically
should it become garbage. Quite in general, it is a good idea not to
rely on such GC finalization as the solitary mechanism to free
resources but to at least provide explicit de-allocation
means. Depending on the resource, we may even want to consider it an
error that should be reported if it ever ends up being
GC-finalized. One way to implement finalization would be to use the
<code>Gc.finalise</code> function on <code>x_display</code> values and
register <code>x_close_display</code> as a finalizer and wrap up our
raw <code>x_open_display</code> function accordingly on the OCaml
side. We may also provide a finalizer written in C. This will be shown
in the next example. In addition, we will make sure that using
<code>x_server_vendor</code> on an invalid X display will raise a
special exception defined by us, which will provide both a
human-readable problem description and an OCaml tag telling us what
went wrong.
</p>

<p>
</p><center>
<table border="1">
<tbody><tr><th>Extending our example: finalization and exceptions</th></tr>
<tr><td><hr></td></tr>
<tr><th><code>c_examples.mli</code></th></tr>
<tr><td><pre><code>

(* Add: *)

type x_entity =
  | X_C_Display
  | X_C_Window
  | X_C_Colormap
(* ...May want to add more... *)

exception X_Invalid of (string * x_entity)
(* Note: the round parens are strictly mandatory and vital here!
   The code will compile but crash if we omit them.
   (A Very Dark Corner(TM) of OCaml!)
 *)

</code></pre></td></tr>

<tr><td><hr></td></tr>
<tr><th>c_examples.ml</th></tr>
<tr><td><pre><code>

(* Change and add: *)

external x_open_display: string -&gt; x_display = "c_ex_x_open_display_v2";;

external x_display_is_valid: x_display -&gt; bool = "c_ex_x_display_is_valid_v2";;

external x_close_display: x_display -&gt; unit = "c_ex_x_close_display_v2";;

external x_server_vendor: x_display -&gt; string = "c_ex_x_server_vendor_v2";;

type x_entity =
  | X_C_Display
  | X_C_Window
  | X_C_Colormap
(* ...May want to add more... *)
;;

exception X_Invalid of (string * x_entity);;

let _ = Callback.register_exception "x_invalid" (X_Invalid ("",X_C_Display));;

</code></pre></td></tr>
<tr><td><hr></td></tr>
<tr><th>c_examples_impl.c</th></tr>
<tr><td><pre><code>

/* Note that this is declared static - this makes our code more tidy
   by saying:

   "This function is private to this very module!"
*/
static void finalize_x_display(value block)
{
  Display *disp;
  disp=(Display *)Field(block,1);

  if(disp)
    {
      fprintf(stderr,"Warning: closing X display on finalization!\n");
      fflush(stderr);
      /* Note: normally it is a sign of bad taste to make a library(!)
	 write to stdout/stderr if it was not permitted to do so.
	 Here, this is okay, as we do it for demonstration purposes
	 only.

	 In real code, we should at least introduce an OCaml-visible
	 flag variable that may be used to silence the library.
       */

      XCloseDisplay(disp);
      /* No need to invalidate the entry, as it is garbage anyway! */
    }
}

CAMLprim c_ex_x_open_display_v2(value ml_display_name)
{
  CAMLparam1(ml_display_name);

  Display *disp;

  disp=XOpenDisplay(String_val(ml_display_name));
  
  CAMLlocal1(block);

  block=alloc_final(2, &amp;finalize_x_display,1,10);

  Store_field(block,1,(value)disp);

  CAMLreturn(block);
}

CAMLprim c_ex_x_display_is_valid_v2(value ml_display)
{
  CAMLparam1(ml_display);

  Display *disp;
  int is_valid;

  disp=(Display *)Field(ml_display,1);

  is_valid=(disp!=0);
  
  fprintf(stderr,"x_display_is_valid(disp=%08x) -&gt; %d\n",disp, is_valid);
  fflush(stderr);
  
  CAMLreturn(Val_bool(is_valid));
}

CAMLprim c_ex_x_close_display_v2(value ml_display)
{
  CAMLparam1(ml_display);

  Display *disp;
  int is_valid;

  disp=(Display *)Field(ml_display,1);

  is_valid=(disp!=0);
  
  if(is_valid)
    {
      XCloseDisplay(disp);
      Store_c_field(ml_display,0,(value)0);
    }

  CAMLreturn(Val_unit);
}

CAMLprim c_ex_x_server_vendor_v2(value ml_display)
{
  CAMLparam1(ml_display);

  Display *disp;
  int is_valid;
  char *vendor_id="";

  disp=(Display *)Field(ml_display,1);

  is_valid=(disp!=0);
  
  if(is_valid)
    {
      vendor_id=XServerVendor(disp);
      /* Now, we use the libX11 function and not the macro
	 for obtaining the server vendor
       */
    }
  else
    {
      CAMLlocal1(exn);
      exn=alloc_tuple(2);

      Store_field(exn,0,copy_string("Invalid X Display!"));
      Store_field(exn,1,Val_int(0));
      
      raise_with_arg(*caml_named_value("x_invalid"),exn);
    }

  CAMLreturn(copy_string(vendor_id));
}
</code></pre></td></tr>

</tbody></table>
</center>
<p></p>

<p>
</p><center>
<table border="1"><tbody><tr><th>Testing the new <code>xlib</code> functions</th></tr>
<tr><td><pre><code>

(* Installation and startup ad before *)

# let disp=x_open_display ":0.0";;
val disp : C_examples.x_display = &lt;abstr&gt;
# x_server_vendor disp;;
- : string = "The XFree86 Project, Inc"
# x_close_display disp;;
- : unit = ()
# x_server_vendor disp;;
Exception: C_examples.X_Invalid ("Invalid X Display!", X_C_Display).
# Gc.full_major();;
- : unit = ()
# let disp2 = ref [x_open_display ":0.0"];;
val disp2 : C_examples.x_display list ref = {contents = [&lt;abstr&gt;]}
# disp2:=[];;
- : unit = ()
# Gc.full_major();;
Warning: closing X display on finalization!
- : unit = ()
# 1;;
- : int = 1
# for i=0 to 100 do Printf.fprintf stderr "%d - %!" i; ignore(x_open_display ":0.0") done;;
0 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
8 - 9 - 10 - 11 - 12 - 13 - 14 - 15 - 16 - 17 - 18 - 19 - Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
20 - 21 - 22 - 23 - 24 - 25 - 26 - 27 - 28 - 29 - 30 - 31 - Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
32 - 33 - 34 - 35 - 36 - 37 - 38 - 39 - 40 - 41 - 42 - 43 - Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
44 - 45 - 46 - 47 - 48 - 49 - 50 - 51 - 52 - 53 - 54 - 55 - Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
56 - 57 - 58 - 59 - 60 - 61 - 62 - 63 - 64 - 65 - 66 - 67 - Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
68 - 69 - 70 - 71 - 72 - 73 - 74 - 75 - 76 - 77 - 78 - 79 - Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
80 - 81 - 82 - 83 - 84 - 85 - 86 - 87 - 88 - 89 - 90 - 91 - Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
Warning: closing X display on finalization!
92 - 93 - 94 - 95 - 96 - 97 - 98 - 99 - 100 - - : unit = ()
</code></pre></td></tr>
</tbody></table></center>
<p></p>

<p>Let us briefly discuss what's new. First, we are now using
<code>alloc_final()</code> to allocate our custom-data blocks. We need
to allocate one extra value entry and use the second slot (having
index 1) for our data, as a pointer to the finalization function will
go into slot 0. Actually, this is not 100% true:
<code>alloc_final()</code> is just a legacy compatibility function for
the more general and also more flexible <code>alloc_custom()</code>
function that also allows us to specify other custom functions that
handle, say, serialization to strings, hashing, and comparison. None
of this really makes overly much sense on X display pointers, so we
just leave it at the more simplistic approach. The other two
parameters control how frequently the GC is called after allocating
entities of this type. The first value is a measure of the relative
amount of resources used by this entity (we just use 1 here), the
second one is a measure for how many of these we allow the system to
allocate before GC has to be called in order to try to reclaim some
that may have become garbage. These "ten allocations per GC" can be
seen at the end of our transcript.
</p>

<p>Concerning exception handling, we first have to introduce an
exception on the OCaml side, and register this with a special name, so
that we can locate it from within C by that name. Then, we build the
argument tuple - we may have used <code>alloc</code> with the special
tag denoting a tuple, but <code>alloc_tuple</code> is a more
convenient shorthand. <em>Note that the parentheses in the exception
definition are mandatory!</em>. If we were to do some less
sophisticated exception handling, we might prefer using the much
simpler <code>raise_with_string</code> instead.
</p>

<h3>C Callbacks</h3>

<p>As we have seen, the functional way to think about the
decomposition of an algorithmic problem into sub-tasks which are
realized by specialized little helper functions is very
natural. Consequently, we find such a style of programming also in
some C libraries. One typical application is the specification of
callback C handlers. Suppose that we have a C library that provides an
opaque C structure called - say - "<code>animal</code>", for which we
can register a callback C function that is called whenever this animal
has to make a sound. Typically, the C library implementor will have
thought about the problem that the library user might need more
flexibility than what can be provided by registering just a C
function. With our background in functional programming, we now may
see it that way: C "functions" are not functions, but just routines. A
proper function is a piece of code specifying what to do, plus maybe
some extra contextual information. We generally just called this a
"proper function" so far. If one wants to emphasize the role of the
contextual data grouped together with the function, this is sometimes
called a "closure". A parameter to a callback-setting function that
provides such context which is passed to the registered callback once
it is executed then is a "closure parameter". This sounds a bit
convoluted - but we will see an example soon. 
</p>

<p>When we wrap up such a library for OCaml, we will usually want to
match the spirit of the original callback approach as closely as
possible. On the OCaml side, we will not require a closure parameter
to the callback function, as OCaml already has proper functions. On
the other hand, we have to use a callback wrapper on the C side that
uses the closure parameter to pass around the OCaml function.
</p>

<p>The details are best studied by looking at an example. Note that
one should pay very close attention here - making things smooth for
the user of our code will require some tricky magic under the hood.
</p>

<p>This is the C library we want to interface (and a C example):</p>

<p>
</p><center>
<table border="1"><tbody><tr><th>The <code>animal</code> library</th></tr>
<tr><th><code>animal.h</code>:</th></tr>
<tr><td><pre><code>

#ifndef _ANIMAL_H
#define ANIMAL_H

typedef void animal_callback_make_sound(void *);

typedef struct
{
  char *name;
  animal_callback_make_sound *cb_make_sound;
  void *cdata_make_sound;
} animal;

extern animal *make_animal(char *);
extern void free_animal(animal *);

extern void register_make_sound(animal *,
				animal_callback_make_sound *,
				void *);


extern void make_sound(animal *);

extern void test_animal(void);


#endif
</code></pre></td></tr>
<tr><th><code>animal.c</code>:</th></tr>
<tr><td><pre><code>

#include <stdio.h>
#include <stdlib.h>

typedef void animal_callback_make_sound(void *);

typedef struct
{
  char *name;
  animal_callback_make_sound *cb_make_sound;
  void *cdata_make_sound;
} animal;



animal *make_animal(char *name)
{
  animal *a=0;
  char *copy_name;
  int name_len;

  if(0==(a=(animal *)calloc(1,sizeof(animal))))
    {
      fprintf(stderr,"Fatal: malloc() failure!\n");
      exit(1);
      /* When such a grave situation occurs, we may even consider
	 aborting the program via raise(9), i.e. shoot ourselves
	 in the head and do not even attempt to do the atexit()
	 cleanup.
       */
    }

  name_len=strlen(name);
  if(0==(copy_name=malloc(name_len+1)))
    {
      fprintf(stderr,"Fatal: malloc() failure!\n");
      exit(1);
    }
  strcpy(copy_name,name);


  a-&gt;name=copy_name;
  return a;
}

void free_animal(animal *a)
{
  free(a-&gt;name);
  free(a);
}

void register_make_sound(animal *a,
			 animal_callback_make_sound *cb,
			 void *data)
{
  a-&gt;cb_make_sound=cb;
  a-&gt;cdata_make_sound=data;
}

void make_sound(animal *a)
{
  if(a-&gt;cb_make_sound)
    a-&gt;cb_make_sound(a-&gt;cdata_make_sound);
}

/* === Testing === */

static void callback_make_sound_demo1(void *data)
{
  char *str=(char *)data;
  printf("%c%c%c%s\n",str[0],str[0],str[0],str);
}

void test_animal(void)
{
  animal *a=make_animal("duck");
  register_make_sound(a,&amp;callback_make_sound_demo1,(void *)"quack");

  make_sound(a);
  free_animal(a);
}
</stdlib.h></stdio.h></code></pre></td></tr>
<tr><th><code>animal_example.c</code>:</th></tr>
<tr><td><pre><code>

extern void test_animal(void);

int main(void)
{
  test_animal();
  return 0;
}

/* Test run:

$ gcc -o animal_example animal.c animal_example.c

$ ./animal_example
qqqquack

$ # Works fine!
*/
</code></pre></td></tr>
</tbody></table></center>
<p></p>

<p>In order to wrap this, we make the following further modifications:</p>

<p>
</p><center>
<table border="1">
<tbody><tr><th>Extending our example: Lifting callback-setting from C to OCaml</th></tr>
<tr><td><hr></td></tr>
<tr><th><code>Makefile</code></th></tr>
<tr><td><pre><code>
SOURCES = c_examples.mli c_examples.ml c_examples_impl.c animal.c

# Note: if we had this in a proper installed shared object library,
# we would give linker option flags as in the libX11 example instead.
</code></pre></td></tr>
<tr><th><code>c_examples.mli</code></th></tr>
<tr><td><pre><code>
(* Add: *)

type animal;;

val make_animal: string -&gt; animal

val free_animal: animal -&gt; unit

val register_make_sound: animal -&gt; (unit -&gt; unit) -&gt; unit

val make_sound: animal -&gt; unit
</code></pre></td></tr>
<tr><th><code>c_examples.ml</code></th></tr>
<tr><td><pre><code>
(* Add: *)

(* Callback example *)

type animal;;

external make_animal: string -&gt; animal = "c_ex_make_animal";;

external free_animal: animal -&gt; unit = "c_ex_free_animal";;

external register_make_sound: animal -&gt; (unit -&gt; unit) -&gt; unit =
  "c_ex_register_make_sound";;

external make_sound: animal -&gt; unit = "c_ex_make_sound";;

</code></pre></td></tr>

<tr><th><code>c_examples_impl.c</code></th></tr>
<tr><td><pre><code>

/* === Animal interface === */

#include "animal.h"

static void cleanup_animal_and_callback(value ml_animal_and_callback)
{
  animal *a;
  value *cb;
  a=(animal *)Field(ml_animal_and_callback,1);
  cb=(value *)Field(ml_animal_and_callback,2);
  
  if(a)
    {
      free_animal(a);
      Store_c_field(ml_animal_and_callback,1,(value)0);
      caml_remove_global_root(cb);
      free(cb);
      Store_c_field(ml_animal_and_callback,2,(value)0);
      /* Defensive programming. */
    }
}

static void finalize_raw_animal(value block)
{
  animal *a;
  a=(animal *)Field(block,1);

  if(a)
    {
      fprintf(stderr,"Warning: reclaiming animal on finalization!\n");
      fflush(stderr);
      cleanup_animal_and_callback(block);
    }
}

static void callback_wrapper_make_sound(void *cb)
{
  value ml_fun= *(value *)cb;

  if(ml_fun != Val_unit)
    {
      fprintf(stderr,"Calling ML callback 0x%08x!\n",ml_fun);
      callback(ml_fun,Val_unit);
    }
}


CAMLprim c_ex_make_animal(value ml_name)
{
  CAMLparam1(ml_name);
  value *ml_callback_container;
  
  animal *a=make_animal(String_val(ml_name));

  /* The callback must be placed in non-moving C-visible
     malloc()-allocated space. It will have to contain a ML value -
     the callback - and we have to tell the GC about it, so that it can
     (1) start scanning from this value,
     (2) adjust the pointer if it moves around the value on the ML heap.
   */

  if(0==(ml_callback_container=(value *)malloc(sizeof(value))))
    {
      fprintf(stderr,"AIEE: malloc failure - aborting!()\n");
      exit(1);
    }

  *ml_callback_container=Val_unit;
  caml_register_global_root(ml_callback_container);
  

  CAMLlocal1(ml_animal_and_callback);
  
  ml_animal_and_callback=alloc_final(3, &amp;finalize_raw_animal,1,100);

  /* Slot zero will contain the custom operations, slot one
     the animal, and slot two a C value which holds 
     the ML function implementing the callback, or Val_unit
     if none is set.
  */

  Store_c_field(ml_animal_and_callback,1,(value)a);
  Store_c_field(ml_animal_and_callback,2,(value)ml_callback_container);
  
  CAMLreturn(ml_animal_and_callback);
}


CAMLprim c_ex_free_animal(value ml_animal_and_callback)
{
  CAMLparam1(ml_animal_and_callback);

  cleanup_animal_and_callback(ml_animal_and_callback);

  CAMLreturn(Val_unit);
}

CAMLprim c_ex_register_make_sound(value ml_animal, value ml_fun)
{
  CAMLparam2(ml_animal,ml_fun);
  animal *a=(animal *)Field(ml_animal,1);
  value *cb=Field(ml_animal,2);
  *cb=ml_fun;
  register_make_sound(a,&amp;callback_wrapper_make_sound,cb);
  CAMLreturn(Val_unit);
}

CAMLprim c_ex_make_sound(value ml_animal_and_callback)
{
  CAMLparam1(ml_animal_and_callback);
  animal *a=(animal *)Field(ml_animal_and_callback,1);

  if(a)
    {
      make_sound(a);
    }
  CAMLreturn(Val_unit);
}

</code></pre></td></tr>
</tbody></table></center>
<p></p>

<p>Quite an example, indeed. Let us see now that this really works as
advertised:
</p>

<p>
</p><center>
<table border="1"><tbody><tr><th>Running the Callback example</th></tr>
<tr><td><pre><code>

# let the_duck = make_animal "duck";;
val the_duck : C_examples.animal = &lt;abstr&gt;
# make_sound the_duck;;
- : unit = ()
# register_make_sound the_duck (let r = ref 0 in fun () -&gt; begin r:= !r+1; Printf.printf "Quacking for the %d-th time!\n%!" !r end);;
- : unit = ()
# make_sound the_duck;;
Calling ML callback 0x0807a9f4!
Quacking for the 1-th time!
- : unit = ()
# make_sound the_duck;;
Calling ML callback 0x0807a9f4!
Quacking for the 2-th time!
- : unit = ()
# make_sound the_duck;;
Calling ML callback 0x0807a9f4!
Quacking for the 3-th time!
- : unit = ()
# make_sound the_duck;;
Calling ML callback 0x0807a9f4!
Quacking for the 4-th time!
- : unit = ()
# Gc.full_major();;
- : unit = ()
# make_sound the_duck;;
Calling ML callback 0xb7bbef8c!
Quacking for the 5-th time!
- : unit = ()
# Gc.full_major();;
- : unit = ()
# make_sound the_duck;;
Calling ML callback 0xb7bbef8c!
Quacking for the 6-th time!
- : unit = ()
# register_make_sound the_duck (fun () -&gt; Printf.printf "Quack Quack!\n%!");;
- : unit = ()
# make_sound the_duck;;
Calling ML callback 0x0807f9f8!
Quack Quack!
- : unit = ()
# Gc.full_major();;
- : unit = ()
# make_sound the_duck;;
Calling ML callback 0xb7bbc310!
Quack Quack!
- : unit = ()
# free_animal the_duck;;
- : unit = ()
# make_sound the_duck;;
- : unit = ()
# 
</code></pre></td></tr>
</tbody></table></center>
<p></p>

<p>The key idea is: We have to provide a C data pointer when we
register our callback function. Actually, what we want to pass here is
the ML function, but this may be moved around in memory by the GC. So,
we have to pass a pointer to a C memory region holding the ML
function. But then, we have to make sure that the GC will recognize
this C-allocated memory as a position that holds a ML value, which
should be treated as a root for heap scanning, and modified if the
value is moved around. Therefore, we have to
<code>register_global_root</code> it - and unregister and free it once
we get rid of the object for which we registered the callback. The
reader should take his time to think this through.
</p>

<p>Actually, this unfortunately means that we will encounter an ugly
problem if the callback function we register is a closure containing
the object for which we registered the callback. The reason is that
the callback-holding object will be responsible for removing the
global GC root in its finalizer - but if we make this object
accessible through that global GC root, it never will be finalized. In
other words, if we write code like the following, this means
asking for trouble:
</p>

<p>
</p><center>
<table border="1"><tbody><tr><th>Running the Callback example</th></tr>
<tr><td><pre><code>

open C_examples;;

let rec test n =
  if n=0
  then ()
  else
    let a = make_animal "frog" in
    let x = [a] in
    let ms () = 
      let len = List.length x in
      Printf.printf "Quaak (%d)\n%!" len
    in
    begin
      register_make_sound a ms;
      make_sound a;
      Gc.full_major();
      (* Now, forget about a and ms *)
      test (n-1)
    end
;;

</code></pre></td></tr>
</tbody></table></center>
<p></p>

<p><em style="">XXX Actually, if I run this
e.g. as (test 1000), I get a segfault, but strangely, the address
reported for the callback function always is the same. This should not
be possible! Something is wrong with this discussion. Have to
investigate!)</em></p>

<p>This brings us about as far as we want (or have to) go with our
discussion of the C interface. Let us conclude this lesson with this
final pearl: a module providing functionality that allows us to
specify a (Real d-dimensional Space -&gt; Real k-dimensional Space)
function in the form of a string containing C code. This will then be
put into a C source code file, compiled, dynamically loaded, and
linked from within OCaml, so that we can <code>c_register</code> a
string and in the end obtain a very fast <code>float array -&gt; float
array</code> OCaml function implementing this computation!
Documentation of the (very small) ML interface is still lacking,
especially concerning re-use of the output vector, and error checking
should be improved (catching compiler errors as well as making sure
the wrapped function comes with array length bounds
checks). Nevertheless, this is a closed example showing many of the
techniques we have discussed here, plus a few new ones, in particular:
using the module system to define a weak hash table and using this to
keep an overview over the still-in-use C-wrapped functions and using
dynamical loading of C libraries.
</p>

<p><a href="http://www.soton.ac.uk/%7Efangohr/nsim/tutorial/ocaml/c_examples">The complete <code>c_examples</code> module we discussed above (for completeness)</a></p>

<p><a href="http://www.soton.ac.uk/%7Efangohr/nsim/tutorial/ocaml/fastfields">The <code>fastfields</code> module</a></p>

<hr>

<h3><a name="gcl-alloc">How GCL boxes integers</a></h3>

<p>One very simple way to demonstrate this is to use the shell command
"<code>ulimit -v 200000</code>" to artificially limit virtual memory
size to 200000 KB and then start GCL. If we try to define a vector of
20 million values, this would require about 80 MB of RAM. If we
provide the initial value, all entries will point to the same
entity. But look what happens if we start putting different numbers
into different places:
</p>

<p>
</p><center>
<table border="1">
<tbody><tr><th>GCL and memory management</th></tr>
<tr><td><pre><code>
$ ulimit -a
core file size        (blocks, -c) 0
data seg size         (kbytes, -d) unlimited
file size             (blocks, -f) unlimited
max locked memory     (kbytes, -l) unlimited
max memory size       (kbytes, -m) unlimited
open files                    (-n) 1024
pipe size          (512 bytes, -p) 8
stack size            (kbytes, -s) unlimited
cpu time             (seconds, -t) unlimited
max user processes            (-u) unlimited
virtual memory        (kbytes, -v) unlimited
$ ulimit -v 200000
$ gcl
GCL (GNU Common Lisp)  2.6.6 CLtL1    Jan 18 2005 00:13:38
Source License: LGPL(gcl,gmp), GPL(unexec,bfd)
Binary License:  GPL due to GPL'ed components: (READLINE BFD UNEXEC)
Modifications of this banner must retain notice of a compatible license
Dedicated to the memory of W. Schelter

Use (help) to get some basic information on how to use GCL.

&gt;&gt;(defparameter arr (make-array 20000000 :initial-element 7))

ARR

&gt;&gt;(aref arr 0)

7

&gt;&gt;(dotimes (j 20000000) (setf (aref arr j) j) (if (= 0 (mod j 1000000)) (print j)))

0 
1000000 
2000000 
3000000 
Unrecoverable error: Can't allocate.  Good-bye!.
Aborted
$ 
</code></pre></td></tr>
<tr><th>In comparison, MzScheme in the same situation</th></tr>
<tr><td><pre><code>
$ ulimit -v
200000
tf@ouija:~/talks/ocaml-tutorial$ mzscheme 
Welcome to MzScheme version 209, Copyright (c) 2004 PLT Scheme, Inc.
&gt; (define a (make-vector 20000000 7))
&gt; (vector-ref a 0)
7
&gt; (let loop ((j 0)) (if (&lt; j 20000000) (begin (vector-set! a j j) (loop (+ j 1)))))
&gt; (vector-ref a 1999777)
1999777
</code></pre></td></tr>
</tbody></table></center>
<p></p>

<p>So, this hints at GCL doing heap allocation of integers, while
MzScheme does not. Neither do quite a lot other functional systems.
</p>

    <hr>
    <address><a href="mailto:tf@cip.physik.uni-muenchen.de">Dr. Thomas Fischbacher</a></address>
<!-- Created: Thu Dec 15 16:19:40 GMT 2005 -->
<!-- hhmts start -->
Last modified: Sat May 13 18:25:36 BST 2006
<!-- hhmts end -->
  
</body></html>