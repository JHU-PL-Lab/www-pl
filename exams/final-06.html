<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<HEAD>
<title>PL Final 2006</title>
</HEAD>
<BODY LINK="#0000FF" VLINK="#800080" bgcolor="#F0FFF0">
<h3> 600.426, Programming Languages
<br> Spring 2006
<br> Final Examination
<br> 
</h3>
You can use one handwritten 8.5x11 notes sheet.<p>
For this exam you have 10 "freebie" points which you can apply to any
question(s).  Those points are added to your score on the question up
to but not over the total number of points the question is for.  You
can sprinkle them about as you choose.<p> 

<strong>Good Luck!</strong>
<hr>
<ol><h4>Little Questions</h4>
  <li>(4 points) (a) What does Caml reply to the following input:
      <pre>
      type foo = { x : int }
      type bar = { x : int; y : int}
      let f x = x.x;;
</pre>
      (b) Now immediately after typing in the above, what does Caml
      reply on the following input:
      <pre>let g y = f (if y=0 then {x = 3} else {x = 3; y = 6})
      in g 5;; </pre>

  <li>(8 points) Consider an <strong>STD</strong> version of the
      program in the previous question:
      <pre>
      (Function y : Int ->
         (Function x : {x : Int } -> x.x) (If y=0 Then {x = 3} Else {x = 3; y = 6})
      ) 5</pre>
      a) Is this program typable in <strong>STD</strong>?  Give the
      derivation or argue why not.<br>
b) Removing the type declarations from the above code, is the
      resulting program typable in <strong>CDR</strong> (the
      constraint inference system)?  Show your work.
<p>

  <li>(4 points) We briefly discussed the <code>Abort</code> control
      operator in class: once you hit it, your program immediately
      terminates, nothing else is done.  Define <strong>DAb</strong>
      as <strong>D</strong> with a new syntax form
      <code>Abort(e)</code> which when executed returns the value of
      <code>e</code> and quits.  So, <code>3 + Abort(7) ==> 7</code>.
      Write a <strong>DAb</strong> interpreter in Caml; you don't need
      to repeat any clauses that were in the <strong>D</strong>
      interpreter.

     <p>

  <li>(6 points) For each of the following potential operational equivalences for
    <strong>DSR</strong>, state whether it is true or false.  Note that <code>e0</code> is
    considered an arbitrary expression, i.e. the equivalence holds for
    any such expression. <code>x</code> on the other hand is an
    arbitrary variable.<br>
(a)<code> x x x =~ x x </code>?<br>
(b) <code>If x = False Then False Else True =~ x</code> ?<br>
(c) <code>e0 + e0 =~ e0 + e0 + 1 - 1</code> ?
<p>

  <li>(8 points) Take the following Caml program:
    <pre>
    let rec even x = if x = 0 then true else odd (x-1)
         and odd x = if x = 0 then false else if x = 1 then true else even (x-1)
    in odd 12;;
    </pre>
    and code it in <strong>D</strong>, <em>without</em> using
    <code>Let Rec</code>.  You need to keep it as mutually recursive
    functions, so you answer should contain the "pattern" to allow any
    two functions calling each other to be easily coded in
    <strong>D</strong>.  


    <p>
   
<h4>Big Question</h4>

<li>This big question concerns an extension to
<strong>D</strong> with Lisp-style lists, defining the language
<strong>DLisp</strong>. <br> Here are the <strong>DLisp</strong> list
operators and for your reference their Caml equivalents; they are very
similar.
    
    <pre>
    DLisp        Caml
    nil          []            (empty list)
    cons(e,e)    e::e          (cons)
    car(e)       List.hd e     (head; usually pattern matched in Caml)
    cdr(e)       List.tl e     (tail; usually pattern matched in Caml)
    null(e)      match x with [] -> true | _ -> false
                               (check for empty list; always pattern matched)  
    </pre>
(a) (3 points) Warm up: show how to write a map function on these kinds of lists.
    <code>map f l</code> should apply function f to each element of
    the list <code>l</code> in turn.  An example <code>l</code> can be
    e.g. <code>cons(1,cons(2,cons(3,nil)))</code> so mapping
    <code>Function x -> x+1</code> to this list would return
    <code>cons(2,cons(3,cons(4,nil)))</code>.
    <p>

    (b) (8 points) Give the operational semantics rules for 
    <strong>DLisp</strong>.  You only need
    to give the new rules not  in the
    <strong>D</strong> operational semantics. Use the Caml intuitions
    above to guide you.  Be sure to state what the values are for
    <strong>DLisp</strong>.<p> 

    (c) (6 points) Suppose we were in the process of developing an
    encoding of <strong>DLisp</strong> into 
    <strong>DSR</strong> that started as follows:
    <pre>
    cons(e1,e2)  =  { car = e1; cdr = e2 }
    car(e)       =  e.car
    cdr(e)       =  e.cdr
    </pre>
    Either finish this encoding with mappings for <code>null(e) /
    nil</code> or argue why it cannot be done.  You cannot change the
    above three mappings.
<p>

    (d) (6 points) In Lisp the lists are in fact <em>mutable</em> if special list
    mutation operators are used -- the head and tail of any list can
    be changed.  The mutation operations are <code>setcar(l,e)</code>
    and <code>setcdr(l,e)</code> to mutate the head and tail of
    <code>l</code>, respectively.  Think of them as analogues of
    Caml's mutable records, but here it is the head/tail of a list being
    mutated and not record fields.  Consider now the language
    <strong>DMLisp</strong> which adds these <strong>M</strong>utate
    operations to <strong>DLisp</strong>.  Here is an example to give you the
    idea.

<pre>
Let l1 = cons(1,cons(2,nil))
  In setcdr(cdr(l1)),cons(3,nil);
     l1</pre>
would return the list <code>cons(1,cons(2,cons(3,nil)))</code> (the
tail of <code>l1</code> is the list <code>cons(2,nil)</code>, and the
<code>setcdr</code> is mutating <em>it's</em> tail, <code>nil</code>,
to be the new value, <code>cons(3,nil)</code>).  Note
   that <code>setcdr</code> <em>mutated</em> 
   <code>l1</code>, its value changed.
<br>
Given this new powerful operation show how a <code>smash</code> function can be
written which "glues" two lists together.  The above example in fact
is a case of <code>smash</code>:
<pre>smash (cons(1,cons(2,nil))) (cons(3,nil)) ==> cons(1,cons(2,cons(3,nil)))</pre>

This operation not only returns the appended list, the first argument
is <em>mutated</em> to have the second list "tacked on" at its end as
was <code>l1</code> above.  To clarify,
<pre>
Let l = cons(1,cons(2,nil)) In
Let _ = smash (l) (cons(3,nil)) In
  l
     ==> cons(1,cons(2,cons(3,nil)))</pre>
<p>
(e) (3 points) OK, now write a normal, "functional" list append which does not use
<code>setcar/setcdr</code>.  Example:
<pre>
Let l1 = cons(1,cons(2,nil)) In Let l2 = cons(3,nil) In append l1 l2
==> cons(1,cons(2,cons(3,nil)))</pre>
The values of <code>l1/l2</code> are unchanged by the
<code>append</code> call.
<p>
(f) (4 points) The smash and append functions look similar, but one is mutating
its first argument and the other is not.  Prove that
<pre>smash =~ append</pre>
is <em>false</em> by finding an appropriate <strong>DMLisp</strong> context
that tells them apart.

<p>
(g) (10 points) Now let us consider type inference for <strong>DLisp</strong> by
extending the <strong>ED</strong> types, type inference rules, and
closure to handle these list consructs.  The only new type we need is
a list type, <code>tau List</code>.  Write out the new inference and
closure rules for all of the new <strong>DLisp</strong> operators and types.
</ol> 
<p>


</BODY> </html>
