<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<HEAD>
<title>PL Final 2009</title>
</HEAD>
<BODY LINK="#0000FF" VLINK="#800080" bgcolor="#F0FFF0">
<h3> 600.426, Programming Languages
<br> Spring 2009
<br> Final Examination
<br> 
</h3>
You can use one handwritten 8.5x11 notes sheet.  You can write on both
sides.  No printer output is allowed, it must all  be hand-written.<p>

<strong>Good Luck!</strong>
<hr>
<ol>
  <li>(3 points) Show how <code>Let Rec</code> of <strong>Fb</strong> can in
      fact be defined as a macro that does not use <code>Let
      Rec</code> at all:
      <pre>Let Rec f x = e In e' =def= (fill in)</pre>
 <p>
 <li>(3 points) Suppose some actor got stuck in an infinite loop while processing a
      message; what would the effect be on the operational semantics
      for the global actor system (you can assume there are many other
      actors and messages besides the one that wants to loop forever).<br>
<p>
 <li>(3 points) Call-by-name parameter passing is the case where the
     function argument is <em>not</em> evaluated before being passed
     into the function.<br>
 Write out how your <strong>Fb</strong> interpreter function
     <code>eval</code> would have to
     change to replace its call-by-value evaluation stretegy with
     call-by-name (hint: you only need to change the function
     application case, and you can just "..." the rest since it
     doesn't change).

     <p>


  <li>(8 points) For <strong>FbSR</strong>, answer whether the following operational
      equivalences hold.  If the answer is no, give a context C
      showing  that fact.<br>
&nbsp;&nbsp;&nbsp;&nbsp;a)  <code>Function x -> x + 1  ~= Function y
      -> y + 1</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;b)  <code>Function x -> x.x  ~= Function y -> y.y</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;c)  <code>(Function r -> r.y){x = 3; y = 3}
      ~= (Function r -> r.x){x = 3}</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;d)  <code>{x = 3; y = 3}  ~= {x = 3}</code><br>

<p>
  <li>(6 points) This question concerns subtyping.<br>
a) Type the following program in <strong>STFbR</strong> (note this program
  is not showing the type declarations on <code>r1/r2</code>, figure
  those out yourself):
      <pre>
      Function n:Int -> Function r1:{...} -> Function r2:{...}->
         {x = r1.x + 1; y = (If n = 0 Then r1.y - 1 Else r2.y +1); z =  r2.z + 2} </pre>
(you only need to give a legal type, not show the full type derivation)<br>
b) Now write a nontrivial subtype of your answer to a) which changes as
  many of the record types as you can.<br>
c) Like b) but make a supertype.
      <p>
 
 <li>(12 pts) Joey had too much sugar while doing his PL homework and he coded
     all his recursive functions incorrectly -- for example for the
     summate function he wrote
     <pre>
     Y (Function arg -> Function this ->
           If arg = 0 Then 0 Else arg + this (arg - 1)) 5
</pre>
     reversing <code>arg</code> and <code>this</code>.<br>
a) What would happen if the above code was fed into Joeys (correct)
     <code>Fb</code> interpreter?<br>
b) Write a combinator (<strong>Fb</strong> expression)
     <code>reversem</code> which we can
     put between Joey's bad code and <code>Y</code> to fix his
     argument out-of-order problem:
       <pre>
     Y (reversem (Function arg -> Function this ->
           If arg = 0 Then 0 Else arg + this (arg - 1))) 5
</pre>
     will now run fine.<br>
c) On some of the other examples Joey forgot that he didn't need to
     pass <code>this</code> to itself and he wrote a recursive
     function like
      <pre>
     Y (Function this -> Function arg ->
           If arg = 0 Then 0 Else arg + this this (arg - 1)) 5
</pre>
 (two <code>this</code>'s). Write a <code>thisthis2this</code>
     combinator to fix this bug, i.e. so that
         <pre>
     Y (thisthis2this (Function this -> Function arg ->
           If arg = 0 Then 0 Else arg + this this (arg - 1))) 5
</pre>
now works.     
<p>

<li>(12 pts)  a) Show you recall how simple objects may be encoded in
    <strong>FbSR</strong> by writing a class (as a
    <strong>FbSR</strong> function) which creates
    people objects containing fields including a <code>height</code>
    in inches and <code>weight</code> in pounds.  Include methods
    <code>isFat()</code> which returns <code>True</code> iff their
    weight is over 250 lbs and <code>diet()</code> which does nothing
    if they are not fat (use the <code>isFat</code> method to
    determine that) but reduces their weight by 10 lbs if they are
    fat.  Test your class by writing code which creates a
    <code>person</code> object that is fat and asks them to
    <code>diet()</code>. (note, you can assume a <code>greater-than</code> function
    was already written)
<br>
    b) The method for writing message send in the above is mildly annoying in that
    we have to pass the object itself as an argument.  Explain why it
    would <em>not</em> be possible to create a <strong>FbSR</strong> function
    <code>msgSend</code> for which 
    <pre>msgSend person isfat 0</pre> (function is passed three
    arguments, the object, the message name and the argument, in this
    case a dummy <code>0</code>) would send the message
    <code>isfat</code> to object <code>person</code> and we
    wouldn't have to think about passing the object itself.<br>
    c) One somewhat gross solution that would work is if the user
    instead wrote
    <pre>msgSend person (Function ob -> ob.isFat) 0</pre>
    -- write function <code>msgSend</code> such that the above
    invocation would send message <code>isFat</code> to your encoded
    <code>person</code> object.<br>
    d) Perhaps a better solution would be to "pre-apply" the object
    itself so that the methods already had the self passed to them.
    Given your <code>person</code> object coded above, code a
    <code>betterPerson</code> which uses <code>person</code> and for
    which you only need to write
    <code>betterPerson.isFat(0)</code> to send a message, the self
    parameter can be skipped because it was pre-applied.

    <p>

<li>(15 points) Describe how our <strong>EFb</strong> type inference language
    could be extended to an <strong>EFbS</strong> (adding state)
    type inference language:
    <br> a) Write out the new type rules if any that we would add;
    <br> b) Write out the new closure rules if any that we would add.
<br>c) Write any new cases of constraints which are obviously
    inconsistent and which we would need to add to our inconsistency check.
<br>
d) Defining an <strong>EFbR</strong> extension to records is in fact
    quite difficult; make a stab at it and describe why it is hard to
    get it to work.<p>


</ol>

<p>
<br>
<br>

</BODY> </html>

