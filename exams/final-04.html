<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<HEAD>
<title>PL Final 2004</title>
</HEAD>
<BODY LINK="#0000FF" VLINK="#800080" bgcolor="#F0FFF0">
<h3> 600.426, Programming Languages
<br> Spring 2004
<br> Final Examination
<br> 
</h3>
You can use one handwritten 8.5x11 cheat sheet.
<strong>Good Luck!</strong>
<hr>
<ol><h4>Short Answer</h4>

<li> (2 points) In Caml, <code>let</code>-defined variables are
      <em>mutable</em>. True or False?

<li> (2 points) Does <strong>D</strong> support currying? If yes, give an
	    example in concrete syntax. If not, why?


<li>(3 points)
   Give a carefully reasoned argument for why <code>x</code> (the
	  program fragment consisting of just the variable
	  <code>x</code>) is not 
	  operationally equivalent to <code>y</code> in <strong>D</strong>.
<li>(3 points) Operational equivalence is not a perfect definition of
    equivalence: describe two <strong>DSR</strong> programs that are
    operationally 
    equivalent, yet when used (in e.g. the <strong>DSR</strong>
    top-loop) would produce observably different behavior to the user.

<li> (4 points) Is the program <code>let rec f x = f x</code>
	      well-typed in
      Caml. If yes, what is its inferred type? If not, why?

<li> (6 points) Consider the following Caml top-loop session:
<pre>
        Objective Caml version 3.07+2

# let curry f = function x -> function y -> f (x, y);;
val curry : ('a * 'b -> 'c) -> 'a -> 'b -> 'c = &lt;fun&gt;
# let add x y = x + y;;
val add : int -> int -> int = &lt;fun&gt;
# curry add;;
</pre>
What do you think should happen on hitting enter after the last line
		<em>i.e.,</em><code>curry add;;</code>? If there
		is a type-error, explain
		the type-error in your own words; otherwise, give the
		resulting expression with its type.
<li>(6 points) Consider the example of encoding point/colorpoint classes in DSR:
    <pre>
    Let pointClass = Function _ ->
             { x = Ref 3; y = Ref 4;
             magnitude = Function self -> Function _ -> sqrt(!(self.x) + !(self.y));
             isnull = Function self -> Function _ ->   self.magnitude(self) = 0
             setx = Function self -> Function newx -> (self.x) := newx;
             sety = ... }
    In 
    Let colorPointClass = Function _ ->
          Let super = pointClass () In
             { x = super.x; y = super.y;
             color = Ref  { red = 45; green = 20; blue = 20 };
             magnitude =
                Function self -> Function _ -> super.magnitude self () *
                                   self.brightness self;
             isnull = super.isnull;
             brightness = Function self -> Function _ -> ... compute brightness  ...;
             setx = super.setx
             sety = super.sety; setcolor = ... }
In ...
    
</pre>
    a) For a warm-up, write followon code which creates a colorPoint
    object and sends it the isnull message. <br>
b) What would OCaml do if fed the above program including your
    example from a) (turn the reserved words into lower case so the
    program is in OCaml syntax first)?<br>
c) In this encoding, if we instead defined <code>x</code> in
    colorPointClass as <code>.. x = Ref 2; ..</code>, can we still
    access the superclass' x value (initially 3) from magnitude, or is that now
    inaccessible? <br>
d) Supposing we create a colorPoint and send it a
    magnitude message immediately -- will the code
    <code>!(self.x)</code> of the superclass that is executed by
    <code>super.magnitude</code> return <code>3</code> or <code>2</code>?

<li>(6 points) I have exactly two files in the current directory:
		  <code>set.mli</code> and <code>main.ml</code> having
		  the following contents,
<pre>
set.mli
=======
val add: 'a -> 'a list -> 'a list
val contains: 'a -> 'a list -> bool


main.ml
=======
let mySet = Set.add 5 [] in
   let found = Set.contains 5 mySet in
      print_string ((string_of_bool found) ^ "\n")
</pre>
I run the following commands on the shell prompt one after the other
		  in the given order:
<pre>
ocamlc -c set.mli
ocamlc -c main.ml
ocamlc -o main set.cmo main.cmo
</pre>
Which of the above commands succeed? Give a short explanation of your answer.



<li>(6 points) When Joe wrote out his complete <strong>DSR</strong>
    compiler definition, he 
    <em>forgot</em> to perform the closure conversion step. 
    <dl>
      <dd> a) Give an example program that Joe's compiler would fail on.
      <dd> b) What subsequent phase of the compiler would be
    incorrect, i.e. do a transformation that was bad?  Illustrate
    the incorrect transformation with your example from a).
    </dl>

<li> (6 points) Suppose Joe was a little sleep-deprived when writing his
	  typechecker for <strong>TD</strong>, and appended the
	  function identifiers at the
	  tail (instead of head) of <code>gamma</code>, as in:
<pre>
let rec typecheck gamma e =
  match e with
    (* look up first mapping of x in list gamma *)
    Var x -> lookup gamma x
  | Function(Ide x,t,e) ->
      let t' = typecheck (<strong>gamma @ [((Ide x),t)]</strong>) e in
      Arrow(t,t') 
  | ...
</pre>
 The <code>lookup gamma x</code>,
	  however, starts looking for  <code>x</code> from the head of
	  <code>gamma</code>. 
      Give a <em>valid</em> <strong>TD</strong> program which
	  would help the TA  detect the Sleepy Joe Error <em>i.e.,</em> Joe's
	  typechecker will fail to typecheck it.


<li> (8 points) Write a subtype of the following type:
<pre>
( {x : Int} -> {x : {x:Int; y:Int}} ) -> {x:Int; y:Int} -> {x:Int; y: Int; z:Int}
</pre>
<em>Note</em>: None of the component-record types of your subtype
		  should be identical to the corresponding record
		  types of the above type.



<h4>Longer Answer</h4>

<li> (16 points) Consider a new language <strong>DXA</strong>: <strong>DX</strong>
      with <em>arrays</em>, which
      are similar to arrays in Caml. These arrays have a fixed length
      but <em>unlike</em> Caml their elements are <em>immutable</em>. 
      The following is the concrete syntax for
      arrays and array operations:
      <ul>
	<li><code>[| |]</code>, the empty array
	<li><code>[| e1; ...; en |]</code>, initial array - indexed
	  from integers <code>0</code> to <code>n-1</code>
	<li><code>e.(e')</code>, if index <code>e'</code> is within bounds then
	  returns corresponding element else raises exception
	  <code>#ArrayIndexOutOfBounds i</code>, where <code>i</code>
	  is the out of bound index.
	<li><code>e.(e') &lt;- e''</code>, returns a <em>new</em>
	  array or raises exception <code>#ArrayIndexOutOfBounds i</code>, where <code>i</code>
	  is the out of bound index.
      </ul>
      Write the operational semantics rules for
      <strong>DXA</strong>. You need to give all the rules for
      arrays, but don't need to repeat any of the <strong>DX</strong> rules.
<br><br>
The following are examples of array expressions, their corresponding
      types (for the subsequent problem) and evaluated results:
      <pre>
# [|10; 20; 30|];;
==> Int Array = [|10; 20; 30|]
# [|10; 20; 30|].(2);;
==> Int = 30
# Try
     [|10; 20; 30|].(5)
  With
     #ArrayIndexOutOfBounds i -> 999;;
==> Int = 999
# [|10; 20; 30|].(2) <- 40;;
==> Int Array = [|10; 20; 40|]
# Try
     [|10; 20; 30|].(5) <- 40
  With
     #ArrayIndexOutOfBounds i -> 999;;
==> Int = 999

      </pre>

<li> (10 points) Write the type rules for <strong>TDXA</strong>:
	<strong>TDX</strong> with the same array
	syntax. <strong>TDXA</strong> in addition to the types of
	<strong>TDX</strong> has type <code>tau Array</code>. Give
	the new type rules for the array constructs.


</ol> 


</BODY> </html>


<hr>
</body> </html>



